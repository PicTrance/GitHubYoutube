CCS PCH C Compiler, Version 5.105, 4770               24-abr.-22 21:38

               Filename:   D:\OneDrive - Soluciones Marva\YouTubeCanal\GitHub\CCS\Horno\horno3.lst

               ROM used:   5118 bytes (16%)
                           Largest free fragment is 27650
               RAM used:   121 (6%) at main() level
                           145 (7%) worst case
               Stack used: 0 locations
               Stack size: 31

*
0000:  GOTO   0E7E
.................... #include <18F4550.h>
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
0004:  DATA 53,45
0006:  DATA 54,20
0008:  DATA 50,4F
000A:  DATA 49,4E
000C:  DATA 54,20
000E:  DATA 25,66
0010:  DATA 20,20
0012:  DATA 20,20
0014:  DATA 20,20
0016:  DATA 20,00
0018:  DATA 20,20
001A:  DATA 20,20
001C:  DATA 20,20
001E:  DATA 20,20
0020:  DATA 20,20
0022:  DATA 20,20
0024:  DATA 20,20
0026:  DATA 20,20
0028:  DATA 20,20
002A:  DATA 20,00
002C:  DATA 53,45
002E:  DATA 54,20
0030:  DATA 50,4F
0032:  DATA 49,4E
0034:  DATA 54,20
0036:  DATA 25,66
0038:  DATA 20,20
003A:  DATA 20,20
003C:  DATA 20,20
003E:  DATA 20,00
0040:  DATA 54,45
0042:  DATA 4D,50
0044:  DATA 45,52
0046:  DATA 41,54
0048:  DATA 55,52
004A:  DATA 41,20
004C:  DATA 25,66
004E:  DATA 20,20
0050:  DATA 20,20
0052:  DATA 20,20
0054:  DATA 20,00
0056:  MOVLW  8E
0058:  MOVWF  00
005A:  MOVFF  75,01
005E:  MOVFF  74,02
0062:  CLRF   03
0064:  MOVF   01,F
0066:  BNZ   007A
0068:  MOVFF  02,01
006C:  CLRF   02
006E:  MOVLW  08
0070:  SUBWF  00,F
0072:  MOVF   01,F
0074:  BNZ   007A
0076:  CLRF   00
0078:  BRA    008A
007A:  BCF    FD8.0
007C:  BTFSC  01.7
007E:  BRA    0088
0080:  RLCF   02,F
0082:  RLCF   01,F
0084:  DECF   00,F
0086:  BRA    007A
0088:  BCF    01.7
008A:  RETURN 0
*
036E:  CLRF   00
0370:  CLRF   01
0372:  MOVF   x7B,W
0374:  BCF    FD8.0
0376:  BTFSC  x7C.0
0378:  ADDWF  00,F
037A:  RRCF   00,F
037C:  RRCF   01,F
037E:  BTFSC  x7C.1
0380:  ADDWF  00,F
0382:  RRCF   00,F
0384:  RRCF   01,F
0386:  BTFSC  x7C.2
0388:  ADDWF  00,F
038A:  RRCF   00,F
038C:  RRCF   01,F
038E:  BTFSC  x7C.3
0390:  ADDWF  00,F
0392:  RRCF   00,F
0394:  RRCF   01,F
0396:  BTFSC  x7C.4
0398:  ADDWF  00,F
039A:  RRCF   00,F
039C:  RRCF   01,F
039E:  BTFSC  x7C.5
03A0:  ADDWF  00,F
03A2:  RRCF   00,F
03A4:  RRCF   01,F
03A6:  BTFSC  x7C.6
03A8:  ADDWF  00,F
03AA:  RRCF   00,F
03AC:  RRCF   01,F
03AE:  BTFSC  x7C.7
03B0:  ADDWF  00,F
03B2:  RRCF   00,F
03B4:  RRCF   01,F
03B6:  GOTO   0486 (RETURN)
*
05B6:  TBLRD*+
05B8:  MOVFF  FF6,75
05BC:  MOVFF  FF7,76
05C0:  MOVFF  FF5,81
05C4:  RCALL  0566
05C6:  MOVFF  75,FF6
05CA:  MOVFF  76,FF7
05CE:  DECFSZ x74,F
05D0:  BRA    05B6
05D2:  RETURN 0
05D4:  MOVF   x81,W
05D6:  BTFSC  FD8.2
05D8:  BRA    06BC
05DA:  MOVWF  00
05DC:  MOVF   x88,W
05DE:  BTFSC  FD8.2
05E0:  BRA    06BC
05E2:  ADDWF  00,F
05E4:  BNC   05EE
05E6:  MOVLW  81
05E8:  ADDWF  00,F
05EA:  BC    06BC
05EC:  BRA    05F6
05EE:  MOVLW  7F
05F0:  SUBWF  00,F
05F2:  BNC   06BC
05F4:  BZ    06BC
05F6:  MOVFF  82,8C
05FA:  MOVF   x89,W
05FC:  XORWF  x8C,F
05FE:  BSF    x82.7
0600:  BSF    x89.7
0602:  MOVF   x84,W
0604:  MULWF  x8B
0606:  MOVFF  FF4,8E
060A:  MOVF   x83,W
060C:  MULWF  x8A
060E:  MOVFF  FF4,03
0612:  MOVFF  FF3,8D
0616:  MULWF  x8B
0618:  MOVF   FF3,W
061A:  ADDWF  x8E,F
061C:  MOVF   FF4,W
061E:  ADDWFC x8D,F
0620:  MOVLW  00
0622:  ADDWFC 03,F
0624:  MOVF   x84,W
0626:  MULWF  x8A
0628:  MOVF   FF3,W
062A:  ADDWF  x8E,F
062C:  MOVF   FF4,W
062E:  ADDWFC x8D,F
0630:  MOVLW  00
0632:  CLRF   02
0634:  ADDWFC 03,F
0636:  ADDWFC 02,F
0638:  MOVF   x82,W
063A:  MULWF  x8B
063C:  MOVF   FF3,W
063E:  ADDWF  x8D,F
0640:  MOVF   FF4,W
0642:  ADDWFC 03,F
0644:  MOVLW  00
0646:  ADDWFC 02,F
0648:  MOVF   x82,W
064A:  MULWF  x8A
064C:  MOVF   FF3,W
064E:  ADDWF  03,F
0650:  MOVF   FF4,W
0652:  ADDWFC 02,F
0654:  MOVLW  00
0656:  CLRF   01
0658:  ADDWFC 01,F
065A:  MOVF   x84,W
065C:  MULWF  x89
065E:  MOVF   FF3,W
0660:  ADDWF  x8D,F
0662:  MOVF   FF4,W
0664:  ADDWFC 03,F
0666:  MOVLW  00
0668:  ADDWFC 02,F
066A:  ADDWFC 01,F
066C:  MOVF   x83,W
066E:  MULWF  x89
0670:  MOVF   FF3,W
0672:  ADDWF  03,F
0674:  MOVF   FF4,W
0676:  ADDWFC 02,F
0678:  MOVLW  00
067A:  ADDWFC 01,F
067C:  MOVF   x82,W
067E:  MULWF  x89
0680:  MOVF   FF3,W
0682:  ADDWF  02,F
0684:  MOVF   FF4,W
0686:  ADDWFC 01,F
0688:  INCF   00,F
068A:  BTFSC  01.7
068C:  BRA    0698
068E:  RLCF   x8D,F
0690:  RLCF   03,F
0692:  RLCF   02,F
0694:  RLCF   01,F
0696:  DECF   00,F
0698:  MOVLW  00
069A:  BTFSS  x8D.7
069C:  BRA    06B2
069E:  INCF   03,F
06A0:  ADDWFC 02,F
06A2:  ADDWFC 01,F
06A4:  MOVF   01,W
06A6:  BNZ   06B2
06A8:  MOVF   02,W
06AA:  BNZ   06B2
06AC:  MOVF   03,W
06AE:  BNZ   06B2
06B0:  INCF   00,F
06B2:  BTFSC  x8C.7
06B4:  BSF    01.7
06B6:  BTFSS  x8C.7
06B8:  BCF    01.7
06BA:  BRA    06C4
06BC:  CLRF   00
06BE:  CLRF   01
06C0:  CLRF   02
06C2:  CLRF   03
06C4:  RETURN 0
06C6:  MOVF   x81,W
06C8:  SUBLW  B6
06CA:  MOVWF  x81
06CC:  CLRF   03
06CE:  MOVFF  82,85
06D2:  BSF    x82.7
06D4:  BCF    FD8.0
06D6:  RRCF   x82,F
06D8:  RRCF   x83,F
06DA:  RRCF   x84,F
06DC:  RRCF   03,F
06DE:  RRCF   02,F
06E0:  RRCF   01,F
06E2:  RRCF   00,F
06E4:  DECFSZ x81,F
06E6:  BRA    06D4
06E8:  BTFSS  x85.7
06EA:  BRA    0702
06EC:  COMF   00,F
06EE:  COMF   01,F
06F0:  COMF   02,F
06F2:  COMF   03,F
06F4:  INCF   00,F
06F6:  BTFSC  FD8.2
06F8:  INCF   01,F
06FA:  BTFSC  FD8.2
06FC:  INCF   02,F
06FE:  BTFSC  FD8.2
0700:  INCF   03,F
0702:  GOTO   07E2 (RETURN)
0706:  BTFSC  FD8.1
0708:  BRA    0710
070A:  CLRF   FEA
070C:  MOVLW  8C
070E:  MOVWF  FE9
0710:  CLRF   00
0712:  CLRF   01
0714:  CLRF   02
0716:  CLRF   03
0718:  CLRF   x8C
071A:  CLRF   x8D
071C:  CLRF   x8E
071E:  CLRF   x8F
0720:  MOVF   x8B,W
0722:  IORWF  x8A,W
0724:  IORWF  x89,W
0726:  IORWF  x88,W
0728:  BZ    0782
072A:  MOVLW  20
072C:  MOVWF  x90
072E:  BCF    FD8.0
0730:  RLCF   x81,F
0732:  RLCF   x82,F
0734:  RLCF   x83,F
0736:  RLCF   x84,F
0738:  RLCF   x8C,F
073A:  RLCF   x8D,F
073C:  RLCF   x8E,F
073E:  RLCF   x8F,F
0740:  MOVF   x8B,W
0742:  SUBWF  x8F,W
0744:  BNZ   0756
0746:  MOVF   x8A,W
0748:  SUBWF  x8E,W
074A:  BNZ   0756
074C:  MOVF   x89,W
074E:  SUBWF  x8D,W
0750:  BNZ   0756
0752:  MOVF   x88,W
0754:  SUBWF  x8C,W
0756:  BNC   0776
0758:  MOVF   x88,W
075A:  SUBWF  x8C,F
075C:  MOVF   x89,W
075E:  BTFSS  FD8.0
0760:  INCFSZ x89,W
0762:  SUBWF  x8D,F
0764:  MOVF   x8A,W
0766:  BTFSS  FD8.0
0768:  INCFSZ x8A,W
076A:  SUBWF  x8E,F
076C:  MOVF   x8B,W
076E:  BTFSS  FD8.0
0770:  INCFSZ x8B,W
0772:  SUBWF  x8F,F
0774:  BSF    FD8.0
0776:  RLCF   00,F
0778:  RLCF   01,F
077A:  RLCF   02,F
077C:  RLCF   03,F
077E:  DECFSZ x90,F
0780:  BRA    072E
0782:  MOVFF  8C,FEF
0786:  MOVFF  8D,FEC
078A:  MOVFF  8E,FEC
078E:  MOVFF  8F,FEC
0792:  RETURN 0
0794:  MOVF   FE9,W
0796:  MOVWF  x79
0798:  MOVF   x78,W
079A:  MOVWF  x7B
079C:  BZ    07D0
079E:  MOVFF  77,84
07A2:  MOVFF  76,83
07A6:  MOVFF  75,82
07AA:  MOVFF  74,81
07AE:  CLRF   x8B
07B0:  CLRF   x8A
07B2:  MOVLW  20
07B4:  MOVWF  x89
07B6:  MOVLW  82
07B8:  MOVWF  x88
07BA:  RCALL  05D4
07BC:  MOVFF  03,77
07C0:  MOVFF  02,76
07C4:  MOVFF  01,75
07C8:  MOVFF  00,74
07CC:  DECFSZ x7B,F
07CE:  BRA    079E
07D0:  MOVFF  77,84
07D4:  MOVFF  76,83
07D8:  MOVFF  75,82
07DC:  MOVFF  74,81
07E0:  BRA    06C6
07E2:  MOVFF  03,77
07E6:  MOVFF  02,76
07EA:  MOVFF  01,75
07EE:  MOVFF  00,74
07F2:  BTFSS  x77.7
07F4:  BRA    0810
07F6:  DECF   x79,F
07F8:  BSF    x79.5
07FA:  COMF   x74,F
07FC:  COMF   x75,F
07FE:  COMF   x76,F
0800:  COMF   x77,F
0802:  INCF   x74,F
0804:  BTFSC  FD8.2
0806:  INCF   x75,F
0808:  BTFSC  FD8.2
080A:  INCF   x76,F
080C:  BTFSC  FD8.2
080E:  INCF   x77,F
0810:  MOVLW  3B
0812:  MOVWF  x80
0814:  MOVLW  9A
0816:  MOVWF  x7F
0818:  MOVLW  CA
081A:  MOVWF  x7E
081C:  CLRF   x7D
081E:  MOVLW  0A
0820:  MOVWF  x7B
0822:  MOVF   x78,W
0824:  BTFSC  FD8.2
0826:  INCF   x79,F
0828:  BSF    FD8.1
082A:  CLRF   FEA
082C:  MOVLW  74
082E:  MOVWF  FE9
0830:  MOVFF  77,84
0834:  MOVFF  76,83
0838:  MOVFF  75,82
083C:  MOVFF  74,81
0840:  MOVFF  80,8B
0844:  MOVFF  7F,8A
0848:  MOVFF  7E,89
084C:  MOVFF  7D,88
0850:  RCALL  0706
0852:  MOVF   01,W
0854:  MOVF   00,F
0856:  BNZ   0876
0858:  INCF   x78,W
085A:  SUBWF  x7B,W
085C:  BZ    0876
085E:  MOVF   x79,W
0860:  BZ    087A
0862:  ANDLW  0F
0864:  SUBWF  x7B,W
0866:  BZ    086A
0868:  BC    08D8
086A:  BTFSC  x79.7
086C:  BRA    08D8
086E:  BTFSC  x79.6
0870:  BRA    087A
0872:  MOVLW  20
0874:  BRA    08D0
0876:  MOVLW  20
0878:  ANDWF  x79,F
087A:  BTFSS  x79.5
087C:  BRA    0896
087E:  BCF    x79.5
0880:  MOVF   x78,W
0882:  BTFSS  FD8.2
0884:  DECF   x79,F
0886:  MOVF   00,W
0888:  MOVWF  x79
088A:  MOVLW  2D
088C:  MOVWF  x81
088E:  RCALL  0566
0890:  MOVF   x79,W
0892:  MOVWF  00
0894:  CLRF   x79
0896:  MOVF   x78,W
0898:  SUBWF  x7B,W
089A:  BNZ   08B0
089C:  MOVF   00,W
089E:  MOVWF  x79
08A0:  MOVLW  2E
08A2:  MOVWF  x81
08A4:  RCALL  0566
08A6:  MOVF   x79,W
08A8:  MOVWF  00
08AA:  MOVLW  20
08AC:  ANDWF  x79,F
08AE:  MOVLW  00
08B0:  MOVLW  30
08B2:  BTFSS  x79.5
08B4:  BRA    08D0
08B6:  BCF    x79.5
08B8:  MOVF   x78,W
08BA:  BTFSS  FD8.2
08BC:  DECF   x79,F
08BE:  MOVF   00,W
08C0:  MOVWF  x79
08C2:  MOVLW  2D
08C4:  MOVWF  x81
08C6:  RCALL  0566
08C8:  MOVF   x79,W
08CA:  MOVWF  00
08CC:  CLRF   x79
08CE:  MOVLW  30
08D0:  ADDWF  00,F
08D2:  MOVFF  00,81
08D6:  RCALL  0566
08D8:  BCF    FD8.1
08DA:  MOVFF  80,84
08DE:  MOVFF  7F,83
08E2:  MOVFF  7E,82
08E6:  MOVFF  7D,81
08EA:  CLRF   x8B
08EC:  CLRF   x8A
08EE:  CLRF   x89
08F0:  MOVLW  0A
08F2:  MOVWF  x88
08F4:  RCALL  0706
08F6:  MOVFF  03,80
08FA:  MOVFF  02,7F
08FE:  MOVFF  01,7E
0902:  MOVFF  00,7D
0906:  DECFSZ x7B,F
0908:  BRA    0828
090A:  RETURN 0
090C:  TBLRD*+
090E:  MOVF   FF5,F
0910:  BZ    092A
0912:  MOVFF  FF6,74
0916:  MOVFF  FF7,75
091A:  MOVFF  FF5,81
091E:  RCALL  0566
0920:  MOVFF  74,FF6
0924:  MOVFF  75,FF7
0928:  BRA    090C
092A:  GOTO   09E4 (RETURN)
*
0A08:  MOVF   x78,W
0A0A:  BTFSC  FD8.2
0A0C:  BRA    0B58
0A0E:  MOVWF  x84
0A10:  MOVF   x7C,W
0A12:  BTFSC  FD8.2
0A14:  BRA    0B58
0A16:  SUBWF  x84,F
0A18:  BNC   0A24
0A1A:  MOVLW  7F
0A1C:  ADDWF  x84,F
0A1E:  BTFSC  FD8.0
0A20:  BRA    0B58
0A22:  BRA    0A30
0A24:  MOVLW  81
0A26:  SUBWF  x84,F
0A28:  BTFSS  FD8.0
0A2A:  BRA    0B58
0A2C:  BTFSC  FD8.2
0A2E:  BRA    0B58
0A30:  MOVFF  84,00
0A34:  CLRF   01
0A36:  CLRF   02
0A38:  CLRF   03
0A3A:  CLRF   x83
0A3C:  MOVFF  79,82
0A40:  BSF    x82.7
0A42:  MOVFF  7A,81
0A46:  MOVFF  7B,80
0A4A:  MOVLW  19
0A4C:  MOVWF  x84
0A4E:  MOVF   x7F,W
0A50:  SUBWF  x80,F
0A52:  BC    0A6E
0A54:  MOVLW  01
0A56:  SUBWF  x81,F
0A58:  BC    0A6E
0A5A:  SUBWF  x82,F
0A5C:  BC    0A6E
0A5E:  SUBWF  x83,F
0A60:  BC    0A6E
0A62:  INCF   x83,F
0A64:  INCF   x82,F
0A66:  INCF   x81,F
0A68:  MOVF   x7F,W
0A6A:  ADDWF  x80,F
0A6C:  BRA    0ABE
0A6E:  MOVF   x7E,W
0A70:  SUBWF  x81,F
0A72:  BC    0A98
0A74:  MOVLW  01
0A76:  SUBWF  x82,F
0A78:  BC    0A98
0A7A:  SUBWF  x83,F
0A7C:  BC    0A98
0A7E:  INCF   x83,F
0A80:  INCF   x82,F
0A82:  MOVF   x7E,W
0A84:  ADDWF  x81,F
0A86:  MOVF   x7F,W
0A88:  ADDWF  x80,F
0A8A:  BNC   0ABE
0A8C:  INCF   x81,F
0A8E:  BNZ   0ABE
0A90:  INCF   x82,F
0A92:  BNZ   0ABE
0A94:  INCF   x83,F
0A96:  BRA    0ABE
0A98:  MOVF   x7D,W
0A9A:  IORLW  80
0A9C:  SUBWF  x82,F
0A9E:  BC    0ABC
0AA0:  MOVLW  01
0AA2:  SUBWF  x83,F
0AA4:  BC    0ABC
0AA6:  INCF   x83,F
0AA8:  MOVF   x7D,W
0AAA:  IORLW  80
0AAC:  ADDWF  x82,F
0AAE:  MOVF   x7E,W
0AB0:  ADDWF  x81,F
0AB2:  BNC   0A86
0AB4:  INCF   x82,F
0AB6:  BNZ   0A86
0AB8:  INCF   x83,F
0ABA:  BRA    0A86
0ABC:  BSF    03.0
0ABE:  DECFSZ x84,F
0AC0:  BRA    0AC4
0AC2:  BRA    0ADA
0AC4:  BCF    FD8.0
0AC6:  RLCF   x80,F
0AC8:  RLCF   x81,F
0ACA:  RLCF   x82,F
0ACC:  RLCF   x83,F
0ACE:  BCF    FD8.0
0AD0:  RLCF   03,F
0AD2:  RLCF   02,F
0AD4:  RLCF   01,F
0AD6:  RLCF   x85,F
0AD8:  BRA    0A4E
0ADA:  BTFSS  x85.0
0ADC:  BRA    0AEA
0ADE:  BCF    FD8.0
0AE0:  RRCF   01,F
0AE2:  RRCF   02,F
0AE4:  RRCF   03,F
0AE6:  RRCF   x85,F
0AE8:  BRA    0AEE
0AEA:  DECF   00,F
0AEC:  BZ    0B58
0AEE:  BTFSC  x85.7
0AF0:  BRA    0B2E
0AF2:  BCF    FD8.0
0AF4:  RLCF   x80,F
0AF6:  RLCF   x81,F
0AF8:  RLCF   x82,F
0AFA:  RLCF   x83,F
0AFC:  MOVF   x7F,W
0AFE:  SUBWF  x80,F
0B00:  BC    0B10
0B02:  MOVLW  01
0B04:  SUBWF  x81,F
0B06:  BC    0B10
0B08:  SUBWF  x82,F
0B0A:  BC    0B10
0B0C:  SUBWF  x83,F
0B0E:  BNC   0B44
0B10:  MOVF   x7E,W
0B12:  SUBWF  x81,F
0B14:  BC    0B20
0B16:  MOVLW  01
0B18:  SUBWF  x82,F
0B1A:  BC    0B20
0B1C:  SUBWF  x83,F
0B1E:  BNC   0B44
0B20:  MOVF   x7D,W
0B22:  IORLW  80
0B24:  SUBWF  x82,F
0B26:  BC    0B2E
0B28:  MOVLW  01
0B2A:  SUBWF  x83,F
0B2C:  BNC   0B44
0B2E:  INCF   03,F
0B30:  BNZ   0B44
0B32:  INCF   02,F
0B34:  BNZ   0B44
0B36:  INCF   01,F
0B38:  BNZ   0B44
0B3A:  INCF   00,F
0B3C:  BZ    0B58
0B3E:  RRCF   01,F
0B40:  RRCF   02,F
0B42:  RRCF   03,F
0B44:  MOVFF  79,84
0B48:  MOVF   x7D,W
0B4A:  XORWF  x84,F
0B4C:  BTFSS  x84.7
0B4E:  BRA    0B54
0B50:  BSF    01.7
0B52:  BRA    0B60
0B54:  BCF    01.7
0B56:  BRA    0B60
0B58:  CLRF   00
0B5A:  CLRF   01
0B5C:  CLRF   02
0B5E:  CLRF   03
0B60:  GOTO   1014 (RETURN)
0B64:  MOVLW  80
0B66:  BTFSC  FD8.1
0B68:  XORWF  x7D,F
0B6A:  CLRF   x8A
0B6C:  CLRF   x8B
0B6E:  MOVFF  79,89
0B72:  MOVF   x7D,W
0B74:  XORWF  x89,F
0B76:  MOVF   x78,W
0B78:  BTFSC  FD8.2
0B7A:  BRA    0D34
0B7C:  MOVWF  x88
0B7E:  MOVWF  00
0B80:  MOVF   x7C,W
0B82:  BTFSC  FD8.2
0B84:  BRA    0D46
0B86:  SUBWF  x88,F
0B88:  BTFSC  FD8.2
0B8A:  BRA    0C8E
0B8C:  BNC   0C08
0B8E:  MOVFF  7D,8E
0B92:  BSF    x8E.7
0B94:  MOVFF  7E,8D
0B98:  MOVFF  7F,8C
0B9C:  CLRF   x8B
0B9E:  BCF    FD8.0
0BA0:  RRCF   x8E,F
0BA2:  RRCF   x8D,F
0BA4:  RRCF   x8C,F
0BA6:  RRCF   x8B,F
0BA8:  DECFSZ x88,F
0BAA:  BRA    0B9C
0BAC:  BTFSS  x89.7
0BAE:  BRA    0BB6
0BB0:  BSF    x8A.0
0BB2:  BRA    0D6E
0BB4:  BCF    x8A.0
0BB6:  BCF    x88.0
0BB8:  BSF    x8A.4
0BBA:  CLRF   FEA
0BBC:  MOVLW  7B
0BBE:  MOVWF  FE9
0BC0:  BRA    0D94
0BC2:  BCF    x8A.4
0BC4:  BTFSC  x89.7
0BC6:  BRA    0BDC
0BC8:  BTFSS  x88.0
0BCA:  BRA    0BF2
0BCC:  RRCF   x8E,F
0BCE:  RRCF   x8D,F
0BD0:  RRCF   x8C,F
0BD2:  RRCF   x8B,F
0BD4:  INCF   00,F
0BD6:  BTFSC  FD8.2
0BD8:  BRA    0D64
0BDA:  BRA    0BF2
0BDC:  BTFSC  x8E.7
0BDE:  BRA    0BF8
0BE0:  BCF    FD8.0
0BE2:  RLCF   x8B,F
0BE4:  RLCF   x8C,F
0BE6:  RLCF   x8D,F
0BE8:  RLCF   x8E,F
0BEA:  DECF   00,F
0BEC:  BTFSC  FD8.2
0BEE:  BRA    0D64
0BF0:  BRA    0BDC
0BF2:  BSF    x8A.6
0BF4:  BRA    0CCC
0BF6:  BCF    x8A.6
0BF8:  MOVFF  79,89
0BFC:  BTFSS  x79.7
0BFE:  BRA    0C04
0C00:  BSF    x8E.7
0C02:  BRA    0D56
0C04:  BCF    x8E.7
0C06:  BRA    0D56
0C08:  MOVFF  7C,88
0C0C:  MOVFF  7C,00
0C10:  MOVF   x78,W
0C12:  SUBWF  x88,F
0C14:  MOVFF  79,8E
0C18:  BSF    x8E.7
0C1A:  MOVFF  7A,8D
0C1E:  MOVFF  7B,8C
0C22:  CLRF   x8B
0C24:  BCF    FD8.0
0C26:  RRCF   x8E,F
0C28:  RRCF   x8D,F
0C2A:  RRCF   x8C,F
0C2C:  RRCF   x8B,F
0C2E:  DECFSZ x88,F
0C30:  BRA    0C22
0C32:  BTFSS  x89.7
0C34:  BRA    0C3C
0C36:  BSF    x8A.1
0C38:  BRA    0D6E
0C3A:  BCF    x8A.1
0C3C:  BCF    x88.0
0C3E:  BSF    x8A.5
0C40:  CLRF   FEA
0C42:  MOVLW  7F
0C44:  MOVWF  FE9
0C46:  BRA    0D94
0C48:  BCF    x8A.5
0C4A:  BTFSC  x89.7
0C4C:  BRA    0C62
0C4E:  BTFSS  x88.0
0C50:  BRA    0C78
0C52:  RRCF   x8E,F
0C54:  RRCF   x8D,F
0C56:  RRCF   x8C,F
0C58:  RRCF   x8B,F
0C5A:  INCF   00,F
0C5C:  BTFSC  FD8.2
0C5E:  BRA    0D64
0C60:  BRA    0C78
0C62:  BTFSC  x8E.7
0C64:  BRA    0C7E
0C66:  BCF    FD8.0
0C68:  RLCF   x8B,F
0C6A:  RLCF   x8C,F
0C6C:  RLCF   x8D,F
0C6E:  RLCF   x8E,F
0C70:  DECF   00,F
0C72:  BTFSC  FD8.2
0C74:  BRA    0D64
0C76:  BRA    0C62
0C78:  BSF    x8A.7
0C7A:  BRA    0CCC
0C7C:  BCF    x8A.7
0C7E:  MOVFF  7D,89
0C82:  BTFSS  x7D.7
0C84:  BRA    0C8A
0C86:  BSF    x8E.7
0C88:  BRA    0D56
0C8A:  BCF    x8E.7
0C8C:  BRA    0D56
0C8E:  MOVFF  7D,8E
0C92:  BSF    x8E.7
0C94:  MOVFF  7E,8D
0C98:  MOVFF  7F,8C
0C9C:  BTFSS  x89.7
0C9E:  BRA    0CA8
0CA0:  BCF    x8E.7
0CA2:  BSF    x8A.2
0CA4:  BRA    0D6E
0CA6:  BCF    x8A.2
0CA8:  CLRF   x8B
0CAA:  BCF    x88.0
0CAC:  CLRF   FEA
0CAE:  MOVLW  7B
0CB0:  MOVWF  FE9
0CB2:  BRA    0D94
0CB4:  BTFSC  x89.7
0CB6:  BRA    0CF0
0CB8:  MOVFF  79,89
0CBC:  BTFSS  x88.0
0CBE:  BRA    0CCC
0CC0:  RRCF   x8E,F
0CC2:  RRCF   x8D,F
0CC4:  RRCF   x8C,F
0CC6:  RRCF   x8B,F
0CC8:  INCF   00,F
0CCA:  BZ    0D64
0CCC:  BTFSS  x8B.7
0CCE:  BRA    0CE6
0CD0:  INCF   x8C,F
0CD2:  BNZ   0CE6
0CD4:  INCF   x8D,F
0CD6:  BNZ   0CE6
0CD8:  INCF   x8E,F
0CDA:  BNZ   0CE6
0CDC:  RRCF   x8E,F
0CDE:  RRCF   x8D,F
0CE0:  RRCF   x8C,F
0CE2:  INCF   00,F
0CE4:  BZ    0D64
0CE6:  BTFSC  x8A.6
0CE8:  BRA    0BF6
0CEA:  BTFSC  x8A.7
0CEC:  BRA    0C7C
0CEE:  BRA    0D28
0CF0:  MOVLW  80
0CF2:  XORWF  x8E,F
0CF4:  BTFSS  x8E.7
0CF6:  BRA    0D00
0CF8:  BRA    0D6E
0CFA:  MOVFF  7D,89
0CFE:  BRA    0D14
0D00:  MOVFF  79,89
0D04:  MOVF   x8E,F
0D06:  BNZ   0D14
0D08:  MOVF   x8D,F
0D0A:  BNZ   0D14
0D0C:  MOVF   x8C,F
0D0E:  BNZ   0D14
0D10:  CLRF   00
0D12:  BRA    0D56
0D14:  BTFSC  x8E.7
0D16:  BRA    0D28
0D18:  BCF    FD8.0
0D1A:  RLCF   x8B,F
0D1C:  RLCF   x8C,F
0D1E:  RLCF   x8D,F
0D20:  RLCF   x8E,F
0D22:  DECFSZ 00,F
0D24:  BRA    0D14
0D26:  BRA    0D64
0D28:  BTFSS  x89.7
0D2A:  BRA    0D30
0D2C:  BSF    x8E.7
0D2E:  BRA    0D56
0D30:  BCF    x8E.7
0D32:  BRA    0D56
0D34:  MOVFF  7C,00
0D38:  MOVFF  7D,8E
0D3C:  MOVFF  7E,8D
0D40:  MOVFF  7F,8C
0D44:  BRA    0D56
0D46:  MOVFF  78,00
0D4A:  MOVFF  79,8E
0D4E:  MOVFF  7A,8D
0D52:  MOVFF  7B,8C
0D56:  MOVFF  8E,01
0D5A:  MOVFF  8D,02
0D5E:  MOVFF  8C,03
0D62:  BRA    0DCC
0D64:  CLRF   00
0D66:  CLRF   01
0D68:  CLRF   02
0D6A:  CLRF   03
0D6C:  BRA    0DCC
0D6E:  CLRF   x8B
0D70:  COMF   x8C,F
0D72:  COMF   x8D,F
0D74:  COMF   x8E,F
0D76:  COMF   x8B,F
0D78:  INCF   x8B,F
0D7A:  BNZ   0D86
0D7C:  INCF   x8C,F
0D7E:  BNZ   0D86
0D80:  INCF   x8D,F
0D82:  BNZ   0D86
0D84:  INCF   x8E,F
0D86:  BTFSC  x8A.0
0D88:  BRA    0BB4
0D8A:  BTFSC  x8A.1
0D8C:  BRA    0C3A
0D8E:  BTFSC  x8A.2
0D90:  BRA    0CA6
0D92:  BRA    0CFA
0D94:  MOVF   FEF,W
0D96:  ADDWF  x8C,F
0D98:  BNC   0DA4
0D9A:  INCF   x8D,F
0D9C:  BNZ   0DA4
0D9E:  INCF   x8E,F
0DA0:  BTFSC  FD8.2
0DA2:  BSF    x88.0
0DA4:  MOVF   FED,F
0DA6:  MOVF   FEF,W
0DA8:  ADDWF  x8D,F
0DAA:  BNC   0DB2
0DAC:  INCF   x8E,F
0DAE:  BTFSC  FD8.2
0DB0:  BSF    x88.0
0DB2:  MOVF   FED,F
0DB4:  MOVF   FEF,W
0DB6:  BTFSC  FEF.7
0DB8:  BRA    0DBC
0DBA:  XORLW  80
0DBC:  ADDWF  x8E,F
0DBE:  BTFSC  FD8.0
0DC0:  BSF    x88.0
0DC2:  BTFSC  x8A.4
0DC4:  BRA    0BC2
0DC6:  BTFSC  x8A.5
0DC8:  BRA    0C48
0DCA:  BRA    0CB4
0DCC:  RETURN 0
0DCE:  MOVFF  75,7C
0DD2:  MOVF   x79,W
0DD4:  XORWF  x7C,F
0DD6:  BTFSS  x7C.7
0DD8:  BRA    0DE4
0DDA:  BCF    FD8.2
0DDC:  BCF    FD8.0
0DDE:  BTFSC  x75.7
0DE0:  BSF    FD8.0
0DE2:  BRA    0E42
0DE4:  MOVFF  75,7C
0DE8:  MOVFF  78,7D
0DEC:  MOVF   x74,W
0DEE:  SUBWF  x7D,F
0DF0:  BZ    0DFE
0DF2:  BTFSS  x7C.7
0DF4:  BRA    0E42
0DF6:  MOVF   FD8,W
0DF8:  XORLW  01
0DFA:  MOVWF  FD8
0DFC:  BRA    0E42
0DFE:  MOVFF  79,7D
0E02:  MOVF   x75,W
0E04:  SUBWF  x7D,F
0E06:  BZ    0E14
0E08:  BTFSS  x7C.7
0E0A:  BRA    0E42
0E0C:  MOVF   FD8,W
0E0E:  XORLW  01
0E10:  MOVWF  FD8
0E12:  BRA    0E42
0E14:  MOVFF  7A,7D
0E18:  MOVF   x76,W
0E1A:  SUBWF  x7D,F
0E1C:  BZ    0E2A
0E1E:  BTFSS  x7C.7
0E20:  BRA    0E42
0E22:  MOVF   FD8,W
0E24:  XORLW  01
0E26:  MOVWF  FD8
0E28:  BRA    0E42
0E2A:  MOVFF  7B,7D
0E2E:  MOVF   x77,W
0E30:  SUBWF  x7D,F
0E32:  BZ    0E40
0E34:  BTFSS  x7C.7
0E36:  BRA    0E42
0E38:  MOVF   FD8,W
0E3A:  XORLW  01
0E3C:  MOVWF  FD8
0E3E:  BRA    0E42
0E40:  BCF    FD8.0
0E42:  RETURN 0
0E44:  MOVLW  8E
0E46:  MOVWF  00
0E48:  MOVF   x74,W
0E4A:  SUBWF  00,F
0E4C:  MOVFF  75,02
0E50:  MOVFF  76,01
0E54:  BSF    02.7
0E56:  MOVF   00,F
0E58:  BZ    0E6C
0E5A:  BCF    FD8.0
0E5C:  MOVF   02,F
0E5E:  BNZ   0E64
0E60:  MOVF   01,F
0E62:  BZ    0E6C
0E64:  RRCF   02,F
0E66:  RRCF   01,F
0E68:  DECFSZ 00,F
0E6A:  BRA    0E5A
0E6C:  BTFSS  x75.7
0E6E:  BRA    0E7A
0E70:  COMF   01,F
0E72:  COMF   02,F
0E74:  INCF   01,F
0E76:  BTFSC  FD8.2
0E78:  INCF   02,F
0E7A:  GOTO   1394 (RETURN)
.................... 
.................... #list
.................... 
.................... #device PASS_STRINGS = IN_RAM
.................... 
.................... #define size_buffer 20                                                     // Tamaño de la cadena principal
....................                                                    // Libreria para descomposicion de tramas de datos
.................... #use delay(crystal=20000000)
*
008C:  CLRF   FEA
008E:  MOVLW  82
0090:  MOVWF  FE9
0092:  MOVF   FEF,W
0094:  BZ    00B0
0096:  MOVLW  06
0098:  MOVWF  01
009A:  CLRF   00
009C:  DECFSZ 00,F
009E:  BRA    009C
00A0:  DECFSZ 01,F
00A2:  BRA    009A
00A4:  MOVLW  7B
00A6:  MOVWF  00
00A8:  DECFSZ 00,F
00AA:  BRA    00A8
00AC:  DECFSZ FEF,F
00AE:  BRA    0096
00B0:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1)
.................... #FUSES NOWDT                    /*No Watch Dog Timer*/
.................... #FUSES HS                       /*High speed Osc (> 4mhz) */
.................... #FUSES PUT                      /*Power Up Timer*/
.................... #FUSES NOPROTECT                /*Code not protected from reading*/
.................... #FUSES NOBROWNOUT               /*No brownout reset*/
.................... #FUSES NOMCLR                     /*Master Clear pin enabled*/
.................... #FUSES NOLVP                    /*No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O*/
.................... #FUSES NOCPD
.................... #define LCD_ENABLE_PIN PIN_B0 // ASIGNAMOS EL PIN "B0" COMO SALIDA PARA E
.................... #define LCD_RS_PIN PIN_B1 // ASIGNAMOS EL PIN "B1" COMO SALIDA PARA RSW
.................... #define LCD_RW_PIN PIN_B2 // ASIGNAMOS EL PIN "B2" COMO SALIDA PARA RW
.................... #define LCD_DATA4 PIN_B3 // ASIGNAMOS EL PIN "B3" COMO SALIDA PARA D4
.................... #define LCD_DATA5 PIN_B4 // ASIGNAMOS EL PIN "B4" COMO SALIDA PARA D5
.................... #define LCD_DATA6 PIN_B5 // ASIGNAMOS EL PIN "B5" COMO SALIDA PARA D6
.................... #define LCD_DATA7 PIN_B6 // ASIGNAMOS EL PIN "B6" COMO SALIDA PARA D7
.................... #include<lcd.c>
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
*
0148:  BSF    F93.3
....................    output_float(LCD_DATA5);
014A:  BSF    F93.4
....................    output_float(LCD_DATA6);
014C:  BSF    F93.5
....................    output_float(LCD_DATA7);
014E:  BSF    F93.6
....................   #else
....................    lcdtris.data = 0xF;
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
0150:  BSF    F8A.2
0152:  BCF    F93.2
....................    delay_cycles(1);
0154:  NOP   
....................    lcd_output_enable(1);
0156:  BSF    F8A.0
0158:  BCF    F93.0
....................    delay_cycles(1);
015A:  NOP   
....................    high = lcd_read_nibble();
015C:  RCALL  00F6
015E:  MOVFF  01,8A
....................       
....................    lcd_output_enable(0);
0162:  BCF    F8A.0
0164:  BCF    F93.0
....................    delay_cycles(1);
0166:  NOP   
....................    lcd_output_enable(1);
0168:  BSF    F8A.0
016A:  BCF    F93.0
....................    delay_us(1);
016C:  BRA    016E
016E:  BRA    0170
0170:  NOP   
....................    low = lcd_read_nibble();
0172:  RCALL  00F6
0174:  MOVFF  01,89
....................       
....................    lcd_output_enable(0);
0178:  BCF    F8A.0
017A:  BCF    F93.0
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
017C:  BCF    F93.3
....................    output_drive(LCD_DATA5);
017E:  BCF    F93.4
....................    output_drive(LCD_DATA6);
0180:  BCF    F93.5
....................    output_drive(LCD_DATA7);
0182:  BCF    F93.6
....................   #else
....................    lcdtris.data = 0x0;
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
0184:  SWAPF  x8A,W
0186:  MOVWF  00
0188:  MOVLW  F0
018A:  ANDWF  00,F
018C:  MOVF   00,W
018E:  IORWF  x89,W
0190:  MOVWF  01
0192:  GOTO   01A2 (RETURN)
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
*
00F6:  CLRF   x8B
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
00F8:  BSF    F93.3
00FA:  MOVLW  00
00FC:  BTFSC  F81.3
00FE:  MOVLW  01
0100:  IORWF  x8B,F
....................    n |= input(LCD_DATA5) << 1;
0102:  BSF    F93.4
0104:  MOVLW  00
0106:  BTFSC  F81.4
0108:  MOVLW  01
010A:  MOVWF  00
010C:  BCF    FD8.0
010E:  RLCF   00,F
0110:  MOVF   00,W
0112:  IORWF  x8B,F
....................    n |= input(LCD_DATA6) << 2;
0114:  BSF    F93.5
0116:  MOVLW  00
0118:  BTFSC  F81.5
011A:  MOVLW  01
011C:  MOVWF  00
011E:  RLCF   00,F
0120:  RLCF   00,F
0122:  MOVLW  FC
0124:  ANDWF  00,F
0126:  MOVF   00,W
0128:  IORWF  x8B,F
....................    n |= input(LCD_DATA7) << 3;
012A:  BSF    F93.6
012C:  MOVLW  00
012E:  BTFSC  F81.6
0130:  MOVLW  01
0132:  MOVWF  00
0134:  RLCF   00,F
0136:  RLCF   00,F
0138:  RLCF   00,F
013A:  MOVLW  F8
013C:  ANDWF  00,F
013E:  MOVF   00,W
0140:  IORWF  x8B,F
....................    
....................    return(n);
0142:  MOVFF  8B,01
....................   #else
0146:  RETURN 0
....................    return(lcd.data);
....................   #endif
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
*
00B2:  BTFSC  x8A.0
00B4:  BRA    00BA
00B6:  BCF    F8A.3
00B8:  BRA    00BC
00BA:  BSF    F8A.3
00BC:  BCF    F93.3
....................    output_bit(LCD_DATA5, bit_test(n, 1));
00BE:  BTFSC  x8A.1
00C0:  BRA    00C6
00C2:  BCF    F8A.4
00C4:  BRA    00C8
00C6:  BSF    F8A.4
00C8:  BCF    F93.4
....................    output_bit(LCD_DATA6, bit_test(n, 2));
00CA:  BTFSC  x8A.2
00CC:  BRA    00D2
00CE:  BCF    F8A.5
00D0:  BRA    00D4
00D2:  BSF    F8A.5
00D4:  BCF    F93.5
....................    output_bit(LCD_DATA7, bit_test(n, 3));
00D6:  BTFSC  x8A.3
00D8:  BRA    00DE
00DA:  BCF    F8A.6
00DC:  BRA    00E0
00DE:  BSF    F8A.6
00E0:  BCF    F93.6
....................   #else      
....................    lcdlat.data = n;
....................   #endif
....................       
....................    delay_cycles(1);
00E2:  NOP   
....................    lcd_output_enable(1);
00E4:  BSF    F8A.0
00E6:  BCF    F93.0
....................    delay_us(2);
00E8:  MOVLW  03
00EA:  MOVWF  00
00EC:  DECFSZ 00,F
00EE:  BRA    00EC
....................    lcd_output_enable(0);
00F0:  BCF    F8A.0
00F2:  BCF    F93.0
00F4:  RETURN 0
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
*
0196:  BCF    F93.0
....................    lcd_rs_tris();
0198:  BCF    F93.1
....................    lcd_rw_tris();
019A:  BCF    F93.2
....................   #endif
.................... 
....................    lcd_output_rs(0);
019C:  BCF    F8A.1
019E:  BCF    F93.1
....................    while ( bit_test(lcd_read_byte(),7) ) ;
01A0:  BRA    0148
01A2:  MOVFF  01,89
01A6:  BTFSC  01.7
01A8:  BRA    01A0
....................    lcd_output_rs(address);
01AA:  MOVF   x86,F
01AC:  BNZ   01B2
01AE:  BCF    F8A.1
01B0:  BRA    01B4
01B2:  BSF    F8A.1
01B4:  BCF    F93.1
....................    delay_cycles(1);
01B6:  NOP   
....................    lcd_output_rw(0);
01B8:  BCF    F8A.2
01BA:  BCF    F93.2
....................    delay_cycles(1);
01BC:  NOP   
....................    lcd_output_enable(0);
01BE:  BCF    F8A.0
01C0:  BCF    F93.0
....................    lcd_send_nibble(n >> 4);
01C2:  SWAPF  x88,W
01C4:  MOVWF  x89
01C6:  MOVLW  0F
01C8:  ANDWF  x89,F
01CA:  MOVFF  89,8A
01CE:  RCALL  00B2
....................    lcd_send_nibble(n & 0xf);
01D0:  MOVF   x88,W
01D2:  ANDLW  0F
01D4:  MOVWF  x89
01D6:  MOVWF  x8A
01D8:  RCALL  00B2
01DA:  RETURN 0
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
01DC:  MOVLW  28
01DE:  MOVWF  x75
01E0:  MOVLW  0C
01E2:  MOVWF  x76
01E4:  MOVLW  01
01E6:  MOVWF  x77
01E8:  MOVLW  06
01EA:  MOVWF  x78
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
01EC:  BCF    F8A.0
01EE:  BCF    F93.0
....................    lcd_output_rs(0);
01F0:  BCF    F8A.1
01F2:  BCF    F93.1
....................    lcd_output_rw(0);
01F4:  BCF    F8A.2
01F6:  BCF    F93.2
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
01F8:  BCF    F93.3
....................    output_drive(LCD_DATA5);
01FA:  BCF    F93.4
....................    output_drive(LCD_DATA6);
01FC:  BCF    F93.5
....................    output_drive(LCD_DATA7);
01FE:  BCF    F93.6
....................   #else
....................    lcdtris.data = 0x0;
....................   #endif
....................    lcd_enable_tris();
0200:  BCF    F93.0
....................    lcd_rs_tris();
0202:  BCF    F93.1
....................    lcd_rw_tris();
0204:  BCF    F93.2
....................  #endif
....................     
....................    delay_ms(15);
0206:  MOVLW  0F
0208:  MOVWF  x82
020A:  RCALL  008C
....................    for(i=1;i<=3;++i)
020C:  MOVLW  01
020E:  MOVWF  x74
0210:  MOVF   x74,W
0212:  SUBLW  03
0214:  BNC   0226
....................    {
....................        lcd_send_nibble(3);
0216:  MOVLW  03
0218:  MOVWF  x8A
021A:  RCALL  00B2
....................        delay_ms(5);
021C:  MOVLW  05
021E:  MOVWF  x82
0220:  RCALL  008C
0222:  INCF   x74,F
0224:  BRA    0210
....................    }
....................    
....................    lcd_send_nibble(2);
0226:  MOVLW  02
0228:  MOVWF  x8A
022A:  RCALL  00B2
....................    delay_ms(5);
022C:  MOVLW  05
022E:  MOVWF  x82
0230:  RCALL  008C
....................    for(i=0;i<=3;++i)
0232:  CLRF   x74
0234:  MOVF   x74,W
0236:  SUBLW  03
0238:  BNC   0254
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
023A:  CLRF   03
023C:  MOVF   x74,W
023E:  ADDLW  75
0240:  MOVWF  FE9
0242:  MOVLW  00
0244:  ADDWFC 03,W
0246:  MOVWF  FEA
0248:  MOVFF  FEF,88
024C:  CLRF   x86
024E:  RCALL  0196
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
0250:  INCF   x74,F
0252:  BRA    0234
0254:  GOTO   0EC6 (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
*
0544:  DECFSZ x83,W
0546:  BRA    054A
0548:  BRA    0550
....................       address=LCD_LINE_TWO;
054A:  MOVLW  40
054C:  MOVWF  x84
054E:  BRA    0552
....................    else
....................       address=0;
0550:  CLRF   x84
....................      
....................    address+=x-1;
0552:  MOVLW  01
0554:  SUBWF  x82,W
0556:  ADDWF  x84,F
....................    lcd_send_byte(0,0x80|address);
0558:  MOVF   x84,W
055A:  IORLW  80
055C:  MOVWF  x85
055E:  CLRF   x86
0560:  MOVWF  x88
0562:  RCALL  0196
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
0564:  RETURN 0
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
0566:  MOVF   x81,W
0568:  XORLW  07
056A:  BZ    057A
056C:  XORLW  0B
056E:  BZ    0584
0570:  XORLW  06
0572:  BZ    0594
0574:  XORLW  02
0576:  BZ    05A0
0578:  BRA    05AA
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
057A:  MOVLW  01
057C:  MOVWF  x82
057E:  MOVWF  x83
0580:  RCALL  0544
0582:  BRA    05B4
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
0584:  CLRF   x86
0586:  MOVLW  01
0588:  MOVWF  x88
058A:  RCALL  0196
....................                      delay_ms(2);
058C:  MOVLW  02
058E:  MOVWF  x82
0590:  RCALL  008C
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
0592:  BRA    05B4
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
0594:  MOVLW  01
0596:  MOVWF  x82
0598:  MOVLW  02
059A:  MOVWF  x83
059C:  RCALL  0544
059E:  BRA    05B4
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
05A0:  CLRF   x86
05A2:  MOVLW  10
05A4:  MOVWF  x88
05A6:  RCALL  0196
05A8:  BRA    05B4
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
05AA:  MOVLW  01
05AC:  MOVWF  x86
05AE:  MOVFF  81,88
05B2:  RCALL  0196
....................      #endif
....................    }
05B4:  RETURN 0
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #define ok pin_D2
.................... #BYTE TRISC=0X87
.................... #BYTE TRISB=0XF93
.................... #BYTE PORTB=0XF81
.................... 
.................... char trama_principal[size_buffer];                                         // Almacena la cadena recibida desde el puerto serial
.................... char trama_1[10];                                                          // Almacena la trama 1
.................... char trama_2[10];                                                          // Almacena la trama 2
.................... int dato_rx[2]; 
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
03BA:  CLRF   x79
....................    sign = 0;
03BC:  CLRF   x77
....................    base = 10;
03BE:  MOVLW  0A
03C0:  MOVWF  x78
....................    result = 0;
03C2:  CLRF   x76
.................... 
....................    if (!s)
03C4:  MOVF   x74,W
03C6:  IORWF  x75,W
03C8:  BNZ   03D0
....................       return 0;
03CA:  MOVLW  00
03CC:  MOVWF  01
03CE:  BRA    0542
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
03D0:  MOVF   x79,W
03D2:  INCF   x79,F
03D4:  ADDWF  x74,W
03D6:  MOVWF  FE9
03D8:  MOVLW  00
03DA:  ADDWFC x75,W
03DC:  MOVWF  FEA
03DE:  MOVFF  FEF,7A
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
03E2:  MOVF   x7A,W
03E4:  SUBLW  2D
03E6:  BNZ   0400
....................    {
....................       sign = 1;         // Set the sign to negative
03E8:  MOVLW  01
03EA:  MOVWF  x77
....................       c = s[index++];
03EC:  MOVF   x79,W
03EE:  INCF   x79,F
03F0:  ADDWF  x74,W
03F2:  MOVWF  FE9
03F4:  MOVLW  00
03F6:  ADDWFC x75,W
03F8:  MOVWF  FEA
03FA:  MOVFF  FEF,7A
....................    }
03FE:  BRA    0418
....................    else if (c == '+')
0400:  MOVF   x7A,W
0402:  SUBLW  2B
0404:  BNZ   0418
....................    {
....................       c = s[index++];
0406:  MOVF   x79,W
0408:  INCF   x79,F
040A:  ADDWF  x74,W
040C:  MOVWF  FE9
040E:  MOVLW  00
0410:  ADDWFC x75,W
0412:  MOVWF  FEA
0414:  MOVFF  FEF,7A
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
0418:  MOVF   x7A,W
041A:  SUBLW  2F
041C:  BTFSC  FD8.0
041E:  BRA    0532
0420:  MOVF   x7A,W
0422:  SUBLW  39
0424:  BTFSS  FD8.0
0426:  BRA    0532
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
0428:  MOVF   x7A,W
042A:  SUBLW  30
042C:  BNZ   046A
042E:  MOVF   x79,W
0430:  ADDWF  x74,W
0432:  MOVWF  FE9
0434:  MOVLW  00
0436:  ADDWFC x75,W
0438:  MOVWF  FEA
043A:  MOVF   FEF,W
043C:  SUBLW  78
043E:  BZ    0452
0440:  MOVF   x79,W
0442:  ADDWF  x74,W
0444:  MOVWF  FE9
0446:  MOVLW  00
0448:  ADDWFC x75,W
044A:  MOVWF  FEA
044C:  MOVF   FEF,W
044E:  SUBLW  58
0450:  BNZ   046A
....................       {
....................          base = 16;
0452:  MOVLW  10
0454:  MOVWF  x78
....................          index++;
0456:  INCF   x79,F
....................          c = s[index++];
0458:  MOVF   x79,W
045A:  INCF   x79,F
045C:  ADDWF  x74,W
045E:  MOVWF  FE9
0460:  MOVLW  00
0462:  ADDWFC x75,W
0464:  MOVWF  FEA
0466:  MOVFF  FEF,7A
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
046A:  MOVF   x78,W
046C:  SUBLW  0A
046E:  BNZ   04A4
....................       {
....................          while (c >= '0' && c <= '9')
0470:  MOVF   x7A,W
0472:  SUBLW  2F
0474:  BC    04A2
0476:  MOVF   x7A,W
0478:  SUBLW  39
047A:  BNC   04A2
....................          {
....................             result = 10*result + (c - '0');
047C:  MOVLW  0A
047E:  MOVWF  x7B
0480:  MOVFF  76,7C
0484:  BRA    036E
0486:  MOVLW  30
0488:  SUBWF  x7A,W
048A:  ADDWF  01,W
048C:  MOVWF  x76
....................             c = s[index++];
048E:  MOVF   x79,W
0490:  INCF   x79,F
0492:  ADDWF  x74,W
0494:  MOVWF  FE9
0496:  MOVLW  00
0498:  ADDWFC x75,W
049A:  MOVWF  FEA
049C:  MOVFF  FEF,7A
04A0:  BRA    0470
....................          }
....................       }
04A2:  BRA    0532
....................       else if (base == 16)    // The number is a hexa number
04A4:  MOVF   x78,W
04A6:  SUBLW  10
04A8:  BNZ   0532
....................       {
....................          c = toupper(c);
04AA:  MOVF   x7A,W
04AC:  SUBLW  60
04AE:  BC    04BC
04B0:  MOVF   x7A,W
04B2:  SUBLW  7A
04B4:  BNC   04BC
04B6:  MOVF   x7A,W
04B8:  ANDLW  DF
04BA:  BRA    04BE
04BC:  MOVF   x7A,W
04BE:  MOVWF  x7A
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
04C0:  MOVF   x7A,W
04C2:  SUBLW  2F
04C4:  BC    04CC
04C6:  MOVF   x7A,W
04C8:  SUBLW  39
04CA:  BC    04D8
04CC:  MOVF   x7A,W
04CE:  SUBLW  40
04D0:  BC    0532
04D2:  MOVF   x7A,W
04D4:  SUBLW  46
04D6:  BNC   0532
....................          {
....................             if (c >= '0' && c <= '9')
04D8:  MOVF   x7A,W
04DA:  SUBLW  2F
04DC:  BC    04F6
04DE:  MOVF   x7A,W
04E0:  SUBLW  39
04E2:  BNC   04F6
....................                result = (result << 4) + (c - '0');
04E4:  SWAPF  x76,W
04E6:  MOVWF  x7B
04E8:  MOVLW  F0
04EA:  ANDWF  x7B,F
04EC:  MOVLW  30
04EE:  SUBWF  x7A,W
04F0:  ADDWF  x7B,W
04F2:  MOVWF  x76
04F4:  BRA    0508
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
04F6:  SWAPF  x76,W
04F8:  MOVWF  x7B
04FA:  MOVLW  F0
04FC:  ANDWF  x7B,F
04FE:  MOVLW  41
0500:  SUBWF  x7A,W
0502:  ADDLW  0A
0504:  ADDWF  x7B,W
0506:  MOVWF  x76
.................... 
....................             c = s[index++];
0508:  MOVF   x79,W
050A:  INCF   x79,F
050C:  ADDWF  x74,W
050E:  MOVWF  FE9
0510:  MOVLW  00
0512:  ADDWFC x75,W
0514:  MOVWF  FEA
0516:  MOVFF  FEF,7A
....................             c = toupper(c);
051A:  MOVF   x7A,W
051C:  SUBLW  60
051E:  BC    052C
0520:  MOVF   x7A,W
0522:  SUBLW  7A
0524:  BNC   052C
0526:  MOVF   x7A,W
0528:  ANDLW  DF
052A:  BRA    052E
052C:  MOVF   x7A,W
052E:  MOVWF  x7A
0530:  BRA    04C0
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
0532:  DECFSZ x77,W
0534:  BRA    053E
0536:  MOVF   x78,W
0538:  SUBLW  0A
053A:  BNZ   053E
....................        result = -result;
053C:  NEGF   x76
.................... 
....................    return(result);
053E:  MOVFF  76,01
0542:  RETURN 0
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <get_string.c>                                                    // Libreria para lectura de cadenas de caractares
.................... /* #include <get_string.c>
.................... *
.................... * Creada por: Ing. Abiezer Hernandez O.
.................... * Fecha de creacion: 04/08/2019
.................... * Electronica y Circuitos
.................... *
.................... */
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... void read_string(char* s, unsigned int max)
.................... {
....................    unsigned int len;
....................    char c;
....................    --max;
*
0258:  DECF   x76,F
....................    len=0;
025A:  CLRF   x77
....................    do {
....................      c = getc();
025C:  BTFSS  F9E.5
025E:  BRA    025C
0260:  MOVFF  FAE,78
....................      if(c==8) {
0264:  MOVF   x78,W
0266:  SUBLW  08
0268:  BNZ   0272
....................         if(len>0){
026A:  MOVF   x77,F
026C:  BZ    0270
....................           len--;
026E:  DECF   x77,F
....................         }
....................      }else if ((c>=' ')&&(c<='~'))
0270:  BRA    0296
0272:  MOVF   x78,W
0274:  SUBLW  1F
0276:  BC    0296
0278:  MOVF   x78,W
027A:  SUBLW  7E
027C:  BNC   0296
....................        if(len<max){
027E:  MOVF   x76,W
0280:  SUBWF  x77,W
0282:  BC    0296
....................          s[len++]=c;
0284:  MOVF   x77,W
0286:  INCF   x77,F
0288:  ADDWF  x74,W
028A:  MOVWF  FE9
028C:  MOVLW  00
028E:  ADDWFC x75,W
0290:  MOVWF  FEA
0292:  MOVFF  78,FEF
....................        }
....................    } while(c!=13);
0296:  MOVF   x78,W
0298:  SUBLW  0D
029A:  BNZ   025C
....................    s[len]=0;
029C:  MOVF   x77,W
029E:  ADDWF  x74,W
02A0:  MOVWF  FE9
02A2:  MOVLW  00
02A4:  ADDWFC x75,W
02A6:  MOVWF  FEA
02A8:  CLRF   FEF
02AA:  GOTO   0944 (RETURN)
.................... }
.................... 
.................... #ifdef STREAM_PIC
.................... void read_string_stream(char* s2, unsigned int max2)
.................... {
....................    unsigned int len2;
....................    char c2;
....................    --max2;
....................    len2=0;
....................    do {
....................      c2 = getch(SPIC);
....................      if(c2==8) {
....................         if(len2>0){
....................           len2--;
....................         }
....................      }else if ((c2>=' ')&&(c2<='~'))
....................        if(len2<max2){
....................          s2[len2++]=c2;
....................        }
....................    } while(c2!=13);
....................    s2[len2]=0;
.................... }
.................... #endif
.................... 
.................... void read_substring(char* cp, char* vc, int inc , int fn)
.................... {
....................    int pt = 0;
....................    for(int lt=inc; lt<=fn; lt++)
....................    {
....................       vc[pt] = cp[lt];
....................       pt++;
....................    }
....................    pt = 0;
.................... }
.................... 
.................... void read_string_until(char stopchar, char* buffer_rx, int st_size)
.................... {
....................    unsigned int con_t = 0;
....................    while(*(buffer_rx-1) != stopchar)
....................    {
....................       con_t++;
....................       *buffer_rx++ = getc();
....................       if(con_t >= st_size) break;
....................    }
....................    *--buffer_rx=0;
.................... }
.................... 
.................... char *find_string(char *s1, char *s2)
.................... {
....................     char *s, *t;
....................     while(*s1)
....................     {
....................         for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
....................         if (*t == '\0')
....................             return s1;
....................         ++s1;
....................     }
....................     return 0;
.................... }
.................... 
.................... #include <get_plot.c>   
.................... /* #include <get_plot.c>
.................... *
.................... * Creada por: Ing. Abiezer Hernandez O.
.................... * Fecha de creacion: 20/07/2020
.................... * Electronica y Circuitos
.................... *
.................... */
.................... 
.................... void read_substring_plot(char* cp, char* vc, int inc , int fn)
02AE:  CLRF   x88
.................... {
....................    int pt = 0;
....................    for(int lt=inc; lt<=fn; lt++)
02B0:  MOVFF  85,89
02B4:  MOVF   x89,W
02B6:  SUBWF  x86,W
02B8:  BNC   02E8
....................    {
....................       vc[pt] = cp[lt];
02BA:  MOVF   x88,W
02BC:  ADDWF  x83,W
02BE:  MOVWF  01
02C0:  MOVLW  00
02C2:  ADDWFC x84,W
02C4:  MOVWF  03
02C6:  MOVF   x89,W
02C8:  ADDWF  x81,W
02CA:  MOVWF  FE9
02CC:  MOVLW  00
02CE:  ADDWFC x82,W
02D0:  MOVWF  FEA
02D2:  MOVFF  FEF,8C
02D6:  MOVFF  03,FEA
02DA:  MOVFF  01,FE9
02DE:  MOVFF  8C,FEF
....................       pt++;
02E2:  INCF   x88,F
02E4:  INCF   x89,F
02E6:  BRA    02B4
....................    }
....................    vc[pt] = '\0';
02E8:  MOVF   x88,W
02EA:  ADDWF  x83,W
02EC:  MOVWF  FE9
02EE:  MOVLW  00
02F0:  ADDWFC x84,W
02F2:  MOVWF  FEA
02F4:  CLRF   FEF
....................    pt = 0;
02F6:  CLRF   x88
02F8:  GOTO   036C (RETURN)
.................... }
.................... 
.................... void read_plot(char b_ini, char b_fin, char* tr_or, char* n_str, int s_buf)
02FC:  CLRF   x7B
02FE:  CLRF   x7C
0300:  CLRF   x7D
0302:  CLRF   x7E
.................... {
....................    int i = 0;
....................    int j = 0;
....................    int conta_ini = 0;
....................    int conta_fin = 0;
....................    
....................    for(i=0; i<s_buf; i++)
0304:  CLRF   x7B
0306:  MOVF   x7A,W
0308:  SUBWF  x7B,W
030A:  BC    0326
....................    {
....................       if(tr_or[i] == b_ini){
030C:  MOVF   x7B,W
030E:  ADDWF  x76,W
0310:  MOVWF  FE9
0312:  MOVLW  00
0314:  ADDWFC x77,W
0316:  MOVWF  FEA
0318:  MOVF   x74,W
031A:  SUBWF  FEF,W
031C:  BNZ   0322
....................          conta_ini = i;
031E:  MOVFF  7B,7D
....................       }
0322:  INCF   x7B,F
0324:  BRA    0306
....................    }
....................    for(j=0; j<s_buf; j++)
0326:  CLRF   x7C
0328:  MOVF   x7A,W
032A:  SUBWF  x7C,W
032C:  BC    0348
....................    {
....................       if(tr_or[j] == b_fin){
032E:  MOVF   x7C,W
0330:  ADDWF  x76,W
0332:  MOVWF  FE9
0334:  MOVLW  00
0336:  ADDWFC x77,W
0338:  MOVWF  FEA
033A:  MOVF   x75,W
033C:  SUBWF  FEF,W
033E:  BNZ   0344
....................          conta_fin = j;
0340:  MOVFF  7C,7E
....................       }
0344:  INCF   x7C,F
0346:  BRA    0328
....................    }
....................    read_substring_plot(tr_or, n_str, conta_ini+1, conta_fin-1);
0348:  MOVLW  01
034A:  ADDWF  x7D,W
034C:  MOVWF  x7F
034E:  MOVLW  01
0350:  SUBWF  x7E,W
0352:  MOVWF  x80
0354:  MOVFF  77,82
0358:  MOVFF  76,81
035C:  MOVFF  79,84
0360:  MOVFF  78,83
0364:  MOVFF  7F,85
0368:  MOVWF  x86
036A:  BRA    02AE
036C:  RETURN 0
.................... }
.................... 
.................... 
....................          
.................... float setpoint = dato_rx[0];//valor de temperatura deceada
.................... void SET_POINT(){
.................... while (true)
....................    {
....................       if(kbhit() > 0)                                                      // Verificacion se ha recibido datos por el puerto serial
*
092E:  MOVLW  00
0930:  BTFSC  F9E.5
0932:  MOVLW  01
0934:  XORLW  00
0936:  BZ    0990
....................       {
....................          read_string(trama_principal, size_buffer);                        // Lee la cadena de caracteres principal
0938:  CLRF   x75
093A:  MOVLW  04
093C:  MOVWF  x74
093E:  MOVLW  14
0940:  MOVWF  x76
0942:  BRA    0258
....................          read_plot('a','b', trama_principal, trama_1, size_buffer);        // Descompone la primer trama de datos
0944:  MOVLW  61
0946:  MOVWF  x74
0948:  MOVLW  62
094A:  MOVWF  x75
094C:  CLRF   x77
094E:  MOVLW  04
0950:  MOVWF  x76
0952:  CLRF   x79
0954:  MOVLW  18
0956:  MOVWF  x78
0958:  MOVLW  14
095A:  MOVWF  x7A
095C:  RCALL  02FC
....................          read_plot('b','c', trama_principal, trama_2, size_buffer);        // Descompone la segunda trama de datos
095E:  MOVLW  62
0960:  MOVWF  x74
0962:  MOVLW  63
0964:  MOVWF  x75
0966:  CLRF   x77
0968:  MOVLW  04
096A:  MOVWF  x76
096C:  CLRF   x79
096E:  MOVLW  22
0970:  MOVWF  x78
0972:  MOVLW  14
0974:  MOVWF  x7A
0976:  RCALL  02FC
....................          
....................          dato_rx[0] = atoi(trama_1);                                       // Convierte las cadenas de caracteres a datos enteros
0978:  CLRF   x75
097A:  MOVLW  18
097C:  MOVWF  x74
097E:  RCALL  03BA
0980:  MOVFF  01,2C
....................          dato_rx[1] = atoi(trama_2);
0984:  CLRF   x75
0986:  MOVLW  22
0988:  MOVWF  x74
098A:  RCALL  03BA
098C:  MOVFF  01,2D
....................       }
0990:  BRA    092E
....................       }
.................... while (true){
.................... 
....................       lcd_gotoxy (1,1);printf(LCD_PUTC, "SET POINT %f       ",setpoint); //muestra la temperatura deceada
0992:  MOVLW  01
0994:  MOVWF  x82
0996:  MOVWF  x83
0998:  RCALL  0544
099A:  MOVLW  04
099C:  MOVWF  FF6
099E:  MOVLW  00
09A0:  MOVWF  FF7
09A2:  MOVLW  0A
09A4:  MOVWF  x74
09A6:  RCALL  05B6
09A8:  MOVLW  89
09AA:  MOVWF  FE9
09AC:  MOVFF  37,77
09B0:  MOVFF  36,76
09B4:  MOVFF  35,75
09B8:  MOVFF  34,74
09BC:  MOVLW  02
09BE:  MOVWF  x78
09C0:  RCALL  0794
09C2:  MOVLW  10
09C4:  MOVWF  FF6
09C6:  MOVLW  00
09C8:  MOVWF  FF7
09CA:  MOVLW  07
09CC:  MOVWF  x74
09CE:  RCALL  05B6
....................       lcd_gotoxy (1,2);printf(LCD_PUTC, "                   ");
09D0:  MOVLW  01
09D2:  MOVWF  x82
09D4:  MOVLW  02
09D6:  MOVWF  x83
09D8:  RCALL  0544
09DA:  MOVLW  18
09DC:  MOVWF  FF6
09DE:  MOVLW  00
09E0:  MOVWF  FF7
09E2:  BRA    090C
.................... 
....................       while (input(ok))//establece la temperatura para iniciar el sistema
09E4:  BSF    F95.2
09E6:  BTFSS  F83.2
09E8:  BRA    09FC
....................       {
....................          delay_ms(200);
09EA:  MOVLW  C8
09EC:  MOVWF  x82
09EE:  CALL   008C
....................          if(!input(ok))
09F2:  BSF    F95.2
09F4:  BTFSC  F83.2
09F6:  BRA    09FA
....................          {
....................             return;
09F8:  BRA    0A06
....................          }
09FA:  BRA    09E4
....................       }
.................... 
....................       delay_ms(130);
09FC:  MOVLW  82
09FE:  MOVWF  x82
0A00:  CALL   008C
0A04:  BRA    0992
.................... 
....................    }
0A06:  RETURN 0
.................... }
.................... 
.................... void main(){
*
0E7E:  CLRF   FF8
0E80:  BCF    FD0.7
0E82:  BSF    FB8.3
0E84:  MOVLW  08
0E86:  MOVWF  FAF
0E88:  MOVLW  02
0E8A:  MOVWF  FB0
0E8C:  MOVLW  A6
0E8E:  MOVWF  FAC
0E90:  MOVLW  90
0E92:  MOVWF  FAB
0E94:  CLRF   x75
0E96:  MOVFF  2C,74
0E9A:  CALL   0056
0E9E:  MOVFF  03,37
0EA2:  MOVFF  02,36
0EA6:  MOVFF  01,35
0EAA:  MOVFF  00,34
0EAE:  CLRF   39
0EB0:  CLRF   38
0EB2:  MOVF   FC1,W
0EB4:  ANDLW  C0
0EB6:  IORLW  0F
0EB8:  MOVWF  FC1
0EBA:  MOVLW  07
0EBC:  MOVWF  FB4
0EBE:  CLRF   2E
0EC0:  CLRF   2F
....................    lcd_init ();
0EC2:  GOTO   01DC
....................    SET_POINT();
0EC6:  RCALL  092E
....................    float valor=0.0;
....................    float  kp,ki,kd;
....................    float k1=0.0,k2=0.0,k3=0.0;
....................    float e0=0.0,e1=0.0,e2=0.0, u0=0.0,u1=0.0;
....................    float retroalimentacion=0.0;
....................    int16 max, min, duty;
0EC8:  CLRF   3D
0ECA:  CLRF   3C
0ECC:  CLRF   3B
0ECE:  CLRF   3A
0ED0:  CLRF   4D
0ED2:  CLRF   4C
0ED4:  CLRF   4B
0ED6:  CLRF   4A
0ED8:  CLRF   51
0EDA:  CLRF   50
0EDC:  CLRF   4F
0EDE:  CLRF   4E
0EE0:  CLRF   55
0EE2:  CLRF   54
0EE4:  CLRF   53
0EE6:  CLRF   52
0EE8:  CLRF   59
0EEA:  CLRF   58
0EEC:  CLRF   57
0EEE:  CLRF   56
0EF0:  CLRF   5D
0EF2:  CLRF   5C
0EF4:  CLRF   5B
0EF6:  CLRF   5A
0EF8:  CLRF   x61
0EFA:  CLRF   x60
0EFC:  CLRF   5F
0EFE:  CLRF   5E
0F00:  CLRF   x65
0F02:  CLRF   x64
0F04:  CLRF   x63
0F06:  CLRF   x62
0F08:  CLRF   x69
0F0A:  CLRF   x68
0F0C:  CLRF   x67
0F0E:  CLRF   x66
0F10:  CLRF   x6D
0F12:  CLRF   x6C
0F14:  CLRF   x6B
0F16:  CLRF   x6A
.................... 
....................    min=0;//valor minimo para el PWM
0F18:  CLRF   x71
0F1A:  CLRF   x70
....................    max=997;//valor maximo para el PWM
0F1C:  MOVLW  03
0F1E:  MOVWF  x6F
0F20:  MOVLW  E5
0F22:  MOVWF  x6E
.................... 
.................... //!   //constantes del PID
....................    kp=0.1248;
0F24:  MOVLW  24
0F26:  MOVWF  41
0F28:  MOVLW  97
0F2A:  MOVWF  40
0F2C:  MOVLW  7F
0F2E:  MOVWF  3F
0F30:  MOVLW  7B
0F32:  MOVWF  3E
....................    ki=0.00624;//muestreo de 100ms
0F34:  MOVLW  EA
0F36:  MOVWF  45
0F38:  MOVLW  78
0F3A:  MOVWF  44
0F3C:  MOVLW  4C
0F3E:  MOVWF  43
0F40:  MOVLW  77
0F42:  MOVWF  42
....................    kd=0.624;
0F44:  MOVWF  49
0F46:  MOVLW  BE
0F48:  MOVWF  48
0F4A:  MOVLW  1F
0F4C:  MOVWF  47
0F4E:  MOVLW  7E
0F50:  MOVWF  46
.................... 
....................    TRISC=0;
0F52:  CLRF   x87
....................    setup_adc_ports(AN0);//selecciona el puerto AN0 como analogico
0F54:  MOVF   FC1,W
0F56:  ANDLW  C0
0F58:  IORLW  0E
0F5A:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0);
0F5C:  MOVF   FC0,W
0F5E:  ANDLW  C0
0F60:  IORLW  07
0F62:  MOVWF  FC0
0F64:  BCF    FC0.7
0F66:  BSF    FC2.0
....................    setup_timer_2(T2_DIV_BY_4,249,1); //interrupt 0-997 //ancho de PWM en 1ms
0F68:  MOVLW  00
0F6A:  IORLW  05
0F6C:  MOVWF  FCA
0F6E:  MOVLW  F9
0F70:  MOVWF  FCB
....................    setup_ccp1(CCP_PWM|CCP_SHUTDOWN_AC_L|CCP_SHUTDOWN_BD_L);
0F72:  BCF    F94.2
0F74:  BCF    F8B.2
0F76:  MOVLW  0C
0F78:  MOVWF  FBD
0F7A:  CLRF   FB7
0F7C:  CLRF   FB6
....................    set_adc_channel (0); //numero 0 = pin A0 //selecciona la entrada analogica
0F7E:  MOVLW  00
0F80:  MOVWF  01
0F82:  MOVF   FC2,W
0F84:  ANDLW  C3
0F86:  IORWF  01,W
0F88:  MOVWF  FC2
.................... 
....................    while(TRUE)
....................    {
.................... 
....................       while (input(ok))
0F8A:  BSF    F95.2
0F8C:  BTFSS  F83.2
0F8E:  BRA    0FA4
....................       {
....................          delay_ms(200);
0F90:  MOVLW  C8
0F92:  MOVWF  x82
0F94:  CALL   008C
....................          if(!input(ok))
0F98:  BSF    F95.2
0F9A:  BTFSC  F83.2
0F9C:  BRA    0FA2
....................          {
....................             set_pwm1_duty(0);
0F9E:  CLRF   FBE
....................             SET_POINT();
0FA0:  RCALL  092E
....................          }
0FA2:  BRA    0F8A
....................       }
.................... 
....................       valor=read_adc();   //lee el valor analogico de AN0
0FA4:  BSF    FC2.1
0FA6:  BTFSC  FC2.1
0FA8:  BRA    0FA6
0FAA:  MOVF   FC4,W
0FAC:  CLRF   x75
0FAE:  MOVWF  x74
0FB0:  CALL   0056
0FB4:  MOVFF  03,3D
0FB8:  MOVFF  02,3C
0FBC:  MOVFF  01,3B
0FC0:  MOVFF  00,3A
....................       retroalimentacion=(valor*500)/1023;// realizamos la convercion para obtener la temperatura real
0FC4:  MOVFF  3D,84
0FC8:  MOVFF  3C,83
0FCC:  MOVFF  3B,82
0FD0:  MOVFF  3A,81
0FD4:  CLRF   x8B
0FD6:  CLRF   x8A
0FD8:  MOVLW  7A
0FDA:  MOVWF  x89
0FDC:  MOVLW  87
0FDE:  MOVWF  x88
0FE0:  CALL   05D4
0FE4:  MOVFF  03,77
0FE8:  MOVFF  02,76
0FEC:  MOVFF  01,75
0FF0:  MOVFF  00,74
0FF4:  MOVFF  03,7B
0FF8:  MOVFF  02,7A
0FFC:  MOVFF  01,79
1000:  MOVFF  00,78
1004:  CLRF   x7F
1006:  MOVLW  C0
1008:  MOVWF  x7E
100A:  MOVLW  7F
100C:  MOVWF  x7D
100E:  MOVLW  88
1010:  MOVWF  x7C
1012:  BRA    0A08
1014:  MOVFF  03,6D
1018:  MOVFF  02,6C
101C:  MOVFF  01,6B
1020:  MOVFF  00,6A
.................... 
....................       lcd_gotoxy (1,1);printf(LCD_PUTC, "SET POINT %f       ",setpoint);//muestra la temperatura deceada
1024:  MOVLW  01
1026:  MOVWF  x82
1028:  MOVWF  x83
102A:  CALL   0544
102E:  MOVLW  2C
1030:  MOVWF  FF6
1032:  MOVLW  00
1034:  MOVWF  FF7
1036:  MOVLW  0A
1038:  MOVWF  x74
103A:  CALL   05B6
103E:  MOVLW  89
1040:  MOVWF  FE9
1042:  MOVFF  37,77
1046:  MOVFF  36,76
104A:  MOVFF  35,75
104E:  MOVFF  34,74
1052:  MOVLW  02
1054:  MOVWF  x78
1056:  CALL   0794
105A:  MOVLW  38
105C:  MOVWF  FF6
105E:  MOVLW  00
1060:  MOVWF  FF7
1062:  MOVLW  07
1064:  MOVWF  x74
1066:  CALL   05B6
....................       lcd_gotoxy (1,2);printf(LCD_PUTC, "TEMPERATURA %f       ", retroalimentacion);//muestra la temperatura actual
106A:  MOVLW  01
106C:  MOVWF  x82
106E:  MOVLW  02
1070:  MOVWF  x83
1072:  CALL   0544
1076:  MOVLW  40
1078:  MOVWF  FF6
107A:  MOVLW  00
107C:  MOVWF  FF7
107E:  MOVLW  0C
1080:  MOVWF  x74
1082:  CALL   05B6
1086:  MOVLW  89
1088:  MOVWF  FE9
108A:  MOVFF  6D,77
108E:  MOVFF  6C,76
1092:  MOVFF  6B,75
1096:  MOVFF  6A,74
109A:  MOVLW  02
109C:  MOVWF  x78
109E:  CALL   0794
10A2:  MOVLW  4E
10A4:  MOVWF  FF6
10A6:  MOVLW  00
10A8:  MOVWF  FF7
10AA:  MOVLW  07
10AC:  MOVWF  x74
10AE:  CALL   05B6
.................... 
....................       e0=setpoint - retroalimentacion;//se obtiene el error del valor deceado - la salida del sistema
10B2:  BSF    FD8.1
10B4:  MOVFF  37,7B
10B8:  MOVFF  36,7A
10BC:  MOVFF  35,79
10C0:  MOVFF  34,78
10C4:  MOVFF  6D,7F
10C8:  MOVFF  6C,7E
10CC:  MOVFF  6B,7D
10D0:  MOVFF  6A,7C
10D4:  RCALL  0B64
10D6:  MOVFF  03,59
10DA:  MOVFF  02,58
10DE:  MOVFF  01,57
10E2:  MOVFF  00,56
.................... 
....................       k1=e0*(kp+ki+kd);
10E6:  BCF    FD8.1
10E8:  MOVFF  41,7B
10EC:  MOVFF  40,7A
10F0:  MOVFF  3F,79
10F4:  MOVFF  3E,78
10F8:  MOVFF  45,7F
10FC:  MOVFF  44,7E
1100:  MOVFF  43,7D
1104:  MOVFF  42,7C
1108:  RCALL  0B64
110A:  MOVFF  03,77
110E:  MOVFF  02,76
1112:  MOVFF  01,75
1116:  MOVFF  00,74
111A:  BCF    FD8.1
111C:  MOVFF  03,7B
1120:  MOVFF  02,7A
1124:  MOVFF  01,79
1128:  MOVFF  00,78
112C:  MOVFF  49,7F
1130:  MOVFF  48,7E
1134:  MOVFF  47,7D
1138:  MOVFF  46,7C
113C:  RCALL  0B64
113E:  MOVFF  59,84
1142:  MOVFF  58,83
1146:  MOVFF  57,82
114A:  MOVFF  56,81
114E:  MOVFF  03,8B
1152:  MOVFF  02,8A
1156:  MOVFF  01,89
115A:  MOVFF  00,88
115E:  CALL   05D4
1162:  MOVFF  03,4D
1166:  MOVFF  02,4C
116A:  MOVFF  01,4B
116E:  MOVFF  00,4A
....................       k2=e1*((-2*kd)-kp);
1172:  CLRF   x84
1174:  CLRF   x83
1176:  MOVLW  80
1178:  MOVWF  x82
117A:  MOVWF  x81
117C:  MOVFF  49,8B
1180:  MOVFF  48,8A
1184:  MOVFF  47,89
1188:  MOVFF  46,88
118C:  CALL   05D4
1190:  MOVFF  03,77
1194:  MOVFF  02,76
1198:  MOVFF  01,75
119C:  MOVFF  00,74
11A0:  BSF    FD8.1
11A2:  MOVFF  03,7B
11A6:  MOVFF  02,7A
11AA:  MOVFF  01,79
11AE:  MOVFF  00,78
11B2:  MOVFF  41,7F
11B6:  MOVFF  40,7E
11BA:  MOVFF  3F,7D
11BE:  MOVFF  3E,7C
11C2:  RCALL  0B64
11C4:  MOVFF  5D,84
11C8:  MOVFF  5C,83
11CC:  MOVFF  5B,82
11D0:  MOVFF  5A,81
11D4:  MOVFF  03,8B
11D8:  MOVFF  02,8A
11DC:  MOVFF  01,89
11E0:  MOVFF  00,88
11E4:  CALL   05D4
11E8:  MOVFF  03,51
11EC:  MOVFF  02,50
11F0:  MOVFF  01,4F
11F4:  MOVFF  00,4E
....................       k3=e2*kd;
11F8:  MOVFF  61,84
11FC:  MOVFF  60,83
1200:  MOVFF  5F,82
1204:  MOVFF  5E,81
1208:  MOVFF  49,8B
120C:  MOVFF  48,8A
1210:  MOVFF  47,89
1214:  MOVFF  46,88
1218:  CALL   05D4
121C:  MOVFF  03,55
1220:  MOVFF  02,54
1224:  MOVFF  01,53
1228:  MOVFF  00,52
....................       u0=k1+k2+k3+u1;
122C:  BCF    FD8.1
122E:  MOVFF  4D,7B
1232:  MOVFF  4C,7A
1236:  MOVFF  4B,79
123A:  MOVFF  4A,78
123E:  MOVFF  51,7F
1242:  MOVFF  50,7E
1246:  MOVFF  4F,7D
124A:  MOVFF  4E,7C
124E:  RCALL  0B64
1250:  MOVFF  03,77
1254:  MOVFF  02,76
1258:  MOVFF  01,75
125C:  MOVFF  00,74
1260:  BCF    FD8.1
1262:  MOVFF  03,7B
1266:  MOVFF  02,7A
126A:  MOVFF  01,79
126E:  MOVFF  00,78
1272:  MOVFF  55,7F
1276:  MOVFF  54,7E
127A:  MOVFF  53,7D
127E:  MOVFF  52,7C
1282:  RCALL  0B64
1284:  MOVFF  03,77
1288:  MOVFF  02,76
128C:  MOVFF  01,75
1290:  MOVFF  00,74
1294:  BCF    FD8.1
1296:  MOVFF  03,7B
129A:  MOVFF  02,7A
129E:  MOVFF  01,79
12A2:  MOVFF  00,78
12A6:  MOVFF  69,7F
12AA:  MOVFF  68,7E
12AE:  MOVFF  67,7D
12B2:  MOVFF  66,7C
12B6:  RCALL  0B64
12B8:  MOVFF  03,65
12BC:  MOVFF  02,64
12C0:  MOVFF  01,63
12C4:  MOVFF  00,62
.................... 
....................       if (u0>=max)//asegurando que el valor de la salida no exeda el valor maximo permitido para el PWM
12C8:  MOVFF  6F,75
12CC:  MOVFF  6E,74
12D0:  CALL   0056
12D4:  MOVFF  03,77
12D8:  MOVFF  02,76
12DC:  MOVFF  01,75
12E0:  MOVFF  00,74
12E4:  MOVFF  65,7B
12E8:  MOVFF  64,7A
12EC:  MOVFF  63,79
12F0:  MOVFF  62,78
12F4:  RCALL  0DCE
12F6:  BC    12FA
12F8:  BNZ   1316
....................       {
....................          u0=max;
12FA:  MOVFF  6F,75
12FE:  MOVFF  6E,74
1302:  CALL   0056
1306:  MOVFF  03,65
130A:  MOVFF  02,64
130E:  MOVFF  01,63
1312:  MOVFF  00,62
....................       }
....................       if (u0<=min)//asegurando que el valor de la salida no exeda el valor minimo permitido para el PWM
1316:  MOVFF  71,75
131A:  MOVFF  70,74
131E:  CALL   0056
1322:  MOVFF  65,77
1326:  MOVFF  64,76
132A:  MOVFF  63,75
132E:  MOVFF  62,74
1332:  MOVFF  03,7B
1336:  MOVFF  02,7A
133A:  MOVFF  01,79
133E:  MOVFF  00,78
1342:  RCALL  0DCE
1344:  BC    1348
1346:  BNZ   1364
....................       {
....................          u0=min;
1348:  MOVFF  71,75
134C:  MOVFF  70,74
1350:  CALL   0056
1354:  MOVFF  03,65
1358:  MOVFF  02,64
135C:  MOVFF  01,63
1360:  MOVFF  00,62
....................       }
.................... 
....................       duty=u0+0;//la salida u0 se convierte de float a int16
1364:  BCF    FD8.1
1366:  MOVFF  65,7B
136A:  MOVFF  64,7A
136E:  MOVFF  63,79
1372:  MOVFF  62,78
1376:  CLRF   x7F
1378:  CLRF   x7E
137A:  CLRF   x7D
137C:  CLRF   x7C
137E:  CALL   0B64
1382:  MOVFF  03,77
1386:  MOVFF  02,76
138A:  MOVFF  01,75
138E:  MOVFF  00,74
1392:  BRA    0E44
1394:  MOVFF  02,73
1398:  MOVFF  01,72
.................... 
....................       set_pwm1_duty(duty);//establece el ancho de pulso
139C:  MOVFF  73,02
13A0:  MOVFF  72,01
13A4:  RRCF   02,F
13A6:  RRCF   01,F
13A8:  RRCF   02,F
13AA:  RRCF   01,F
13AC:  RRCF   02,F
13AE:  MOVFF  01,FBE
13B2:  RRCF   02,F
13B4:  RRCF   02,W
13B6:  ANDLW  30
13B8:  MOVWF  00
13BA:  MOVF   FBD,W
13BC:  ANDLW  CF
13BE:  IORWF  00,W
13C0:  MOVWF  FBD
.................... 
....................       u1=u0;//el valor actual pasa a ser el valor anterior
13C2:  MOVFF  65,69
13C6:  MOVFF  64,68
13CA:  MOVFF  63,67
13CE:  MOVFF  62,66
....................       e2=e1;
13D2:  MOVFF  5D,61
13D6:  MOVFF  5C,60
13DA:  MOVFF  5B,5F
13DE:  MOVFF  5A,5E
....................       e1=e0;
13E2:  MOVFF  59,5D
13E6:  MOVFF  58,5C
13EA:  MOVFF  57,5B
13EE:  MOVFF  56,5A
.................... 
....................       delay_ms(100);//se establece el tiempo de muestreo
13F2:  MOVLW  64
13F4:  MOVWF  x82
13F6:  CALL   008C
13FA:  BRA    0F8A
....................    
....................    }
.................... }
13FC:  SLEEP 

Configuration Fuses:
   Word  1: CC04   PLL5 CPUDIV1 NOUSBDIV HS FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
