CCS PCH C Compiler, Version 5.104, 22719               21-jun.-21 19:02

               Filename:   G:\OneDrive - Soluciones Marva\proyectos de pics\Canal\USB_CCS\ex_usb_serial.lst

               ROM used:   6270 bytes (19%)
                           Largest free fragment is 22398
               RAM used:   465 (23%) at main() level
                           509 (25%) worst case
               Stack used: 5 locations (0 in main + 5 for interrupts)
               Stack size: 31

*
1000:  GOTO   2716
*
1008:  MOVWF  04
100A:  MOVFF  FD8,05
100E:  MOVFF  FE0,06
1012:  MOVLB  0
1014:  MOVFF  FE9,0C
1018:  MOVFF  FEA,07
101C:  MOVFF  FE1,08
1020:  MOVFF  FE2,09
1024:  MOVFF  FD9,0A
1028:  MOVFF  FDA,0B
102C:  MOVFF  FF3,12
1030:  MOVFF  FF4,13
1034:  MOVFF  FFA,14
1038:  MOVFF  FF5,15
103C:  MOVFF  FF6,16
1040:  MOVFF  FF7,17
1044:  MOVFF  00,0E
1048:  MOVFF  01,0F
104C:  MOVFF  02,10
1050:  MOVFF  03,11
1054:  BTFSS  FA0.5
1056:  GOTO   1060
105A:  BTFSC  FA1.5
105C:  GOTO   1F5A
1060:  MOVFF  0E,00
1064:  MOVFF  0F,01
1068:  MOVFF  10,02
106C:  MOVFF  11,03
1070:  MOVFF  0C,FE9
1074:  MOVFF  07,FEA
1078:  BSF    07.7
107A:  MOVFF  08,FE1
107E:  MOVFF  09,FE2
1082:  MOVFF  0A,FD9
1086:  MOVFF  0B,FDA
108A:  MOVFF  12,FF3
108E:  MOVFF  13,FF4
1092:  MOVFF  14,FFA
1096:  MOVFF  15,FF5
109A:  MOVFF  16,FF6
109E:  MOVFF  17,FF7
10A2:  MOVF   04,W
10A4:  MOVFF  06,FE0
10A8:  MOVFF  05,FD8
10AC:  RETFIE 0
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////                        EX_USB_SERIAL.c                          ////
.................... ////                                                                 ////
.................... //// A demonstration of the USB CDC API that is provided by CCS.     ////
.................... //// The USB CDC API that CCS provides will create a virtual UART    ////
.................... //// port.  USB CDC drivers are included with most versions of       ////
.................... //// Microsoft Windows, and when properly loaded will create a COMx  ////
.................... //// port from which you can write and read to your PIC device       ////
.................... //// like any serial device that has a COMx port.                    ////
.................... ////                                                                 ////
.................... //// This example creates a USB<->UART converter.  Open              ////
.................... //// Hyperterminal to COM1 (or whatever COM port is your usual RS232 ////
.................... //// serial COM port).  Plug the PIC to USB.  Open Hypertimernal to  ////
.................... //// the new COM port that is the USB<->UART COM port (for this      ////
.................... //// example say it is COM2).  Typing a character in COM1 will cause ////
.................... //// it to be sent out COM2, and vice-versa.                         ////
.................... ////                                                                 ////
.................... //// See usb_cdc.h for API documentation.                            ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// VERSION HISTORY                                                 ////
.................... ////                                                                 ////
.................... //// Mar 11th, 2011:                                                 ////
.................... ////  Shortened one printf() so it will fit on PIC16.                ////
.................... ////                                                                 ////
.................... //// Oct 27th, 2011:                                                 ////
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    ////
.................... ////     documentation.  In order for this to work,                  ////
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          ////
.................... ////     DSR/DCD is sent to host/PC and it's value is the current    ////
.................... ////     state of the button.  This is the same routine to send ring ////
.................... ////     or break signals to the host/PC.                            ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  ////
.................... ////  Added initial 18F47J53 family support.                         ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   ////
.................... ////                                                                 ////
.................... //// April 28th, 2010:                                               ////
.................... ////  Added ex_usb_common.h.                                         ////
.................... ////  Initial support for CCS PIC24USB board.                        ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// July 1st, 2005: Initial Release.                                ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #include "ex_usb_common.h"
.................... ///dsjhakdlbsakjdhsak
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////                        ex_usb_common.h                          ////
.................... ////                                                                 ////
.................... //// Common hardware definitions and configuration for all of CCS's  ////
.................... //// USB example programs (ex_usb_*.c)                               ////
.................... ////                                                                 ////
.................... //// One of the following configuration macros must be #defined:     ////
.................... ////  USB_HW_CCS_PIC18F4550   CCS PIC18F4550 USB Development kit     ////
.................... ////  USB_HW_CCS_PIC18F45K50  CCS PIC18F45K50 USB Development kit    ////
.................... ////  USB_HW_CCS_PIC24F       CCS 24FJ256GB206 USB Development kit.  ////
.................... ////  USB_HW_CCS_E3           CCS E3 Mini development kit.           ////
.................... ////  USB_HW_CCS_16F1459      CCS Rapid USB Development kit.         ////
.................... ////                          PIC16F1459 using internal oscillator.  ////
.................... ////  USB_HW_MCHP_16F1459     Microchip low-pin count USB            ////
.................... ////                          development kit with a PIC16F1459.     ////
.................... ////                          NOTE: the ICD pins on the low pin      ////
.................... ////                          count development kit are not          ////
.................... ////                          compatible with this chip!             ////
.................... ////  USB_HW_CCS_USBN9604     CCS National USBN9604 USB development  ////
.................... ////                          kit (external USB peripheral).         ////
.................... ////  USB_HW_MCHP_18F14K50    Microchip low-pin count USB            ////
.................... ////                          development kit (PIC18F14K50).         ////
.................... ////  USB_HW_MCHP_18F46J50    Microchip USB PIM Demo Board           ////
.................... ////                          (PIC18F46J50).                         ////
.................... ////  USB_HW_GENERIC_18F67J50 Generic 18F67J50 example.              ////
.................... ////  USB_HW_GENERIC_18F27J53 Generic 18F27J53 example.              ////
.................... ////  USB_HW_GENERIC_18F45K50 Generic 18F45K50 example.              ////
.................... ////  USB_HW_GENERIC_18F67J94 Generic 18F67J94 example.              ////
.................... ////  USB_HW_MCHP_EXPLORER16_24F  Microchip Explorer16 with USB      ////
.................... ////                          OTG PICTail Plus.                      ////
.................... ////  USB_HW_MCHP_EXPLORER16_24E  Microchip Explorer16 with USB      ////
.................... ////                          OTG PICTail Plus.                      ////
.................... ////  USB_HW_CCS_24FJ64GC006  CCS PIC24USB development kit,          ////
.................... ////                 PIC replaced with PIC24FJ64GC006 and grounding  ////
.................... ////                 pin 21 (SVss).                                  ////
.................... ////  USB_HW_CCS_24FJ1024GB606 CCS PIC24USB development kit,         ////
.................... ////                 PIC replaced with PIC24FJ1024GB606.             ////
.................... ////  USB_HW_CCS_18F4523      The PIC16F1459 on the CCS 18F4523      ////
.................... ////                            development kit.                     ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// VERSION HISTORY                                                 ////
.................... ////                                                                 ////
.................... //// May 13th, 2016:                                                 ////
.................... ////  Addded USB_HW_CCS_24FJ1024GB606.                               ////
.................... ////                                                                 ////
.................... //// April 6th, 2016:                                                ////
.................... ////  Replaced USB_HW_GENERIC_24FJ128GC006 with                      ////
.................... ////  USB_HW_CCS_24FJ64GC006.                                        ////
.................... ////                                                                 ////
.................... //// December 15th, 2015:                                            ////
.................... ////  Added USB_HW_CCS_E3.  But this kit comes with a USB CDC        ////
.................... ////  bootloader, so in most cases you may want to use the e3.h      ////
.................... ////  include file that comes with the compiler instead of           ////
.................... ////  using this.                                                    ////
.................... ////                                                                 ////
.................... //// June 30, 2015:                                                  ////
.................... ////  Added USB_HW_CCS_18F4523                                       ////
.................... ////                                                                 ////
.................... //// Sep 18, 2014:                                                   ////
.................... ////  Added USB_HW_CCS_PIC18F45K50                                   ////
.................... ////                                                                 ////
.................... //// Dec 17, 2013:                                                   ////
.................... ////  Added USB_HW_GENERIC_18F67J94                                  ////
.................... ////  Added USB_HW_GENERIC_24FJ128GC006                              ////
.................... ////                                                                 ////
.................... //// July 1, 2013:                                                   ////
.................... ////  Added USB_HW_CCS_16F1459                                       ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added USB_HW_GENERIC_18F45K50                                  ////
.................... ////                                                                 ////
.................... //// Feb 15th, 2013:                                                 ////
.................... ////  Removed USB_HW_CCS_PIC16C765, added USB_HW_MCHP_16F1459        ////
.................... ////                                                                 ////
.................... //// Mar 7th, 2012:                                                  ////
.................... ////  Renamed USB_HW_MCHP_EXPLORER16 to USB_HW_MCHP_EXPLORER16_24F.  ////
.................... ////  Added USB_HW_MCHP_EXPLORER16_24E.                              ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Added initial 18F47J53 family support.                         ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   ////
.................... ////                                                                 ////
.................... //// August 31st, 2010:                                              ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and           ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                              ////
.................... ////                                                                 ////
.................... //// April 28th, 2010:                                               ////
.................... ////  Added ex_usb_common.h.                                         ////
.................... ////  Initial support for CCS PIC24USB board.                        ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()        ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create     ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards        ////
.................... ////     compatibility).                                             ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... ////// Begin User Configuration
.................... 
.................... #define USB_HW_CCS_PIC18F4550     //CCS PIC18F4550 USB Development kit
.................... //#define USB_HW_CCS_PIC18F45K50     //CCS PIC18F45K50 USB Development kit
.................... //#define USB_HW_CCS_E3   //CCS E3 Mini development kit.  18F14K50 with 12Mhz crystal.
.................... //#define USB_HW_CCS_16F1459        //CCS Rapid USB devleopment kit.  16F1459 with no oscillator
.................... //#define USB_HW_CCS_PIC24F           //CCS 24FJ256GB206 USB Development kit
.................... //#define USB_HW_CCS_PIC33EP           //CCS PIC24 USB Development kit, PIC replaced with a 33EP256MU806
.................... //#define USB_HW_CCS_USBN9604       //CCS National USBN9604 USB development kit (external USB peripheral)
.................... //#define USB_HW_MCHP_18F14K50      //Microchip low-pin count USB development kit (PIC18F14K50)
.................... //#define USB_HW_MCHP_18F46J50      //Microchip USB PIM Demo Board (PIC18F46J50)
.................... //#define USB_HW_GENERIC_18F67J50   //Generic 18F67J50 example
.................... //#define USB_HW_GENERIC_18F27J53   //Generic 18F27J53 example
.................... //#define USB_HW_MCHP_EXPLORER16_24F   //Microchip Explorer16 with USB OTG PICTail+ & 24FJ256GB110
.................... //#define USB_HW_MCHP_EXPLORER16_24E   //Microchip Explorer16 with USB OTG PICTail+
.................... //#define USB_HW_MCHP_16F1459        //Microchip low-pin count USB development kit with a 16F1459, using internal oscillator with active clock tuning  NOTE: the ICD pins on the low pin count development kit are not compatible with this chip!
.................... //#define USB_HW_GENERIC_18F45K50     //Generic 18F45K50 example.  You can get this by taking a CCS 4550 board and replacing the PIC with a 45K50 and the crystal wiht a 12Mhz
.................... //#define USB_HW_GENERIC_18F67J94   //Generic 18F67J94 example.
.................... //#define USB_HW_CCS_24FJ64GC006       //CCS PIC24USB development kit, PIC replaced with PIC24FJ64GC006 and grounding pin 21 (SVss)
.................... //#define USB_HW_CCS_24FJ1024GB606       //CCS PIC24USB development kit, PIC replaced with PIC24FJ1024GB606
.................... //#define USB_HW_MCHP_24FJ1024GB610       //Microchip Explorer 16 with 24FJ1024GB610 PIM and USB OTG PICtail+
.................... //#define USB_HW_CCS_18F4523          //The PIC16F1459 on the 18F4523 development kit
.................... 
.................... // Optional configuration.
.................... // Defining USB_ISR_POLLING will have USB library not use ISRs.  Instead you
.................... // must periodically call usb_task().
.................... //#define USB_ISR_POLLING
.................... 
.................... ////// End User Configuration
.................... 
.................... #ifndef __EX_USB_COMMON_H__
.................... #define __EX_USB_COMMON_H__
.................... 
.................... #if defined(USB_HW_CCS_PIC18F4550)
....................    #include <18F4550.h>
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
10AE:  CLRF   FF7
10B0:  ADDLW  BE
10B2:  MOVWF  FF6
10B4:  MOVLW  10
10B6:  ADDWFC FF7,F
10B8:  TBLRD*+
10BA:  MOVF   FF5,W
10BC:  RETURN 0
10BE:  DATA 00,03
10C0:  DATA 02,FF
10C2:  DATA FF,FF
10C4:  DATA FF,FF
10C6:  DATA FF,FF
10C8:  DATA FF,FF
10CA:  DATA FF,FF
10CC:  DATA FF,FF
10CE:  CLRF   FF7
10D0:  ADDLW  DE
10D2:  MOVWF  FF6
10D4:  MOVLW  10
10D6:  ADDWFC FF7,F
10D8:  TBLRD*+
10DA:  MOVF   FF5,W
10DC:  RETURN 0
10DE:  DATA 00,FF
10E0:  DATA 02,FF
10E2:  DATA FF,FF
10E4:  DATA FF,FF
10E6:  DATA FF,FF
10E8:  DATA FF,FF
10EA:  DATA FF,FF
10EC:  DATA FF,FF
10EE:  CLRF   FF7
10F0:  ADDLW  FE
10F2:  MOVWF  FF6
10F4:  MOVLW  10
10F6:  ADDWFC FF7,F
10F8:  TBLRD*+
10FA:  MOVF   FF5,W
10FC:  RETURN 0
10FE:  DATA 40,00
1100:  DATA 0B,00
1102:  DATA 40,00
1104:  DATA 00,00
1106:  DATA 00,00
1108:  DATA 00,00
110A:  DATA 00,00
110C:  DATA 00,00
110E:  DATA 00,00
1110:  DATA 00,00
1112:  DATA 00,00
1114:  DATA 00,00
1116:  DATA 00,00
1118:  DATA 00,00
111A:  DATA 00,00
111C:  DATA 00,00
111E:  CLRF   FF7
1120:  ADDLW  2E
1122:  MOVWF  FF6
1124:  MOVLW  11
1126:  ADDWFC FF7,F
1128:  TBLRD*+
112A:  MOVF   FF5,W
112C:  RETURN 0
112E:  DATA 40,00
1130:  DATA 00,00
1132:  DATA 40,00
1134:  DATA 00,00
1136:  DATA 00,00
1138:  DATA 00,00
113A:  DATA 00,00
113C:  DATA 00,00
113E:  DATA 00,00
1140:  DATA 00,00
1142:  DATA 00,00
1144:  DATA 00,00
1146:  DATA 00,00
1148:  DATA 00,00
114A:  DATA 00,00
114C:  DATA 00,00
114E:  CLRF   FF7
1150:  ADDLW  5E
1152:  MOVWF  FF6
1154:  MOVLW  11
1156:  ADDWFC FF7,F
1158:  TBLRD*+
115A:  MOVF   FF5,W
115C:  RETURN 0
115E:  DATA 09,02
1160:  DATA 43,00
1162:  DATA 02,01
1164:  DATA 00,80
1166:  DATA 32,09
1168:  DATA 04,00
116A:  DATA 00,01
116C:  DATA 02,02
116E:  DATA 01,00
1170:  DATA 05,24
1172:  DATA 00,10
1174:  DATA 01,04
1176:  DATA 24,02
1178:  DATA 02,05
117A:  DATA 24,06
117C:  DATA 00,01
117E:  DATA 05,24
1180:  DATA 01,00
1182:  DATA 01,07
1184:  DATA 05,81
1186:  DATA 03,0B
1188:  DATA 00,FA
118A:  DATA 09,04
118C:  DATA 01,00
118E:  DATA 02,0A
1190:  DATA 00,00
1192:  DATA 00,07
1194:  DATA 05,02
1196:  DATA 02,40
1198:  DATA 00,01
119A:  DATA 07,05
119C:  DATA 82,02
119E:  DATA 40,00
11A0:  DATA 01,00
11A2:  CLRF   FF7
11A4:  ADDLW  B2
11A6:  MOVWF  FF6
11A8:  MOVLW  11
11AA:  ADDWFC FF7,F
11AC:  TBLRD*+
11AE:  MOVF   FF5,W
11B0:  RETURN 0
11B2:  DATA 02,00
11B4:  CLRF   FF7
11B6:  ADDLW  C4
11B8:  MOVWF  FF6
11BA:  MOVLW  11
11BC:  ADDWFC FF7,F
11BE:  TBLRD*+
11C0:  MOVF   FF5,W
11C2:  RETURN 0
11C4:  DATA 12,17
11C6:  DATA 1B,20
11C8:  DATA FF,FF
11CA:  DATA FF,FF
11CC:  CLRF   FF7
11CE:  ADDLW  DC
11D0:  MOVWF  FF6
11D2:  MOVLW  11
11D4:  ADDWFC FF7,F
11D6:  TBLRD*+
11D8:  MOVF   FF5,W
11DA:  RETURN 0
11DC:  DATA 12,01
11DE:  DATA 10,01
11E0:  DATA 02,00
11E2:  DATA 00,40
11E4:  DATA 05,24
11E6:  DATA 0B,00
11E8:  DATA 00,01
11EA:  DATA 01,02
11EC:  DATA 00,01
11EE:  CLRF   FF7
11F0:  ADDLW  FE
11F2:  MOVWF  FF6
11F4:  MOVLW  11
11F6:  ADDWFC FF7,F
11F8:  TBLRD*+
11FA:  MOVF   FF5,W
11FC:  RETURN 0
11FE:  DATA 04,03
1200:  DATA 09,04
1202:  DATA 08,03
1204:  DATA 43,00
1206:  DATA 43,00
1208:  DATA 53,00
120A:  DATA 20,03
120C:  DATA 43,00
120E:  DATA 43,00
1210:  DATA 53,00
1212:  DATA 20,00
1214:  DATA 55,00
1216:  DATA 53,00
1218:  DATA 42,00
121A:  DATA 20,00
121C:  DATA 74,00
121E:  DATA 6F,00
1220:  DATA 20,00
1222:  DATA 55,00
1224:  DATA 41,00
1226:  DATA 52,00
1228:  DATA 54,00
122A:  CLRF   FF7
122C:  ADDLW  3A
122E:  MOVWF  FF6
1230:  MOVLW  12
1232:  ADDWFC FF7,F
1234:  TBLRD*+
1236:  MOVF   FF5,W
1238:  RETURN 0
123A:  DATA 28,0C
123C:  DATA 01,06
*
12D2:  MOVF   xD5,W
12D4:  MULWF  xD7
12D6:  MOVFF  FF3,01
12DA:  MOVFF  FF4,00
12DE:  MULWF  xD8
12E0:  MOVF   FF3,W
12E2:  ADDWF  00,F
12E4:  MOVF   xD6,W
12E6:  MULWF  xD7
12E8:  MOVF   FF3,W
12EA:  ADDWFC 00,W
12EC:  MOVWF  02
12EE:  RETURN 0
*
1FCC:  DATA 55,53
1FCE:  DATA 42,20
1FD0:  DATA 63,6F
1FD2:  DATA 6E,6E
1FD4:  DATA 65,63
1FD6:  DATA 74,65
1FD8:  DATA 64,2C
1FDA:  DATA 20,77
1FDC:  DATA 61,69
1FDE:  DATA 74,69
1FE0:  DATA 6E,67
1FE2:  DATA 20,66
1FE4:  DATA 6F,72
1FE6:  DATA 20,65
1FE8:  DATA 6E,75
1FEA:  DATA 6D,61
1FEC:  DATA 72,61
1FEE:  DATA 74,69
1FF0:  DATA 6F,6E
1FF2:  DATA 2E,2E
1FF4:  DATA 2E,0D
1FF6:  DATA 0A,0A
1FF8:  DATA 00,00
1FFA:  DATA 55,53
1FFC:  DATA 42,20
1FFE:  DATA 64,69
2000:  DATA 73,63
2002:  DATA 6F,6E
2004:  DATA 6E,65
2006:  DATA 63,74
2008:  DATA 65,64
200A:  DATA 2C,20
200C:  DATA 77,61
200E:  DATA 69,74
2010:  DATA 69,6E
2012:  DATA 67,20
2014:  DATA 66,6F
2016:  DATA 72,20
2018:  DATA 63,6F
201A:  DATA 6E,6E
201C:  DATA 65,63
201E:  DATA 74,69
2020:  DATA 6F,6E
2022:  DATA 2E,2E
2024:  DATA 2E,0D
2026:  DATA 0A,0A
2028:  DATA 00,00
202A:  DATA 55,53
202C:  DATA 42,20
202E:  DATA 65,6E
2030:  DATA 75,6D
2032:  DATA 65,72
2034:  DATA 61,74
2036:  DATA 65,64
2038:  DATA 20,62
203A:  DATA 79,20
203C:  DATA 50,43
203E:  DATA 2F,48
2040:  DATA 4F,53
2042:  DATA 54,0D
2044:  DATA 0A,0A
2046:  DATA 00,00
2048:  DATA 55,53
204A:  DATA 42,20
204C:  DATA 75,6E
204E:  DATA 65,6E
2050:  DATA 75,6D
2052:  DATA 65,72
2054:  DATA 61,74
2056:  DATA 65,64
2058:  DATA 20,62
205A:  DATA 79,20
205C:  DATA 50,43
205E:  DATA 2F,48
2060:  DATA 4F,53
2062:  DATA 54,2C
2064:  DATA 20,77
2066:  DATA 61,69
2068:  DATA 74,69
206A:  DATA 6E,67
206C:  DATA 20,66
206E:  DATA 6F,72
2070:  DATA 20,65
2072:  DATA 6E,75
2074:  DATA 6D,65
2076:  DATA 72,61
2078:  DATA 74,69
207A:  DATA 6F,6E
207C:  DATA 2E,2E
207E:  DATA 2E,0D
2080:  DATA 0A,0A
2082:  DATA 00,00
2084:  DATA 53,65
2086:  DATA 72,69
2088:  DATA 61,6C
208A:  DATA 20,70
208C:  DATA 72,6F
208E:  DATA 67,72
2090:  DATA 61,6D
2092:  DATA 20,69
2094:  DATA 6E,69
2096:  DATA 74,69
2098:  DATA 61,74
209A:  DATA 65,64
209C:  DATA 20,6F
209E:  DATA 6E,20
20A0:  DATA 55,53
20A2:  DATA 42,3C
20A4:  DATA 2D,3E
20A6:  DATA 55,41
20A8:  DATA 52,54
20AA:  DATA 20,43
20AC:  DATA 4F,4D
20AE:  DATA 20,50
20B0:  DATA 6F,72
20B2:  DATA 74,0D
20B4:  DATA 0A,0A
20B6:  DATA 00,00
20B8:  DATA 0D,0A
20BA:  DATA 4E,65
20BC:  DATA 77,20
20BE:  DATA 62,75
20C0:  DATA 74,74
20C2:  DATA 6F,6E
20C4:  DATA 20,73
20C6:  DATA 74,61
20C8:  DATA 74,65
20CA:  DATA 20,62
20CC:  DATA 65,69
20CE:  DATA 6E,67
20D0:  DATA 20,73
20D2:  DATA 65,6E
20D4:  DATA 74,3A
20D6:  DATA 20,00
20D8:  DATA 46,41
20DA:  DATA 49,4C
20DC:  DATA 00,00
20DE:  DATA 0D,0A
20E0:  DATA 0A,43
20E2:  DATA 43,53
20E4:  DATA 20,43
20E6:  DATA 44,43
20E8:  DATA 20,28
20EA:  DATA 56,69
20EC:  DATA 72,74
20EE:  DATA 75,61
20F0:  DATA 6C,20
20F2:  DATA 52,53
20F4:  DATA 32,33
20F6:  DATA 32,29
20F8:  DATA 20,45
20FA:  DATA 78,61
20FC:  DATA 6D,70
20FE:  DATA 6C,65
2100:  DATA 0D,0A
2102:  DATA 00,00
2104:  DATA 0D,0A
2106:  DATA 50,43
2108:  DATA 4D,3A
210A:  DATA 20,76
210C:  DATA 00,00
210E:  DATA 35,2E
2110:  DATA 31,30
2112:  DATA 34,00
2114:  DATA 0C,55
2116:  DATA 53,42
2118:  DATA 2D,53
211A:  DATA 65,72
211C:  DATA 69,61
211E:  DATA 6C,0A
2120:  DATA 63,6F
2122:  DATA 6E,20
2124:  DATA 70,69
2126:  DATA 63,31
2128:  DATA 38,66
212A:  DATA 34,35
212C:  DATA 35,30
212E:  DATA 00,00
2130:  DATA 0C,53
2132:  DATA 75,73
2134:  DATA 63,72
2136:  DATA 69,62
2138:  DATA 65,74
213A:  DATA 65,0A
213C:  DATA 41,6C
213E:  DATA 20,63
2140:  DATA 61,6E
2142:  DATA 61,6C
2144:  DATA 00,00
2146:  DATA 48,45
2148:  DATA 4C,4C
214A:  DATA 4F,2D
214C:  DATA 57,4F
214E:  DATA 52,4C
2150:  DATA 44,2D
2152:  DATA 48,45
2154:  DATA 4C,4C
2156:  DATA 4F,2D
2158:  DATA 57,4F
215A:  DATA 52,4C
215C:  DATA 44,2D
215E:  DATA 48,45
2160:  DATA 4C,4C
2162:  DATA 4F,2D
2164:  DATA 57,4F
2166:  DATA 52,4C
2168:  DATA 44,2D
216A:  DATA 48,45
216C:  DATA 4C,4C
216E:  DATA 4F,2D
2170:  DATA 57,4F
2172:  DATA 52,4C
2174:  DATA 44,2D
2176:  DATA 48,45
2178:  DATA 4C,4C
217A:  DATA 4F,2D
217C:  DATA 57,4F
217E:  DATA 52,4C
2180:  DATA 44,2D
2182:  DATA 48,45
2184:  DATA 4C,4C
2186:  DATA 4F,2D
2188:  DATA 57,4F
218A:  DATA 52,4C
218C:  DATA 44,2D
218E:  DATA 48,45
2190:  DATA 4C,4C
2192:  DATA 4F,2D
2194:  DATA 57,4F
2196:  DATA 52,4C
2198:  DATA 44,2D
219A:  DATA 48,45
219C:  DATA 4C,4C
219E:  DATA 4F,2D
21A0:  DATA 57,4F
21A2:  DATA 52,4C
21A4:  DATA 44,2D
21A6:  DATA 44,4F
21A8:  DATA 4E,45
21AA:  DATA 00,00
21AC:  TBLRD*+
21AE:  MOVF   FF5,F
21B0:  BZ    21CC
21B2:  MOVFF  FF6,AE
21B6:  MOVFF  FF7,AF
21BA:  MOVF   FF5,W
21BC:  BTFSS  F9E.4
21BE:  BRA    21BC
21C0:  MOVWF  FAD
21C2:  MOVFF  AE,FF6
21C6:  MOVFF  AF,FF7
21CA:  BRA    21AC
21CC:  RETURN 0
*
23F0:  TBLRD*+
23F2:  MOVF   FF5,F
23F4:  BZ    240E
23F6:  MOVFF  FF6,AC
23FA:  MOVFF  FF7,AD
23FE:  MOVFF  FF5,AE
2402:  RCALL  23A8
2404:  MOVFF  AC,FF6
2408:  MOVFF  AD,FF7
240C:  BRA    23F0
240E:  RETURN 0
*
2462:  TSTFSZ 01
2464:  BRA    246C
2466:  TSTFSZ 02
2468:  BRA    246E
246A:  BRA    247A
246C:  INCF   02,F
246E:  MOVFF  00,FEE
2472:  DECFSZ 01,F
2474:  BRA    246E
2476:  DECFSZ 02,F
2478:  BRA    246E
247A:  GOTO   2576 (RETURN)
*
2686:  TBLRD*+
2688:  MOVF   FF5,F
268A:  BZ    26A4
268C:  MOVFF  FF6,AC
2690:  MOVFF  FF7,AD
2694:  MOVFF  FF5,AE
2698:  RCALL  264C
269A:  MOVFF  AC,FF6
269E:  MOVFF  AD,FF7
26A2:  BRA    2686
26A4:  GOTO   2804 (RETURN)
*
26E0:  MOVF   FEF,F
26E2:  BZ    2702
26E4:  MOVFF  FEA,AD
26E8:  MOVFF  FE9,AC
26EC:  MOVFF  FEF,AE
26F0:  RCALL  23A8
26F2:  MOVFF  AD,FEA
26F6:  MOVFF  AC,FE9
26FA:  INCF   FE9,F
26FC:  BTFSC  FD8.2
26FE:  INCF   FEA,F
2700:  BRA    26E0
2702:  GOTO   2840 (RETURN)
.................... 
.................... #list
.................... 
....................    #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN
....................    #use delay(clock=48000000)
*
21FA:  CLRF   FEA
21FC:  MOVLW  AF
21FE:  MOVWF  FE9
2200:  MOVF   FEF,W
2202:  BZ    2220
2204:  MOVLW  0F
2206:  MOVWF  01
2208:  CLRF   00
220A:  DECFSZ 00,F
220C:  BRA    220A
220E:  DECFSZ 01,F
2210:  BRA    2208
2212:  MOVLW  8F
2214:  MOVWF  00
2216:  DECFSZ 00,F
2218:  BRA    2216
221A:  NOP   
221C:  DECFSZ FEF,F
221E:  BRA    2204
2220:  RETURN 0
....................    #build (reset=0x1000,interrupt=0x1008)
....................    #org 0x0000,0x0FFF{}
.................... 
....................    //leds ordered from bottom to top
....................    #DEFINE LED1 PIN_E0  //green
....................    #define LED2 PIN_E1  //yellow
....................    #define LED3 PIN_E2  //red
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define BUTTON_PRESSED() !input(PIN_B4)
.................... 
....................    //see section below labeled USB_CABLE_IS_ATTACHED
....................    //#define PIN_USB_SENSE   PIN_B2
.................... 
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL
....................    #define HW_ADC_CHANNEL  0
....................    #define HW_ADC_PORTS    AN0
....................    
....................    #define HW_INIT() setup_adc_ports(HW_ADC_PORTS)
.................... #endif
.................... 
.................... #if defined(USB_HW_CCS_PIC18F45K50)
....................    #include <18F45K50.h>
....................    
....................    #if 1
....................       // use the external crystal on the board
....................       #use delay(crystal=16MHz, clock=48MHz, USB_FULL)
....................    #else
....................       // use the internal oscillator with active clock tuning
....................       #use delay(int, clock=48MHz, USB_FULL, act=USB)
....................    #endif
....................    
....................    #fuses WDT_SW         //No Watch Dog Timer, enabled in Software
....................    #fuses CCP2C1         //CCP2 input/output multiplexed with RC1
....................    #fuses PUT            //Power Up Timer
....................    #fuses BROWNOUT_SW    //Brownout controlled by configuration bit in special file register
....................    #fuses BORV19         //Brownout reset at 1.9V
....................    #fuses PBADEN         //PORTB pins are configured as analog input channels on RESET
....................    #fuses T3CKC0         //T3 Clock In is on C0
....................    #fuses SDOB3          //SDO is on RB3
....................    #fuses MCLR           //Master Clear pin enabled
....................    #fuses NOLVP          //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
....................    #fuses NOSTVREN       //Stack full/underflow will not cause reset
....................    #fuses NOPROTECT      //Code not protected from reading
....................    #fuses NOCPB          //No Boot Block code protection
....................    #fuses NOCPD          //No EE protection
....................    #fuses NOWRT          //Program memory not write protected
....................    #fuses WRTC           //Configuration registers write protected
....................    #fuses NOWRTB         //Boot block not write protected
....................    #fuses NOWRTD         //Data EEPROM not write protected
....................    #fuses NOEBTR         //Memory not protected from table reads
....................    #fuses NOEBTRB        //Boot block not protected from table reads
.................... 
....................    //leds ordered from bottom to top
....................    #DEFINE LED1 PIN_A5  //green
....................    #define LED2 PIN_B4  //yellow
....................    #define LED3 PIN_B5  //red
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define BUTTON_PRESSED() !input(PIN_A4)
.................... 
....................    //see section below labeled USB_CABLE_IS_ATTACHED
....................    #define PIN_USB_SENSE   PIN_B2
.................... 
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL
....................    #define HW_ADC_CHANNEL  0  //PIN_A0
....................    #define HW_ADC_PORTS    sAN0
....................    
....................    #define HW_INIT() setup_adc_ports(HW_ADC_PORTS)
.................... #endif
.................... 
.................... #if defined(USB_HW_CCS_16F1459)
....................    #include <16F1459.h>
.................... 
....................    #use delay(int=8MHz, clock=48MHz, USB_FULL, act=USB)
.................... 
....................    #fuses MCLR
....................    #fuses PUT
....................    #fuses WDT_SW         //No Watch Dog Timer, enabled in Software
....................    #fuses NOPROTECT      //Code not protected from reading
....................    #fuses NOBROWNOUT     //No brownout reset
....................    #fuses NOWRT          //Program memory not write protected, otherwise bootloader won't work
....................    #fuses NOSTVREN       //Stack full/underflow will not cause reset
....................    #fuses NOLPBOR        //Low-Power Brownout reset is disabled
....................    #fuses NOLVP          //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... 
....................    //leds are ordered left to right
....................    #define LED_DIR1 PIN_A5
....................    #define LED_DIR2 PIN_C6
....................    #define LED_ON(x)    delay_cycles(1)
....................    #define LED_OFF(x)   delay_cycles(1)
....................    #define LEDS_OFF()      output_low(LED_DIR1);  output_low(LED_DIR2)
....................    #define LEDS_GREEN()    LEDS_OFF(); output_high(LED_DIR1)
....................    #define LEDS_RED()      LEDS_OFF(); output_high(LED_DIR2)
....................    #define LEDS_TOGGLE()   output_toggle(LED_DIR1);  output_toggle(LED_DIR2)
.................... 
....................    #define BUTTON_PRESSED() !input(PIN_C1)
.................... 
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL
....................    #define HW_ADC_CHANNEL  11 //PIN_B5
....................    #define HW_ADC_PORTS    sAN11
.................... 
....................    #define HW_INIT() setup_adc_ports(HW_ADC_PORTS); setup_comparator(NC_NC_NC_NC)
....................    
....................    #define __NO_UART__
....................    
....................    //#define UART_IS_ICD
....................    
....................   #if defined(UART_IS_ICD)
....................    #warning Can't use button and ICSP streaming because they share the same pin!
....................    #define UART_ICD_SETTINGS  xmit=PIN_C0, rcv=PIN_C1, baud=57600
....................   #endif
.................... #endif
.................... 
.................... #if defined(USB_HW_CCS_E3)
....................    #include <18F14K50.h>
.................... 
....................    #use delay(crystal=12MHz, clock=48MHz, USB_FULL)
....................    
....................    #fuses NOWDT
....................    
....................    #define LED1 PIN_C6     //green
....................    #define LED2 PIN_C4     //yellow
....................    #define LED3 PIN_C3     //red
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define LED_ON(x) output_high(x)
....................    #define LED_OFF(x) output_low(x)
....................    #define BUTTON_PRESSED() !input(PIN_C1)
....................    
....................    #define HW_ADC_PORTS    sAN4
....................    #define HW_ADC_CHANNEL  4
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL | ADC_TAD_MUL_2
....................    
....................    //hardware UART pins for this pic is PIN_B5 and PIN_B7
.................... #endif
.................... 
.................... #if defined(USB_HW_CCS_PIC24F)
....................    #include <24FJ256GB206.h>
....................    #build(stack=1024)
....................    #device ICSP=2
....................    #device ADC=8
....................    #fuses HS,PR_PLL,NOWDT,PLL5,SOSC_DIG
....................    #use delay(clock=32M)
.................... 
....................    #pin_select U1TX = PIN_D5
....................    #pin_select U1RX = PIN_D4
.................... 
....................    #pin_select SDI2 = PIN_F5
....................    #pin_select SDO2 = PIN_B15
....................    #pin_select SCK2OUT = PIN_F4
.................... 
....................    #define LED1 PIN_B9     //green
....................    #define LED2 PIN_B10    //yellow
....................    #define LED3 PIN_B11    //red
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define LED_ON(x) output_high(x)
....................    #define LED_OFF(x) output_low(x)
....................    #define BUTTON_PRESSED() !input(PIN_F0)
.................... 
....................    #define HW_ADC_PORTS    sAN0|sAN2   //AN0/PIN_B0=POT, AN2/PIN_B2=VBus
....................    #define HW_ADC_CHANNEL  0
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31
.................... 
....................    #define LCD_ENABLE_PIN  PIN_D0
....................    #define LCD_RS_PIN      PIN_D1
....................    #define LCD_RW_PIN      PIN_D2
....................    #define LCD_DATA4       PIN_E6
....................    #define LCD_DATA5       PIN_E7
....................    #define LCD_DATA6       PIN_D6
....................    #define LCD_DATA7       PIN_D7
.................... #endif
.................... 
.................... #if defined(USB_HW_MCHP_24FJ1024GB610)
....................    #include <24FJ1024GB610.h>
....................    //#device ICSP=2  //??
....................    #device ADC=8
....................    
....................    #use delay(crystal=8MHz, clock=32MHz, USB_FULL)
....................    #fuses NOWDT
.................... 
....................    #pin_select U1TX = PIN_F5
....................    #pin_select U1RX = PIN_F4
....................    #define PIN_UART1_RTS   PIN_F13  //out to PC
....................    #define PIN_UART1_CTS   PIN_F12  //in to PIC
.................... 
....................    // led's ordered from left to right
....................    #define LED1 PIN_A7
....................    #define LED2 PIN_A6
....................    #define LED3 PIN_A5
....................    #define LED4 PIN_A4
....................    #define LED5 PIN_A3
....................    #define LED6 PIN_A2
....................    #define LED7 PIN_A1
....................    #define LED8 PIN_A0
....................    #define LED_ON(x) output_high(x)
....................    #define LED_OFF(x) output_low(x)
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3); LED_OFF(LED4);  LED_OFF(LED5); LED_OFF(LED6); LED_OFF(LED7); LED_OFF(LED8)
....................    #define BUTTON_PRESSED() !input(PIN_D6)
.................... 
....................    #define HW_ADC_PORTS    sAN5
....................    #define HW_ADC_CHANNEL  5
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31
.................... #endif
.................... 
.................... #if defined(USB_HW_CCS_24FJ1024GB606)
....................    #include <24FJ1024GB606.h>
....................    #device ICSP=2
....................    #device ADC=8
....................    
....................    #use delay(crystal=20MHz, clock=32MHz, USB_FULL)
....................    #fuses NOWDT
.................... 
....................    #pin_select U1TX = PIN_D5
....................    #pin_select U1RX = PIN_D4
.................... 
....................    #pin_select SDI2 = PIN_F5
....................    #pin_select SDO2 = PIN_B15
....................    #pin_select SCK2OUT = PIN_F4
.................... 
....................    #define LED1 PIN_B9     //green
....................    #define LED2 PIN_B10    //yellow
....................    #define LED3 PIN_B11    //red
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define LED_ON(x) output_high(x)
....................    #define LED_OFF(x) output_low(x)
....................    #define BUTTON_PRESSED() !input(PIN_F0)
.................... 
....................    #define HW_ADC_PORTS    sAN0|sAN2   //AN0/PIN_B0=POT, AN2/PIN_B2=VBus
....................    #define HW_ADC_CHANNEL  0
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31
.................... 
....................    #define LCD_ENABLE_PIN  PIN_D0
....................    #define LCD_RS_PIN      PIN_D1
....................    #define LCD_RW_PIN      PIN_D2
....................    #define LCD_DATA4       PIN_E6
....................    #define LCD_DATA5       PIN_E7
....................    #define LCD_DATA6       PIN_D6
....................    #define LCD_DATA7       PIN_D7
....................    
....................    #define HW_INIT() setup_adc_ports(HW_ADC_PORTS)
.................... #endif
.................... 
.................... #if defined(USB_HW_CCS_PIC33EP)
....................    #include <33EP256MU806.h>
....................    #build(stack=1024)
....................    #device ADC=8
....................    //20MHz clock is scaled to 48mhz for usb clock.
....................    //20mhz clock is scaled to 120mhz for cpu operation.
....................    #use delay(crystal=20Mhz, clock=120Mhz, AUX:clock=48Mhz)
....................    #fuses NOWDT
.................... 
....................    #pin_select U1TX = PIN_D5
....................    #pin_select U1RX = PIN_D4
.................... 
....................    #define LED1 PIN_B9     //green
....................    #define LED2 PIN_B10    //yellow
....................    #define LED3 PIN_B11    //red
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define LED_ON(x) output_high(x)
....................    #define LED_OFF(x) output_low(x)
....................    #define BUTTON_PRESSED() !input(PIN_F0)
.................... 
....................    #define HW_ADC_PORTS    sAN0|sAN2   //0=pot, 2=vbus
....................    #define HW_ADC_CHANNEL  0
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31
.................... 
....................    #define LCD_ENABLE_PIN  PIN_D0
....................    #define LCD_RS_PIN      PIN_D1
....................    #define LCD_RW_PIN      PIN_D2
....................    #define LCD_DATA4       PIN_E6
....................    #define LCD_DATA5       PIN_E7
....................    #define LCD_DATA6       PIN_D6
....................    #define LCD_DATA7       PIN_D7   
.................... #endif
.................... 
.................... #if defined(USB_HW_GENERIC_18F45K50)
....................    #include <18F45K50.h>
....................    
....................    #fuses NOWDT
....................    
....................    //#use delay(crystal=12Mhz, clock=48Mhz, USB_FULL)
....................    #fuses NOCPUDIV, PLLEN, PLL4X, HSH, PRIMARY, NOIESO, NOFCMEN  //12mhz crystal, 48mhz clock for pic and usb
....................    #use delay(clock=48MHz)
.................... 
....................    //leds ordered from bottom to top
....................    #DEFINE LED1 PIN_A5  //green
....................    #define LED2 PIN_B4  //yellow
....................    #define LED3 PIN_B5  //red
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define BUTTON_PRESSED() !input(PIN_A4)
.................... 
....................    //see section below labeled USB_CABLE_IS_ATTACHED
....................    #define PIN_USB_SENSE   PIN_B2
.................... 
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL
....................    #define HW_ADC_CHANNEL  0
....................    #define HW_ADC_PORTS    sAN0
.................... #endif
.................... 
.................... #if defined(USB_HW_MCHP_EXPLORER16_24E)
....................    #include <24EP512GU810.h>
....................    #build(stack=1024)
....................    #device ADC=8
.................... 
....................    #fuses NOWDT, NOIESO
.................... 
....................    //8MHz clock is scaled to 48mhz for usb clock.
....................    //8mhz clock is scaled to 120mhz for cpu operation.
....................    #use delay(crystal=8Mhz, clock=120Mhz, AUX:clock=48Mhz)
....................    
....................    // no pin select compatible.
....................    #pin_select U1TX = PIN_F5
....................    #pin_select U1RX = PIN_F4
....................    #define PIN_UART1_RTS   PIN_F13  //out to PC
....................    #define PIN_UART1_CTS   PIN_F12  //in to PIC
.................... 
....................    // led's ordered from right to left
....................    #define LED1 PIN_A0  //D3
....................    #define LED2 PIN_A1  //D4
....................    #define LED3 PIN_A2  //D5
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define LED_ON(x) output_high(x)
....................    #define LED_OFF(x) output_low(x)
.................... 
....................    #define BUTTON_PRESSED() !input(PIN_D6)   //s3
.................... 
....................    #define HW_ADC_PORTS    sAN5
....................    #define HW_ADC_CHANNEL  5
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31
.................... 
....................    /*
....................    #byte ACLKCON3=getenv("SFR:ACLKCON3")
....................    #byte ACLKDIV3=getenv("SFR:ACLKDIV3")
....................    #bit ACLKCON3_APLLCK=ACLKCON3.14
....................    #bit ACLKCON3_ENAPLL=ACLKCON3.15
....................    //#define HW_INIT() while(!ACLKCON3_APLLCK)
....................    #define HW_INIT() APllInit()
....................    void ApllInit(void)
....................    {
....................       ACLKCON3 = 0x24C1;
....................       ACLKDIV3 = 0x7;
....................       ACLKCON3_ENAPLL = 1;
....................       while(!ACLKCON3_APLLCK);
....................    }
....................    */
.................... #endif
.................... 
.................... #if defined(USB_HW_MCHP_EXPLORER16_24F)
....................    #include <24FJ256GB110.h>
....................    #build(stack=1024)
....................    #device ADC=8
....................    #fuses HS,PR_PLL,NOWDT,DISUVREG,ICSP2
....................    #use delay(clock=32M)  //8MHz clock is 4x because of PLL
....................    #fuses PLL2   //Divide 8MHz by 2 to get the 4MHz required for USB
.................... 
....................    #pin_select U1TX = PIN_F5
....................    #pin_select U1RX = PIN_F4
....................    #define PIN_UART1_RTS   PIN_F13  //out to PC
....................    #define PIN_UART1_CTS   PIN_F12  //in to PIC
.................... 
....................    // led's ordered from left to right
....................    #define LED1 PIN_A7
....................    #define LED2 PIN_A6
....................    #define LED3 PIN_A5
....................    #define LED4 PIN_A4
....................    #define LED5 PIN_A3
....................    #define LED6 PIN_A2
....................    #define LED7 PIN_A1
....................    #define LED8 PIN_A0
....................    #define LED_ON(x) output_high(x)
....................    #define LED_OFF(x) output_low(x)
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3); LED_OFF(LED4);  LED_OFF(LED5); LED_OFF(LED6); LED_OFF(LED7); LED_OFF(LED8)
....................    #define BUTTON_PRESSED() !input(PIN_D6)
.................... 
....................    #define HW_ADC_PORTS    sAN5
....................    #define HW_ADC_CHANNEL  5
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31
.................... #endif
.................... 
.................... #if defined(USB_HW_CCS_USBN9604)
....................    #include <18F452.h>
....................    #fuses HS,NOWDT,NOPROTECT,NOLVP
....................    #use delay(clock=20000000)
.................... 
....................    #define __USB_PIC_PERIF__  0
.................... 
....................    #DEFINE LED1  PIN_B3
....................    #define LED2 PIN_B4
....................    #define LED3 PIN_B5
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define BUTTON_PRESSED() !input(PIN_A4)
.................... 
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL
....................    #define HW_ADC_CHANNEL  0
....................    #define HW_ADC_PORTS    AN0
.................... #endif
.................... 
.................... #if defined(USB_HW_MCHP_16F1459)
....................    //NOTE: the ICD pins on the low pin count development kit are not compatible with this chip!
....................    #include <16F1459.h>
.................... 
....................    #use delay(int=8MHz, clock=48MHz, USB_FULL, act=USB)
.................... 
....................    #fuses NOMCLR
....................    #fuses NOWDT
.................... 
....................    //leds are ordered left to right
....................    #define LED1 PIN_C3
....................    #define LED2 PIN_C2
....................    #define LED3 PIN_C1
....................    #define LED4 PIN_C0
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3); LED_OFF(LED4)
....................    #define LED_ON(x) output_high(x)
....................    #define LED_OFF(x) output_low(x)
.................... 
....................    #if getenv("FUSE_SET:NOMCLR")
....................      #define BUTTON_PRESSED() !input(PIN_A3)
....................    #else
....................      #define BUTTON_PRESSED() FALSE
....................    #endif
.................... 
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL
....................    #define HW_ADC_CHANNEL  10
....................    #define HW_ADC_PORTS    sAN10
.................... #endif
.................... 
.................... #if defined(USB_HW_MCHP_18F14K50)
....................    #include <18F14K50.h>
.................... 
....................    #fuses NOIESO
....................    #fuses NOFCMEN
....................    #fuses PCLKEN
....................    #fuses NOPUT
....................    #fuses NOBROWNOUT
....................    #fuses NOWDT
....................    #fuses NOMCLR
....................    #fuses NOHFOFST
....................    #fuses NOLVP
....................    #fuses NOXINST
.................... 
....................    // configure 12MHz clock for USB operation and 48Mhz CPU operation
....................    #fuses HS
....................    #fuses PLLEN   //enable pll, we can now use CPUDIVx fuses
....................    #fuses CPUDIV1 //CPU clock set to 48MHz
....................    #fuses USBDIV2 //when using low speed USB, need to divide 12MHz by 2.  this fuse has no effect when using full speed.
.................... 
....................    #use delay(clock=48000000)
.................... 
....................    //leds are ordered left to right
....................    #define LED1 PIN_C3
....................    #define LED2 PIN_C2
....................    #define LED3 PIN_C1
....................    #define LED4 PIN_C0
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3); LED_OFF(LED4)
....................    #define LED_ON(x) output_high(x)
....................    #define LED_OFF(x) output_low(x)
....................    #define BUTTON_PRESSED() !input(PIN_A3)
.................... 
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL
....................    #define HW_ADC_CHANNEL  10
....................    #define HW_ADC_PORTS    sAN10
.................... #endif
.................... 
.................... #if defined(USB_HW_MCHP_18F46J50)
....................    #include <18F46J50.h>
.................... 
....................    #fuses NOWDT
....................    #fuses NOXINST
....................    #fuses NODEBUG
....................    #fuses NOPROTECT
.................... 
....................    #fuses HSPLL
....................    #fuses PLL3       //set usb pll clock to 4MHz (from 12Mhz input)
....................    #fuses NOCPUDIV   //set cpu clock to 48MHz
....................    #use delay(clock=48MHz)
.................... 
....................    #DEFINE LED1   PIN_E0
....................    #define LED2   PIN_E1
....................    #define LED3   PIN_D7   //requires PIC18 Explorer
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define LED_ON(x) output_high(x)
....................    #define LED_OFF(x) output_low(x)
....................    #define BUTTON_PRESSED() !input(PIN_B2)
.................... 
....................    // pot is on PIC18 Explorer
....................    #define HW_ADC_PORTS    sAN0
....................    #define HW_ADC_CHANNEL  0
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL
.................... 
....................    // uart/rs232 requires PIC18 Explorer
.................... 
....................    //#define PIN_USB_SENSE   PIN_C2    //Jumper JP2 needs to short 'R' to 'U' position for this to be valid.
.................... 
....................    #define HW_INIT() setup_oscillator(OSC_PLL_ON); delay_ms(50)
.................... #endif
.................... 
.................... #if defined(USB_HW_GENERIC_18F67J50)
....................    #include <18F67J50.h>
.................... 
....................    #fuses NOWDT
....................    #fuses NOXINST
.................... 
....................    //8Mhz clock configured for USB operation and 48MHz CPU operation
....................    #fuses HSPLL
....................    #fuses PLL2
....................    #fuses NOCPUDIV
....................    #use delay(clock=48M)
.................... 
....................    #DEFINE LED1   PIN_E4
....................    #define LED2   PIN_E5
....................    #define LED3   PIN_E6
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define BUTTON_PRESSED() FALSE   //no push button on this hardware
.................... 
....................    #define HW_ADC_PORTS    sAN0
....................    #define HW_ADC_CHANNEL  0
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL
.................... 
....................    #define PIN_USB_SENSE   PIN_B2
.................... 
....................    #byte OSCTUNE = 0xF9B
....................    #bit PLLEN=OSCTUNE.6
....................    #define HW_INIT() PLLEN=TRUE; delay_ms(50)
.................... #endif
.................... 
.................... #if defined(USB_HW_GENERIC_18F27J53)
....................    #include <18F27J53.h>
.................... 
....................    #fuses NOWDT
....................    #fuses NOXINST
.................... 
....................    //12Mhz clock configured for USB operation and 48MHz CPU operation
....................    #fuses HSPLL
....................    #fuses PLLEN
....................    #fuses PLL3
....................    #fuses NOCPUDIV
....................    #use delay(clock=48M)
.................... 
....................    #DEFINE LED1   PIN_B5
....................    #define LED2   PIN_B4
....................    #define LED3   PIN_C7
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    #define BUTTON_PRESSED() (!input(PIN_B0))
.................... 
....................    #define PIN_USB_SENSE   PIN_A3
.................... 
....................    #define __NO_UART__
.................... 
....................    #define HW_ADC_PORTS    sAN0|sAN1|sAN2
....................    #define HW_ADC_CHANNEL  0
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL
.................... 
....................    #byte OSCTUNE = 0xF9B
....................    #bit PLLEN=OSCTUNE.6
.................... 
....................    #define HW_INIT() output_low(PIN_C0); output_low(PIN_C1); output_high(PIN_C2); output_high(PIN_B2); PLLEN=TRUE; delay_ms(50)
.................... #endif
.................... 
.................... #if defined(USB_HW_GENERIC_18F67J94)
....................    #include <18F67J94.h>
....................    
....................    #use delay(int=4MHz, clock=64MHz, USB_FULL, act=USB)  //internal oscillator with active clock tuning
....................    #fuses NOIESO             //Internal External Switch Over mode disabled
....................    #fuses NOCKSNOFSM         //Clock Switching is disabled, fail Safe clock monitor is disabled
....................       
....................    #define __NO_UART__
....................    
....................    #define LED1   PIN_G0
....................    #define LED2   PIN_G1
....................    #define LED3   PIN_G2
....................    #define LEDS_OFF()   LED_OFF(LED1); LED_OFF(LED2); LED_OFF(LED3)
....................    
....................    //wait for PLL to get stable
....................    #define HW_INIT() delay_ms(72)
....................    
....................    #define PIN_USB_SENSE   PIN_F7
.................... #endif
.................... 
.................... #if defined(USB_HW_CCS_24FJ64GC006)
....................    #include <24fj64gc006.h>
....................    #device ICSP=2
....................    #device ADC=8
....................    #fuses NOWDT
....................    
....................    //#use delay(crystal=20MHz, clock=32MHz, USB_FULL)   //external 20mhz crystal
....................    #use delay(int=8MHz, clock=32MHz, USB_FULL, act=USB)   //internal oscillator with active clock tuning
.................... 
....................    #pin_select U1TX = PIN_D5
....................    #pin_select U1RX = PIN_D4
.................... 
....................    #pin_select SDI2 = PIN_F5
....................    #pin_select SDO2 = PIN_B15
....................    #pin_select SCK2OUT = PIN_F4
.................... 
....................    // LEDs on PIC24USB development kit, when changed to a GC006, are
....................    // connected to the SVss and CHx pins and thus we can't use the LEDs.
....................    #define LEDS_OFF()
....................    #define LED_ON(x)
....................    #define LED_OFF(x)
....................    
....................    #define BUTTON_PRESSED() !input(PIN_F0)
.................... 
....................    #define HW_ADC_PORTS    sAN0|sAN2   //AN0/PIN_B0=POT, AN2/PIN_B2=VBus
....................    #define HW_ADC_CHANNEL  0
....................    #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31
.................... 
....................    #define LCD_ENABLE_PIN  PIN_D0
....................    #define LCD_RS_PIN      PIN_D1
....................    #define LCD_RW_PIN      PIN_D2
....................    #define LCD_DATA4       PIN_E6
....................    #define LCD_DATA5       PIN_E7
....................    #define LCD_DATA6       PIN_D6
....................    #define LCD_DATA7       PIN_D7
.................... #endif
.................... 
.................... #if defined(USB_HW_CCS_18F4523)
....................    #include <16F1459.h>
.................... 
....................    #use delay(int=8MHz, clock=48MHz, USB_FULL, act=USB)
.................... 
....................    #fuses MCLR
....................    #fuses PUT
....................    #fuses WDT
.................... 
....................    #define LED_ON    output_high
....................    #define LED_OFF   output_low
.................... 
....................    #define LED1 PIN_C7
....................    
....................    #define LEDS_OFF()   LED_OFF(LED1)
.................... 
....................    #define PIN_USB_SENSE   PIN_C2
.................... 
....................    // no user UART.  there is a UART tied to the 18F4523.
....................    #define __NO_UART__
.................... #endif
.................... 
.................... #if defined(__NO_UART__)
....................    #define uart_putc(c)
....................    #define uart_getc()  (0)
....................    #define uart_kbhit() (FALSE)
....................    #define uart_printf(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) { }
....................    #define uart_task()
.................... #else
....................    #ifndef __UART_BAUD__
....................       #define __UART_BAUD__   9600
....................    #endif
....................    #if defined(PIN_UART_TX)
....................       #use rs232(baud=__UART_BAUD__, xmit=PIN_UART_TX, rcv=PIN_UART_RX, errors)
....................    #elif defined(UART_IS_ICD) 
....................       #if defined(UART_ICD_SETTINGS)
....................        #use rs232(icd, UART_ICD_SETTINGS)
....................       #else
....................        #use rs232(icd)  //pgd=tx, pgc=rx
....................       #endif
....................    #else
....................       #use rs232(baud=__UART_BAUD__, UART1, errors)
*
25EC:  BTFSS  F9E.5
25EE:  BRA    25EC
25F0:  MOVFF  FAB,1A
25F4:  MOVFF  FAE,01
25F8:  BTFSS  1A.1
25FA:  BRA    2600
25FC:  BCF    FAB.4
25FE:  BSF    FAB.4
2600:  GOTO   27C8 (RETURN)
*
2706:  BTFSS  F9E.4
2708:  BRA    2706
270A:  MOVWF  FAD
270C:  GOTO   2714 (RETURN)
....................    #endif
.................... 
....................    #define uart_getc    getc
....................    #define uart_kbhit   kbhit
....................    #define uart_printf  printf
....................    
....................    //#define __DO_DEBUG_USB
....................    //void debug_putc(char c);
.................... 
....................    #if defined(UART_USE_TX_BUFFER)
....................       char tbeBuffer[UART_USE_TX_BUFFER];
....................      #if UART_USE_TX_BUFFER>=0x100
....................       unsigned int16 tbeIn=0, tbeOut=0, tbeCount=0;
....................      #else
....................       unsigned int8 tbeIn=0, tbeOut=0, tbeCount=0;
....................      #endif
.................... 
....................       void uart_putc(char c)
....................       {
....................          if (tbeCount < sizeof(tbeBuffer))
....................          {
....................             tbeCount++;
....................             tbeBuffer[tbeIn++] = c;
....................             if (tbeIn >= sizeof(tbeBuffer))
....................                tbeIn = 0;
....................          }
....................       }
.................... 
....................       void uart_task(void)
....................       {
....................          char c;
....................          if (tbeCount)
....................          {
....................             tbeCount--;
....................             c = tbeBuffer[tbeOut++];
....................             if (tbeOut >= sizeof(tbeBuffer))
....................                tbeOut = 0;
....................             putc(c);
....................          }
....................       }
....................    #else
....................       void uart_putc(char c) {putc(c);}
2710:  MOVF   xAC,W
2712:  BRA    2706
2714:  RETURN 0
....................       #define uart_task()
....................    #endif
.................... #endif
.................... 
.................... #ifndef LEDS_OFF
.................... #define LEDS_OFF()
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //
.................... // Required macro: USB_CABLE_IS_ATTACHED()
.................... //
.................... // This macro provides configuration to the library to detect if a
.................... // USB cable is attached or not.  This is only relevant if the PIC is acting
.................... // as a slave device.
.................... //
.................... // If you are using a USB connection sense method or pin, define this
.................... // macro here.  If you are not using connection sense, comment out this line.
.................... // Without connection sense you will not know if the device gets disconnected.
.................... //
.................... // If you are using a PIC24/33 with the internal USB peripheral, you can connect
.................... // the Vbus (5V) line from the USB to the Vbus pin on the PIC - you
.................... // can then look at the SFR bit U1OTGSTAT.SESVD to determine if USB is
.................... // connected.
.................... //
.................... // If you are not using the internal USB peripheral of a PIC24, you can connect
.................... // Vbus to a GPIO to detect connection sense.
.................... //
.................... // For both methods (connecting to Vbus pin or GPIO pin), a pull-down resistor
.................... // (around 150K) and capacitor (1uF) should also be placed on the Vbus pin.
.................... //
.................... /////////////////////////////////////////////////////////////////////////////
.................... #if defined(PIN_USB_SENSE)
....................    #define USB_CABLE_IS_ATTACHED() input(PIN_USB_SENSE)
.................... #elif defined(__PCD__)
....................    #bit U1OTGSTAT_SESVD=getenv("BIT:SESVD")
....................    #define USB_CABLE_IS_ATTACHED() (U1OTGSTAT_SESVD)
.................... #endif
.................... 
.................... #ifndef LED_ON
.................... #define LED_ON(x) output_low(x)
.................... #endif
.................... 
.................... #ifndef LED_OFF
.................... #define LED_OFF(x) output_high(x)
.................... #endif
.................... 
.................... #ifndef HW_INIT
.................... #define HW_INIT()
.................... #endif
.................... 
.................... #ifndef __USB_PIC_PERIF__
.................... #define __USB_PIC_PERIF__  1
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #include <usb_cdc.h>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////                            usb_cdc.h                            ////
.................... ////                                                                 ////
.................... //// Library for adding a virtual COM port on your PC over USB using ////
.................... //// the standard Communication Device Class (CDC) specification.    ////
.................... //// Including this file in your code will add all USB code,         ////
.................... //// interrupts, descriptors and handlers required.  No other        ////
.................... //// modifications need to be made.                                  ////
.................... ////                                                                 ////
.................... //// This library creates a virtual RS232 link between the PC and    ////
.................... //// the PIC, therefore the library provided will be familiar to     ////
.................... //// anyone with standard UART stream I/O:                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          ////
.................... ////      character received and waiting in the receive buffer.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  ////
.................... ////      there is no data in the receive buffer it will wait until  ////
.................... ////      there is data in the receive buffer.  If you do not want   ////
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   ////
.................... ////      check if there is data before calling usb_cdc_getc().      ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       ////
.................... ////      buffer.  If the transmit buffer is full it will wait until ////
.................... ////      the transmit buffer is not full before putting the char    ////
.................... ////      into the transmit buffer.  The transmit buffer is read by  ////
.................... ////      the PC very quickly, and therefore the buffer should only  ////
.................... ////      be full for a few milli-seconds.  If you are concerned     ////
.................... ////      and don't want to be stuck in a long or infinite loop,     ////
.................... ////      use usb_cdc_putready() to see if there is space in the     ////
.................... ////      transmit buffer before putting data into the transmit      ////
.................... ////      buffer.                                                    ////
.................... ////                                                                 ////
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    ////
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'ptr' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    ////
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'len' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putready() - Returns the number of bytes available      ////
.................... ////     in the TX buffer for storing characters.  If this returns   ////
.................... ////     0 then the buffer is full and waiting for the host (PC)     ////
.................... ////     to read the buffer.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   ////
.................... ////     empty and fully flushed/transmitted to host (PC).           ////
.................... ////                                                                 ////
.................... //// usb_cdc_connected() - Returns TRUE if we received a             ////
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   ////
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        ////
.................... ////      message when the program starts and it opens the virtual   ////
.................... ////      COM port.  This is a simple way to determine if the PC     ////
.................... ////      is ready to display data on a serial terminal program,     ////
.................... ////      but is not garaunteed to work all the time or on other     ////
.................... ////      terminal programs.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   ////
.................... ////      if the transmit buffer is full it will skip the char.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  ////
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   ////
.................... ////                                                                 ////
.................... //// usb_cdc_break - If the PC has sent a break command, this will   ////
.................... ////       hold the break time (in milli-seconds).  If the PC sends  ////
.................... ////       a value of 0xFFFF the device is supposed to hold the      ////
.................... ////       break until it sends a value of 0                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. ////
.................... ////       Of most relevance is the field dte_present, which is the  ////
.................... ////       DTR setting.                                              ////
.................... ////                                                                 ////
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          ////
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   ////
.................... ////       ring, break and more.  See the documentation above        ////
.................... ////       usb_cdc_serial_state() for more information, including    ////
.................... ////       format of state structure.                                ////
.................... ////                                                                 ////
.................... //// The following functions are also provided, and are ports of the ////
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   ////
.................... //// documentation:                                                  ////
.................... ////   get_float_usb() - Read a float number from the user           ////
.................... ////   get_long_usb() - Read a long number from the user             ////
.................... ////   get_int_usb() - Read an integer number from the user          ////
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. ////
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             ////
.................... ////   gethex1_usb() - Read a HEX character                          ////
.................... ////                                                                 ////
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  ////
.................... //// be called when there is incoming CDC (virtual com port) data.   ////
.................... //// This is useful if you want to update legacy RS232 code that     ////
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    ////
.................... //// However, see the INTERRUPT LIMITATIONS section below.           ////
.................... ////                                                                 ////
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    ////
.................... ////  to flush the data as soon as possible.  However at times       ////
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   ////
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         ////
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     ////
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       ////
.................... ////  also attempt to flush the packet on each call to usb_task().   ////
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     ////
.................... ////  if you have a main loop that periodically calls usb_task().    ////
.................... ////                                                                 ////
.................... //// This driver will load all the rest of the USB code, and a set   ////
.................... //// of descriptors that will properly describe a CDC device for a   ////
.................... //// virtual COM port (usb_desc_cdc.h)                               ////
.................... ////                                                                 ////
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      ////
.................... //// standard CDC drivers for a virtual COM port in Windows          ////
.................... //// NT/2000/XP and above.                                           ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// Encapsuated Messages: (USB_CDC_USE_ENCAPSULATED)                ////
.................... //// -------------------------------------------------------------   ////
.................... ////                                                                 ////
.................... //// If USB_CDC_USE_ENCAPSULATED is defined, then the user must      ////
.................... //// provide the following callbacks in their application to provide ////
.................... //// encapsuated message support (SendEncapsulatedCommand and        ////
.................... ////  GetEncapsulatedResponse):                                      ////
.................... ////                                                                 ////
.................... //// usb_cdc_SendEncapsulatedCommand(byte *ptr, unsigned int16 num)  ////
.................... ////     PIC receives encapsulated command from host (PC), 'num'     ////
.................... ////     bytes of message stored in 'ptr'.                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_GetEncapsulatedResponse(byte *ptr, unsigned int16 num)  ////
.................... ////     Host (PC) is asking for 'num' bytes response from the PIC,  ////
.................... ////     PIC should store up to 'num' bytes to 'ptr' as the          ////
.................... ////     response.                                                   ////
.................... ////                                                                 ////
.................... //// Due to the design of the USB stack, all encapsulated messages   ////
.................... //// must be smaller than one endpoint 0 packet.  They cannot be     ////
.................... //// equal in size or larger than the endpoint 0 size.  See          ////
.................... //// USB_MAX_EP0_PACKET_LENGTH.                                      ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// BUFFER SIZES                                                    ////
.................... //// -------------------------------------------------------------   ////
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     ////
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        ////
.................... ////  Full speed devices limit this value to be 64.  To increase     ////
.................... ////  the size of the local PIC buffer you can also define           ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        ////
.................... ////  defined then the total PIC->PC buffer size would be            ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  ////
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      ////
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      ////
.................... ////  then this option isn't used.                                   ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// INTERRUPT LIMITATIONS                                           ////
.................... //// -------------------------------------------------------------   ////
.................... //// This section is only relevant if you are using USB interrupts   ////
.................... ////  and not the USB_ISR_POLLING option.                            ////
.................... ////                                                                 ////
.................... //// USB handling is complex, often requiring several packet         ////
.................... ////  transmissions to accomplish transfer of one block of data.     ////
.................... ////  Most of this processing is done in the USB ISR.  Because       ////
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the ////
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   ////
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  ////
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  ////
.................... ////  overflow the TX buffer than data will be lost.                 ////
.................... ////                                                                 ////
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB ////
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      ////
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           ////
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    ////
.................... ////                                                                 ////
.................... //// ex_usb_serial3.c shows an example of working around these       ////
.................... ////  ISR limitations.  Failure to follow these limitations can      ////
.................... ////  cause the PIC to lockup.  These limtations only need to be     ////
.................... ////  followed in the conditions listed above (writing code in the   ////
.................... ////  ISR or interrupts are disabled).                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// VERSION HISTORY                                                 ////
.................... ////                                                                 ////
.................... //// Nov 20th, 2014:                                                 ////
.................... ////  While usb_cdc_putc() waits for local buffer to be free, also   ////
.................... ////     check the endpoint buffer in case there was a situation     ////
.................... ////     that the ISR for this event was missed.                     ////
.................... ////                                                                 ////
.................... //// Dec 16th, 2013:                                                 ////
.................... ////  Added encapsulated message support.  See                       ////
.................... ////     USB_CDC_USE_ENCAPSULATED above for documentation.           ////
.................... ////                                                                 ////
.................... //// May 31st, 2013:                                                 ////
.................... ////  usb_cdc_putready() now returns the number of bytes available.  ////
.................... ////                                                                 ////
.................... //// May 23rd, 2013:                                                 ////
.................... ////  Added usb_cdc_putd().                                          ////
.................... ////                                                                 ////
.................... //// February 18th, 2013:                                            ////
.................... ////  Enhanced PIC16 support added.                                  ////
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 ////
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    ////
.................... ////                                                                 ////
.................... //// September 13th, 2012:                                           ////
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     ////
.................... ////     (PIC24, dsPIC33).                                           ////
.................... ////  Added usb_cdc_putempty().                                      ////
.................... ////                                                                 ////
.................... //// December 16th, 2011:                                            ////
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will ////
.................... ////     only include the get string helper functions.  This is      ////
.................... ////     a rarely used option, used only if you already wrote your   ////
.................... ////     own getc() and putc() routines.                             ////
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  ////
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      ////
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  ////
.................... ////                                                                 ////
.................... //// Oct 27th, 2011:                                                 ////
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    ////
.................... ////     documentation.  In order for this to work,                  ////
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   ////
.................... ////                                                                 ////
.................... //// Jan 28, 2010:                                                   ////
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    ////
.................... ////     one packet.                                                 ////
.................... ////                                                                 ////
.................... //// Jan 25, 2010:                                                   ////
.................... ////  Ignore incoming 0 length packets.                              ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// April 7th, 2009:                                                ////
.................... ////   Vista 'code 10' issues resolved.                              ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 26th, 2007:                                                 ////
.................... ////              usb_cdc_put_buffer_free() should be more stable.   ////
.................... ////              Fixed a hang-up that would happen if you sent      ////
.................... ////                 exactly 64 bytes.                               ////
.................... ////                                                                 ////
.................... //// Nov 6th, 2007:                                                  ////
.................... ////              Compatabible with latest pic18_usb.h, which        ////
.................... ////                 reduces RAM footprint of USB driver.            ////
.................... ////              This driver now fits on 18F4450/2450 PICs.         ////
.................... ////                                                                 ////
.................... //// October 27th, 2005: Changed the way incoming packets are        ////
.................... ////               handled in that CDC driver will not flush         ////
.................... ////               endpoint until user has handled all data.  This   ////
.................... ////               will prevent overflows as the USB will NAK        ////
.................... ////               incoming packets until it is ready to receive     ////
.................... ////               more.                                             ////
.................... ////            When using 18F4550 family, the RX buffer is          ////
.................... ////               mapped directly to the endpoint buffer - this     ////
.................... ////               saves a chunk of RAM.                             ////
.................... ////            When using the 18F4550 family, you can increase      ////
.................... ////               the TX and RX size over 64 bytes.                 ////
.................... ////            No longer send 0len packets in the TBE interrupt.    ////
.................... ////            Hopefully fixed bugs that caused random crashes      ////
.................... ////               if you tried sending more than 64 bytes.          ////
.................... ////                                                                 ////
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   ////
.................... ////                   buffer.                                       ////
.................... ////                                                                 ////
.................... //// July 1st, 2005: Initial Release.                                ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... //input.c ported to use CDC:
.................... float get_float_usb();
.................... signed long get_long_usb();
.................... signed int get_int_usb();
.................... void get_string_usb(char* s, unsigned int max);
.................... char gethex_usb();
.................... char gethex1_usb();
.................... 
.................... #if !defined(__USB_CDC_HELPERS_ONLY__)
.................... 
.................... //api for the user:
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got)
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free())
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin)
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding)
.................... void usb_cdc_putc_fast(char c);
.................... char usb_cdc_getc(void);
.................... void usb_cdc_putc(char c);
.................... void usb_cdc_get_discard(void);
.................... 
.................... //functions automatically called by USB handler code
.................... void usb_isr_tkn_cdc(void);
.................... void usb_cdc_init(void);
.................... void usb_isr_tok_out_cdc_control_dne(void);
.................... void usb_isr_tok_in_cdc_data_dne(void);
.................... void usb_isr_tok_out_cdc_data_dne(void);
.................... 
.................... void usb_cdc_flush_tx_buffer(void);
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //
.................... // Include the CCS USB Libraries.  See the comments at the top of these
.................... // files for more information
.................... //
.................... /////////////////////////////////////////////////////////////////////////////
.................... #ifndef __USB_PIC_PERIF__
.................... #define __USB_PIC_PERIF__   1
.................... #endif
.................... 
.................... #if __USB_PIC_PERIF__
....................    #if defined(__PCM__)
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c
....................    #elif defined(__PCH__)
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.h                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  This hardware layer      ////
.................... //// supports the USB peripheral on the PIC18 family chips.  Current ////
.................... //// supported families are:                                         ////
.................... ////     PIC18F2455/2550/4455/4550                                   ////
.................... ////     PIC18F2450/4450                                             ////
.................... ////     PIC18F2458/2553/4458/4553                                   ////
.................... ////     PIC18F13K50/14K50                                           ////
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     ////
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       ////
.................... ////     PIC18FxxK50                                                 ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      ////
.................... //// that are specific to only this HW peripheral that you may       ////
.................... //// find useful to use in your application.                         ////
.................... ////                                                                 ////
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    ////
.................... ////  Due to the limited USB RAM of this family, a limitation of     ////
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   ////
.................... ////  The HW actually supports more endpoints, but to simplify       ////
.................... ////  driver development this driver will only support the first 3   ////
.................... ////  so there is an easier memory block to work with.               ////
.................... ////                                                                 ////
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     ////
.................... ////  of USB speed, to save RAM.                                     ////
.................... ////                                                                 ////
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    ////
.................... ////  If you are not using internal pullups, you will need to put    ////
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    ////
.................... ////  want to use slow speed or full speed.  This code configures    ////
.................... ////  the device to use internal pullups, see usb_init() if you      ////
.................... ////  want to change that.                                           ////
.................... ////                                                                 ////
.................... ////  You need approximately 470nF cap on Vusb, even if you are      ////
.................... ////  using the internal 3.3V USB regulator.                         ////
.................... ////                                                                 ////
.................... ////  To run at full speed, you must use the oscillator              ////
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   ////
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     ////
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      ////
.................... ////  96MHz clock.  See the datasheet for details.                   ////
.................... ////                                                                 ////
.................... ////  To run at slow speed you must configure your MCU to run at     ////
.................... ////  24Mhz.  See the datasheet for details.                         ////
.................... ////                                                                 ////
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   ////
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the ////
.................... //// PIC when an event has happened on the USB Bus.  Therfore        ////
.................... //// this code enables interrupts.  A user modification can be made  ////
.................... //// to poll the USB interrupt flag instead of relying on an         ////
.................... //// interrupt.                                                      ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_H__
.................... #DEFINE __PIC18_USB_H__
.................... 
.................... #DEFINE __USB_HARDWARE__
.................... 
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral
.................... #DEFINE __PIC__   1
.................... 
.................... #ifndef USB_USE_FULL_SPEED
....................  #define USB_USE_FULL_SPEED   1
.................... #endif
.................... 
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................    //due to limited ram, force max packet length to 8 for this chip
....................    #define USB_MAX_EP0_PACKET_LENGTH   8
.................... #else
....................    #if USB_USE_FULL_SPEED==0
....................       //slow speed requires 8byte max packet size for endpoint 0
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8
....................    #else
....................       //for full speed you can still use 8bytes, but 64 will be faster
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64
....................    #endif
.................... #endif
.................... #endif
.................... 
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8))
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8
....................  #error Max Endpoint 0 length can't be less than 8!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64
....................  #error Max Endpoint 0 length can't be greater than 64!
.................... #endif
.................... 
.................... #include <usb_hw_layer.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_hw_layer.h                            ////
.................... ////                                                                   ////
.................... //// HW Layer for the USB Stack.                                       ////
.................... ////                                                                   ////
.................... //// HW drivers for the USB stack must support this API.               ////
.................... ////                                                                   ////
.................... //// The HW driver must also have a token handler that will call       ////
.................... //// usb_token_reset() when the device is init/reset, will call        ////
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          ////
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    ////
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     ////
.................... //// See usb.h for documentation of these functions.                   ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __USB_HW_LAYER_H__
.................... #define __USB_HW_LAYER_H__
.................... 
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0,
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4};
.................... 
.................... 
.................... // USER LEVEL FUNCTIONS:
.................... 
.................... /*****************************************************************************
.................... /* usb_init()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_init_cs()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_cs(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_task()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_task(void);
.................... 
.................... /******************************************************************************
.................... /* usb_attach()
.................... /*
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral.
.................... /*
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt.
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_attach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_detach()
.................... /*
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB.
.................... /*
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* If the user does call this function while USB is connected, the USB 
.................... /* peripheral will be disabled only momentarily because usb_task() will
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB
.................... /* reset of the device.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_detach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_put_packet()
.................... /*
.................... /* Input: endpoint - endpoint to send packet to (0..15).
.................... /*        ptr - points to data to send.
.................... /*        len - amount of data to send.
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, 
.................... /*                 or toggle from the last DATAx pid.
.................... /*
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only 
.................... /*         reason it will return FALSE is if because the TX buffer is still full 
.................... /*         from the last time it tried to send a packet.
.................... /*
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a 
.................... /*          difference between a packet and a message.  If you wanted to send a 
.................... /*          512 byte message on an endpoint that only supported 64 byte packets,
.................... /*          this would be accomplished this by sending 8 64-byte packets, 
.................... /*          followed by a 0 length packet.  If the last (or only packet) being 
.................... /*          sent is less than the max packet size defined in your descriptor 
.................... /*          then you do not need to send a 0 length packet to identify
.................... /*          an end of message.
.................... /*
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message 
.................... /*          correctly and know if a 0 lenght packet needs to be sent.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl);
.................... 
.................... /*******************************************************************************
.................... /* usb_get_packet(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer and saved to ptr.
.................... /*
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS!
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()!
.................... /*
.................... /* Summary: Gets a packet of data from the USB endpoint buffer.
.................... /*          Until this is called, if there is data in the receive buffer the
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be
.................... /*          allowed to send a new packet.  Only receives one packet, if you need 
.................... /*          to receive multiple packets or handle 0-length terminator packets,
.................... /*          then use usb_gets().
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /********************************************************************************/
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max);
.................... 
.................... /****************************************************************************
.................... /* usb_kbhit(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check (0..15)
.................... /*
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not.
.................... /*
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers.
.................... /*          See API section of USB.H for more information.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_kbhit(unsigned int8 en);
.................... 
.................... /******************************************************************************
.................... /* usb_tbe(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last
.................... /*         transmit or if this endpoint is invalid.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_tbe(unsigned int8 en);
.................... 
.................... //////////////// END USER LEVEL FUNCTIONS /////////////////////////////////////
.................... 
.................... 
.................... ///
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by
.................... ///            the USB stack, and are not meant to be called by the 
.................... ///            user/application.
.................... ///
.................... 
.................... /*****************************************************************************
.................... /* usb_stall_ep()
.................... /*
.................... /* Input: endpoint - endpoint to stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will
.................... /*          send STALL packet if the host tries to access this endpoint's 
.................... /*          buffer.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_stall_ep(unsigned int8 endpoint);
.................... 
.................... 
.................... /*****************************************************************************
.................... /* usb_unstall_ep(endpoint, direction)
.................... /*
.................... /* Input: endpoint - endpoint to un-stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Un-stalls endpoint.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_unstall_ep(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_endpoint_stalled()
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not.
.................... /*
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to
.................... /*          see if endpoint has been issued a STALL, just whether or not it is
.................... /*          configured to STALL on the next packet.  See Set_Feature and 
.................... /*          Clear_Feature Chapter 9 requests.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_set_address(address)
.................... /*
.................... /* Input: address - address the host specified that we use
.................... /*
.................... /* Summary: Configures the USB Peripheral for the specified device address.  
.................... /*          The host will now talk to use with the following address.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_address(unsigned int8 address);
.................... 
.................... /******************************************************************************
.................... /* usb_set_configured()
.................... /*
.................... /* Input: config - Configuration to use.  0 to uncofigure device.
.................... /*
.................... /* Summary: Configures or unconfigures device.  If configuring device it will
.................... /*          enable all the endpoints the user specified for this configuration.
.................... /*          If un-configuring device it will disable all endpoints.
.................... /*
.................... /*          NOTE: CCS only provides code to handle 1 configuration.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_configured(unsigned int8 config);
.................... 
.................... /******************************************************************************
.................... /* usb_disable_endpoints()
.................... /*
.................... /* Summary: Disables endpoints (all endpoints but 0)
.................... /*
.................... /*****************************************************************************/
.................... void usb_disable_endpoints(void);
.................... 
.................... 
.................... /*******************************************************************************
.................... /* usb_disable_endpoint()
.................... /*
.................... /* Input: Endpoint to disable (0..15)
.................... /*
.................... /* Summary: Disables specified endpoint
.................... /*
.................... /********************************************************************************/
.................... void usb_disable_endpoint(unsigned int8 en);
.................... 
.................... /**************************************************************
.................... /* usb_request_send_response(len)
.................... /* usb_request_get_data()
.................... /* usb_request_stall()
.................... /*
.................... /* Input: len - size of packet to send
.................... /*
.................... /* Summary: One of these 3 functions will be called by the USB stack after
.................... /*          handling a SETUP packet.
.................... /*          
.................... /*          After we process a SETUP request, we have 1 of three responses:
.................... /*            1.) send a response IN packet
.................... /*            2.) wait for followup OUT packet(s) with data
.................... /*            3.) stall because we don't support that SETUP request
.................... /*
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold
.................... /*          the response and the USB Request handler code will call
.................... /*          usb_request_send_response() to let us know how big the packet is.
.................... /*
.................... /*          If we are waiting for more data, usb_request_get_data() will
.................... /*          be called by the USB request handler code to configure the EP0 OUT
.................... /*          endpoint to be ready for more data
.................... /*
.................... /*          If we don't support a request, usb_request_stall() will be called
.................... /*          by the USB request handler code to stall the endpoint 0.
.................... /*
.................... /*          The operation of these functions depends on how SETUP packets
.................... /*          are handled in the hardware layer.
.................... /*
.................... /***************************************************************/
.................... void usb_request_send_response(unsigned int8 len);
.................... void usb_request_get_data(void);
.................... void usb_request_stall(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... //////////////////////// EXTRA USER FUNCTIONS /////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_flush_in()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for transfer
.................... /*        len - length of data that is being tramsferred
.................... /*        tgl - Data toggle synchronization for this packet
.................... /*
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint)
.................... /*
.................... /* Summary: Marks the endpoint ready for transmission.  You must
.................... /*          have already loaded the endpoint buffer with data.
.................... /*          (IN is PIC -> PC).
.................... /*          This routine is useful if you want to setup an endpoint by
.................... /*          writing to the buffer directly.
.................... /*          This routine is not necessary if you use usb_put_packet().
.................... /***************************************************************/
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_flush_out()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for release
.................... /*        tgl - Data toggle synchronization to expect in the next packet
.................... /*
.................... /* Output: NONE
.................... /*
.................... /* Summary: Clears the previously received packet, and then marks this
.................... /*          endpoint's receive buffer as ready for more data.
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not
.................... /*          want to use usb_get_packet(), instead you want to handle with
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size().
.................... /*          This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_rx_packet_size()
.................... /*
.................... /* Input: endpoint - which endpoint to mark to check
.................... /*
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer.
.................... /*
.................... /* Summary: Read the number of data stored in the receive buffer.  When you
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint.
.................... /*    This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... int16 usb_rx_packet_size(int8 endpoint);
.................... 
.................... #ENDIF
.................... 
....................    #else
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
....................    #endif
.................... #else
....................    #include <usbn960x.h>
.................... #endif
.................... #ifndef __USB_DESCRIPTORS__
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_desc_cdc.h                            ////
.................... ////                                                                   ////
.................... //// An example set of device / configuration descriptors for use with ////
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// Oct 27th, 2011:                                                   ////
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     ////
.................... ////     send SERIAL_STATE messages in one packet.                     ////
.................... ////                                                                   ////
.................... //// April 7th, 2009:                                                  ////
.................... ////   Vista 'code 10' issues resolved.                                ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// 10/28/05:                                                         ////
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        ////
.................... ////    packets.                                                       ////
.................... ////    Changed device to USB 1.10                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
.................... #DEFINE __USB_DESCRIPTORS__
.................... 
.................... ///////// config options, although it's best to leave alone for this demo /////
.................... #ifndef  USB_CONFIG_PID
....................    #define  USB_CONFIG_PID       0x000b
.................... #endif
.................... #ifndef  USB_CONFIG_VID
....................    #define  USB_CONFIG_VID       0x2405
.................... #endif
.................... #ifndef  USB_CONFIG_BUS_POWER
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500)
.................... #endif
.................... #ifndef  USB_CONFIG_VERSION
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99
.................... #endif
.................... //////// end config ///////////////////////////////////////////////////////////
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #DEFINE USB_HID_DEVICE  false
.................... #DEFINE USB_CDC_DEVICE  true
.................... 
.................... #define USB_CDC_COMM_IN_ENDPOINT       1
.................... #ifndef USB_CDC_COMM_IN_SIZE
.................... #define USB_CDC_COMM_IN_SIZE           11
.................... #endif
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE
.................... 
.................... //pic to pc endpoint config
.................... #define USB_CDC_DATA_IN_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_IN_SIZE
.................... #define USB_CDC_DATA_IN_SIZE           64
.................... #endif
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE
.................... 
.................... //pc to pic endpoint config
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_OUT_SIZE
.................... #define USB_CDC_DATA_OUT_SIZE           64
.................... #endif
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start config descriptor
.................... ///   right now we only support one configuration descriptor.
.................... ///   the config, interface, class, and endpoint goes into this array.
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints)
.................... 
....................    const char USB_CONFIG_DESC[] = {
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE:
....................       //    config(s)
....................       //    interface(s)
....................       //    class(es)
....................       //    endpoint(s)
.................... 
....................    //config_descriptor for config index 1
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3
....................          2, //number of interfaces this device supports       ==4
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5
....................          0x00, //index of string descriptor for this configuration      ==6
....................         #if USB_CONFIG_BUS_POWER
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #else
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #endif
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8
.................... 
.................... 
....................    //interface descriptor 0 (comm class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11
....................          0x00, //alternate setting     ==12
....................          1, //number of endpoints   ==13
....................          0x02, //class code, 02 = Comm Interface Class     ==14
....................          0x02, //subclass code, 2 = Abstract     ==15
....................          0x01, //protocol code, 1 = v.25ter      ==16
....................          0x00, //index of string descriptor for interface      ==17
.................... 
....................    //class descriptor [functional header]
....................          5, //length of descriptor    ==18
....................          0x24, //dscriptor type (0x24 == )      ==19
....................          0, //sub type (0=functional header) ==20
....................          0x10,0x01, //      ==21,22 //cdc version
.................... 
....................    //class descriptor [acm header]
....................          4, //length of descriptor    ==23
....................          0x24, //dscriptor type (0x24 == )      ==24
....................          2, //sub type (2=ACM)   ==25
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State.
.................... 
....................    //class descriptor [union header]
....................          5, //length of descriptor    ==27
....................          0x24, //dscriptor type (0x24 == )      ==28
....................          6, //sub type (6=union)    ==29
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union.
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. *
.................... 
....................    //class descriptor [call mgmt header]
....................          5, //length of descriptor    ==32
....................          0x24, //dscriptor type (0x24 == )      ==33
....................          1, //sub type (1=call mgmt)   ==34
....................          0, //capabilities          ==35  //device does not handle call management itself
....................          1, //data interface        ==36  //interface number of data class interface
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43
.................... 
....................    //interface descriptor 1 (data class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46
....................          0x00, //alternate setting     ==47
....................          2, //number of endpoints   ==48
....................          0x0A, //class code, 0A = Data Interface Class     ==49
....................          0x00, //subclass code      ==50
....................          0x00, //protocol code      ==51
....................          0x00, //index of string descriptor for interface      ==52
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55
....................          0x02, //transfer type supported (0x02 is bulk)         ==56
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58
....................          1,  //polling interval, in ms.   ==59
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62
....................          0x02, //transfer type supported (0x02 is bulk)         ==63
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67
....................          1  //polling interval, in ms.   ==68
....................    };
.................... 
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ********
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find
....................    //  a specific descriptor in the above table.
.................... 
....................    //the maximum number of interfaces seen on any config
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2
....................    #define USB_MAX_NUM_INTERFACES   2
.................... 
....................    //define how many interfaces there are per config.  [0] is the first config, etc.
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2};
.................... 
....................    //define where to find class descriptors
....................    //first dimension is the config number
....................    //second dimension specifies which interface
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface
....................    //if a class descriptor is not valid, set the value to 0xFFFF
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]=
....................    {
....................    //config 1
....................       //interface 0
....................          //class 1-4
....................          18,23,27,32,
....................       //interface 1
....................          //no classes for this interface
....................          0xFF,0xFF,0xFF,0xFF
....................    };
.................... 
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN)
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly
....................    #endif
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start device descriptors
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={
....................       //starts of with device configuration. only one possible
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1
....................          0x10,0x01, //usb version in bcd  ==2,3
....................          0x02, //class code. 0x02=Communication Device Class ==4
....................          0x00, //subclass code ==5
....................          0x00, //protocol code ==6
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14
....................          0x02, //index of string descriptor of the product  ==15
....................          0x00, //index of string descriptor of serial number  ==16
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17
....................    };
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start string descriptors
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone.
.................... ///
.................... ///   You must define the length else get_next_string_character() will not see the string
.................... ///   Current code only supports 10 strings (0 thru 9)
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
.................... #if !defined(USB_STRINGS_OVERWRITTEN)
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored.
.................... // Strings are saved as unicode.
.................... // These strings are mostly only displayed during the add hardware wizard.
.................... // Once the operating system drivers have been installed it will usually display
.................... // the name from the drivers .INF.
.................... char const USB_STRING_DESC[]={
....................    //string 0
....................          4, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          0x09,0x04,   //Microsoft Defined for US-English
....................    //string 1  - manufacturer
....................          8, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................    //string 2 - product
....................          32, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................          ' ',0,
....................          'U',0,
....................          'S',0,
....................          'B',0,
....................          ' ',0,
....................          't',0,
....................          'o',0,
....................          ' ',0,
....................          'U',0,
....................          'A',0,
....................          'R',0,
....................          'T',0
.................... };
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN)
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... struct {
....................    int1 got;
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100
....................    unsigned int16 len;
....................    unsigned int16 index;
....................   #else
....................    unsigned int8 len;
....................    unsigned int8 index;
....................   #endif
.................... } usb_cdc_get_buffer_status;
.................... 
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             usb.c                                 ////
.................... ////                                                                   ////
.................... //// Standard USB request and token handler code.                      ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... //// The majority of this code is called and used by the interrupt     ////
.................... //// generated by the hardware level, and therefore it is not meant    ////
.................... //// to be called by the user.  The functions that are meant to be     ////
.................... //// called by the user (init, put packet, get packet, etc) are        ////
.................... //// documented in USB.H.                                              ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////    This code will not create a multiple configuration device.     ////
.................... ////    If you wish to create a multiple configuration device then you ////
.................... ////    will have to modify these drivers.                             ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    ////
.................... ////   requests.  These requests are optional.  If you want to support ////
.................... ////   these requests you must provide the code yourself.  See         ////
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      ////
.................... ////   support.                                                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// If you wish to provide your own USB peripheral hardware layer, it ////
.................... //// must must provide the API as described in usb_hw_layer.h.         ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 20, 2015                                                    ////
.................... ////     USB_STRING_DESC_OFFSET no longer used.                        ////
.................... ////                                                                   ////
.................... //// Feb 6th, 2015                                                     ////
.................... ////     Fixed 'len' not being intiailized in usb_gets()               ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// June 8th, 2011:                                                   ////
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  ////
.................... ////     (for no timeout) resolved.                                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// November 13th, 2009:                                              ////
.................... ////  usb_endpoint_is_valid() has an extra check.                      ////
.................... ////                                                                   ////
.................... //// June 9th, 2009:                                                   ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// Dec 14, 2007:                                                     ////
.................... ////  usb_kbhit() moved to device driver.                              ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    ////
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release.                                         ////
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     ////
.................... ////    layer.                                                         ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////  TODO: alot of indexing and length handling for descriptors is    ////
.................... ////   only 8bit, so make sure all descriptor tables are less than     ////
.................... ////   256 bytes long.                                                 ////
.................... ////                                                                   ////
.................... //// Apr 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     ////
.................... ////   usb_ep_tx_size[] defined in usb.h                               ////
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             ////
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  ////
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     ////
.................... ////   the endpoint buffer until you usb_get_packet(), which will      ////
.................... ////   then free the endpoint buffer for more data.  This affects      ////
.................... ////   routines such as usb_gets() and usb_kbhit().                    ////
.................... ////  usb_gets() no longer reads buffered data (see above note),       ////
.................... ////   now it reads multiple packets in the same way usb_puts()        ////
.................... ////   writes multiple packets                                         ////
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  ////
.................... ////   layer.                                                          ////
.................... ////                                                                   ////
.................... //// Nov 11th, 2004:                                                   ////
.................... ////  No longer includes wrong descriptor header.                      ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   ////
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    ////
.................... ////                     although it didn't cause any serious problems ////
.................... ////                                                                   ////
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  ////
.................... ////                     problems with multiple packet messages        ////
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   ////
.................... ////                     descriptors that require a 0 len packet to    ////
.................... ////                     end message.                                  ////
.................... ////                                                                   ////
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DRIVER__
.................... #DEFINE __USB_DRIVER__
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #else
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) 
....................    {
....................       while(len--)
....................       {
....................          debug_usb_packet(debug_putc, "%02X", *ptr++);
....................       }
....................    }
.................... #endif
.................... 
.................... // legacy
.................... #ifndef debug_usb
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l)
.................... #endif
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #if defined(__PIC16F_USB_H__)
....................  #include <pic16f_usb.c>
.................... #endif
.................... 
.................... #if defined(__PIC18_USB_H__)
....................  #include <pic18_usb.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.c                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     ////
.................... //// documentation about the PIC18 hardware layer.                   ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Dec 12, 2016:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Mar 20, 2015:                                                   ////
.................... ////  When TXing a packet, set UOWN bit as a different instruction   ////
.................... ////     as the rest of the BDSTAT flags.  Doing it this way         ////
.................... ////     prevents PIC18F45K50 family USB from locking up.            ////
.................... ////                                                                 ////
.................... //// Mar 1, 2015:                                                    ////
.................... ////  Added __STALL_ON_UEP_ERRATA__ and __UIDLE_JAM_ERRATA__ from    ////
.................... ////     PIC24 USB library, in case those erratas found              ////
.................... ////     their way on the PIC18 USB parts.                           ////
.................... ////                                                                 ////
.................... //// Dec 17, 2013:                                                   ////
.................... ////  Added 18FxxJ9x family support.                                 ////
.................... ////                                                                 ////
.................... //// Dec 11, 2013:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// July 9th, 2012:                                                 ////
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     ////
.................... ////     for non-setup packets on endpoint 0 or all other            ////
.................... ////     endpoints.  This really only affects people using           ////
.................... ////     usb_put_packet() or usb_get_packet() inside of other        ////
.................... ////     interrupts.                                                 ////
.................... ////                                                                 ////
.................... //// Sep 22, 2011:                                                   ////
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   ////
.................... ////     primarily developed for users developing code where         ////
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Added initial 18F47J53 family support.                         ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work.                          ////
.................... ////                                                                 ////
.................... //// Nov 13th, 2009:                                                 ////
.................... ////  usb_disable_endpoint() won't touch BD status registers for     ////
.................... ////     endpoints that aren't allocated.                            ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_C__
.................... #DEFINE __PIC18_USB_C__
.................... 
.................... // i got these from PIC24 library, but maybe these bugs made their way
.................... // into PIC18 usb peripherals.
.................... // __STALL_ON_UEP_ERRATA__ looked wrong on the PIC24 library.
.................... #define __STALL_ON_UEP_ERRATA__
.................... #define __UIDLE_JAM_ERRATA__
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #endif
.................... 
.................... #bit USBIE=getenv("BIT:USBIE")
.................... 
.................... //if you are worried that the PIC is not receiving packets because a bug in the
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on
.................... //receiving.
.................... #ifndef USB_IGNORE_RX_DTS
....................  #define USB_IGNORE_RX_DTS false
.................... #endif
.................... 
.................... #ifndef USB_IGNORE_TX_DTS
....................  #define USB_IGNORE_TX_DTS false
.................... #endif
.................... 
.................... // if only USB_BDT_START is defined, then BDT has a fixed location in RAM
.................... //    but endpoint memory can be anywhere on the PIC.
.................... // if only USB_RAM_START is defined, then both BDT and endpoint have a fixed
.................... //    location in RAM (BDT first, endpoint second).
.................... // if USB_BDT_START and USB_RAM_START are both defined, then BDT has a fixed
.................... //    location in RAM and the endpoint buffers have a different location
.................... //    in RAM.
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50"))
....................  #define __USB_87J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \
....................        (getenv("DEVICE")=="PIC18F24K50") || \
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF24K50"))
....................  #define __USB_45K50__
....................  #define USB_TOTAL_RAM_SPACE  1024
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50"))
....................  #define __USB_46J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || \
....................        (getenv("DEVICE")=="PIC18LF2450") || (getenv("DEVICE")=="PIC18LF4450"))
....................  #define __USB_4450__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................  #define __USB_K50__ //backwards compatability
....................  #define __USB_14K50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x200
....................  #define USB_NUM_UEP 8
....................  //technically this device supports 8 endpoints, but for RAM reasons you should
....................  //attempt to only use the first 3 endpoints.
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") || \
....................        (getenv("DEVICE")=="PIC18LF2455") || (getenv("DEVICE")=="PIC18LF2550") || \
....................        (getenv("DEVICE")=="PIC18LF4455") || (getenv("DEVICE")=="PIC18LF4550") || \
....................        (getenv("DEVICE")=="PIC18LF2458") || (getenv("DEVICE")=="PIC18LF2553") || \
....................        (getenv("DEVICE")=="PIC18LF4458") || (getenv("DEVICE")=="PIC18LF4553") \
....................        )
....................  #define __USB_4550__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") || \
....................        (getenv("DEVICE")=="PIC18LF26J53") || (getenv("DEVICE")=="PIC18LF27J53") || \ 
....................        (getenv("DEVICE")=="PIC18LF46J53") || (getenv("DEVICE")=="PIC18LF47J53") \       
....................        )
....................  #define __USB_18FJ53__
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use
....................  #define USB_BDT_START  0xD00
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F97J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F87J94") ||  \
....................        (getenv("DEVICE")=="PIC18F67J94") ||  \
....................        (getenv("DEVICE")=="PIC18F96J99") ||  \
....................        (getenv("DEVICE")=="PIC18F86J99") ||  \
....................        (getenv("DEVICE")=="PIC18F66J99") ||  \
....................        (getenv("DEVICE")=="PIC18F96J94") ||  \
....................        (getenv("DEVICE")=="PIC18F86J94") ||  \
....................        (getenv("DEVICE")=="PIC18F66J94") ||  \
....................        (getenv("DEVICE")=="PIC18F95J94") ||  \
....................        (getenv("DEVICE")=="PIC18F85J94") ||  \
....................        (getenv("DEVICE")=="PIC18F65J94"))
....................  #define __USB_18FJ94__
....................  #define USB_BDT_START  0x100
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library.
.................... #endif
.................... 
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  15
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  14
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  13
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  12
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  11
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  10
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  9
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  8
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  7
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  6
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  5
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  4
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  3
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  2
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  1
.................... #else
....................  #define USB_LAST_DEFINED_ENDPOINT  0
.................... #endif
.................... 
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8)
.................... 
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE)
.................... 
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT)
....................  #error You are trying to use an invalid endpoint for this hardware!
.................... #endif
.................... 
.................... typedef struct
.................... {
....................    unsigned int8 stat;
....................    unsigned int8 cnt;
....................    unsigned int16 addr;
.................... } STRUCT_BD;
.................... 
.................... #if defined(USB_RAM_START) && !defined(USB_BDT_START)
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       struct
....................       {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................       } bd[USB_LAST_DEFINED_ENDPOINT+1];
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM.buffer)
....................    
....................    #locate g_USBRAM=USB_RAM_START
....................    
....................    #define g_USBBDT g_USBRAM.bd
.................... #else
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #if defined(USB_RAM_START)
....................       #locate g_USBRAM=USB_RAM_START
....................    #endif
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM)
....................    
....................    struct
....................    {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................    } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1];
....................    
....................    #locate g_USBBDT=USB_BDT_START
.................... #endif
.................... 
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer
.................... 
.................... //these buffer definitions needed for CDC library
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer
.................... 
.................... //if you enable this it will keep a counter of the 6 possible errors the
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time.
.................... #if !defined(USB_USE_ERROR_COUNTER)
....................    #define USB_USE_ERROR_COUNTER false
.................... #endif
.................... 
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints
.................... 
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS!
.................... #if !defined(USB_PING_PONG_MODE)
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF
.................... #endif
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................    unsigned int ERROR_COUNTER[6];
.................... #endif
.................... 
.................... //---pic18fxx5x memory locations
.................... #if defined(__USB_4550__) || defined(__USB_4450__)
....................    #byte UFRML   =  0xF66
....................    #byte UFRMH   =  0xF67
....................    #byte UIR     =  0xF68
....................    #byte UIE     =  0xF69
....................    #byte UEIR    =  0xF6A
....................    #byte UEIE    =  0xF6B
....................    #byte U1STAT   =  0xF6C
....................    #byte UCON    =  0xF6D
....................    #byte UADDR   =  0xF6E
....................    #byte UCFG    =  0xF6F
....................    #define  UEP0_LOC 0xF70
.................... #elif defined(__USB_46J50__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #elif defined(__USB_14K50__)
....................    #byte UFRML   =  0xF5D
....................    #byte UFRMH   =  0xF5E
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF60
....................    #byte UEIR    =  0xF5F
....................    #byte UEIE    =  0xF5B
....................    #byte U1STAT   =  0xF63
....................    #byte UCON    =  0xF64
....................    #byte UADDR   =  0xF5C
....................    #byte UCFG    =  0xF61
....................    #define  UEP0_LOC 0xF53
.................... #elif defined(__USB_18FJ53__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #else
....................    #byte UFRML = getenv("SFR:UFRML")
....................    #byte UFRMH = getenv("SFR:UFRMH")
....................    #byte UIR = getenv("SFR:UIR")
....................    #byte UIE = getenv("SFR:UIE")
....................    #byte UEIR = getenv("SFR:UEIR")
....................    #byte UEIE = getenv("SFR:UEIE")
....................    #byte U1STAT = getenv("SFR:USTAT")
....................    #byte UCON = getenv("SFR:UCON")
....................    #byte UADDR = getenv("SFR:UADDR")
....................    #byte UCFG = getenv("SFR:UCFG")
.................... #endif
.................... 
.................... unsigned int8 USTATCopy;
.................... 
.................... unsigned int8 g_UEP[USB_NUM_UEP];
.................... #if defined(UEP0_LOC)
.................... #locate g_UEP=UEP0_LOC
.................... #else
.................... #locate g_UEP=getenv("SFR:UEP0")
.................... #endif
.................... #define UEP(x) g_UEP[x]
.................... 
.................... #define BIT_SOF   6
.................... #define BIT_STALL 5
.................... #define BIT_IDLE  4
.................... #define BIT_TRN   3
.................... #define BIT_ACTV  2
.................... #define BIT_UERR  1
.................... #define BIT_URST  0
.................... 
.................... #BIT UIR_SOF = UIR.BIT_SOF
.................... #BIT UIR_STALL = UIR.BIT_STALL
.................... #BIT UIR_IDLE = UIR.BIT_IDLE
.................... #BIT UIR_TRN = UIR.BIT_TRN
.................... #BIT UIR_ACTV = UIR.BIT_ACTV
.................... #BIT UIR_UERR = UIR.BIT_UERR
.................... #BIT UIR_URST = UIR.BIT_URST
.................... 
.................... #BIT UIE_SOF = UIE.BIT_SOF
.................... #BIT UIE_STALL = UIE.BIT_STALL
.................... #BIT UIE_IDLE = UIE.BIT_IDLE
.................... #BIT UIE_TRN = UIE.BIT_TRN
.................... #BIT UIE_ACTV = UIE.BIT_ACTV
.................... #BIT UIE_UERR = UIE.BIT_UERR
.................... #BIT UIE_URST = UIE.BIT_URST
.................... 
.................... #if getenv("BIT_VALID:PPBRST")
....................    #bit UCON_PPBRST = getenv("BIT:PPBRST")
.................... #endif
.................... #bit UCON_SE0=UCON.5
.................... #bit UCON_PKTDIS=UCON.4
.................... #bit UCON_USBEN=UCON.3
.................... #bit UCON_RESUME=UCON.2
.................... #bit UCON_SUSPND=UCON.1
.................... 
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF)
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr
.................... #else
.................... #error Right now this driver only supports no ping pong
.................... #endif
.................... 
.................... //See UEPn (0xF70-0xF7F)
.................... #define ENDPT_DISABLED   0x00   //endpoint not used
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions
.................... 
.................... //Define the states that the USB interface can be in
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3,
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state;
.................... 
.................... //--BDendST has their PIDs upshifed 2
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction
.................... 
.................... #define USTAT_IN_E0        4
.................... #define USTAT_OUT_SETUP_E0 0
.................... 
.................... #define __USB_UIF_RESET    0x01
.................... #define __USB_UIF_ERROR    0x02
.................... #define __USB_UIF_ACTIVE   0x04
.................... #define __USB_UIF_TOKEN    0x08
.................... #define __USB_UIF_IDLE     0x10
.................... #define __USB_UIF_STALL    0x20
.................... #define __USB_UIF_SOF      0x40
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET
.................... #else
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET
.................... #endif
.................... 
.................... #define __USB_UCFG_UTEYE   0x80
.................... #if defined(__USB_4550__)
....................  #define __USB_UCFG_UOEMON  0x40
.................... #endif
.................... #define __USB_UCFG_UPUEN   0x10
.................... #if !defined(__USB_14K50__)
....................  #define __USB_UCFG_UTRDIS  0x08
.................... #endif
.................... #define __USB_UCFG_FSEN    0x04
.................... 
.................... #if defined(USB_EXTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  0
.................... #endif
.................... 
.................... #if defined(USB_INTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if !defined(__USB_UCFG_MY_UPUEN)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if USB_USE_FULL_SPEED
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE)
.................... #else
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE);
.................... #endif
.................... 
.................... #if defined(__USB_UCFG_UTRDIS)
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS
.................... #else
....................  #define __UCFG_VAL_DISABLED__   0
.................... #endif
.................... 
.................... 
.................... unsigned int8 __setup_0_tx_size;
.................... 
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only
.................... void usb_handle_interrupt();
.................... void usb_isr_rst();
.................... void usb_isr_uerr();
.................... void usb_isr_sof(void);
.................... void usb_isr_activity();
.................... void usb_isr_uidle();
.................... void usb_isr_tok_dne();
.................... void usb_isr_stall(void);
.................... void usb_init_ep0_setup(void);
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... void usb_isr(void);
.................... #endif
.................... 
.................... //// BEGIN User Functions:
.................... 
.................... // see usb_hw_layer.h for more documentation
.................... int1 usb_kbhit(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7)));
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_tbe(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7)));
*
1B60:  CLRF   03
1B62:  MOVF   xD4,W
1B64:  ADDLW  70
1B66:  MOVWF  FE9
1B68:  MOVLW  0F
1B6A:  ADDWFC 03,W
1B6C:  MOVWF  FEA
1B6E:  MOVF   FEF,F
1B70:  BZ    1BA4
1B72:  CLRF   xD6
1B74:  MOVFF  D4,D5
1B78:  CLRF   xD8
1B7A:  MOVLW  08
1B7C:  MOVWF  xD7
1B7E:  CALL   12D2
1B82:  MOVFF  02,D6
1B86:  MOVFF  01,D5
1B8A:  MOVLW  04
1B8C:  ADDWF  xD5,F
1B8E:  MOVLW  00
1B90:  ADDWFC xD6,F
1B92:  MOVFF  D5,FE9
1B96:  MOVLW  04
1B98:  ADDWF  xD6,W
1B9A:  MOVWF  FEA
1B9C:  MOVFF  FEF,D7
1BA0:  BTFSS  xD7.7
1BA2:  BRA    1BA8
1BA4:  MOVLW  00
1BA6:  BRA    1BAA
1BA8:  MOVLW  01
1BAA:  MOVWF  01
1BAC:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_detach(void)
.................... {
....................    UCON_SUSPND = 0;
*
21CE:  BCF    F6D.1
....................    UCON = 0;  //disable USB hardware
21D0:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts
21D2:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__;
21D4:  MOVLW  08
21D6:  MOVWF  F6F
.................... 
....................    // set D+/D- to inputs
....................   #if defined(__USB_87J50__)
....................    set_tris_f(get_tris_f() | 0x18);
....................   #elif defined(__USB_14K50__)
....................    set_tris_a(get_tris_a() | 0x3);
....................   #elif defined(__USB_18FJ94__)
....................    output_float(PIN_F4);
....................    output_float(PIN_F3);
....................   #elif !defined(USB_PIC_NO_USB_GPIO)
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5
21D8:  MOVF   F94,W
21DA:  IORLW  30
21DC:  MOVWF  F94
....................   #endif
....................   
....................    usb_state = USB_STATE_DETACHED;
21DE:  CLRF   23
21E0:  CLRF   19
21E2:  BTFSC  FF2.7
21E4:  BSF    19.7
21E6:  BCF    FF2.7
....................    
....................    usb_token_reset();              //clear the chapter9 stack
21E8:  CALL   13A2
21EC:  BTFSC  19.7
21EE:  BSF    FF2.7
21F0:  GOTO   21F6 (RETURN)
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_attach(void) 
*
2410:  CLRF   19
2412:  BTFSC  FF2.7
2414:  BSF    19.7
2416:  BCF    FF2.7
.................... {
....................    usb_token_reset();
2418:  CALL   13A2
241C:  BTFSC  19.7
241E:  BSF    FF2.7
....................    UCON_SUSPND = 0;
2420:  BCF    F6D.1
....................    UCON = 0;
2422:  CLRF   F6D
....................   #if getenv("BIT_VALID:PPBRST")
....................    UCON_PPBRST = 1;
2424:  BSF    F6D.6
....................    delay_cycles(5);
2426:  BRA    2428
2428:  BRA    242A
242A:  NOP   
....................    UCON_PPBRST = 0;
242C:  BCF    F6D.6
....................   #endif
....................    UCFG = __UCFG_VAL_ENABLED__;
242E:  MOVLW  14
2430:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts
2432:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus
2434:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h
2436:  MOVLW  01
2438:  MOVWF  23
243A:  GOTO   2444 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init_cs(void)
.................... {
....................    usb_detach();
*
21F4:  BRA    21CE
21F6:  GOTO   278C (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_task(void) 
.................... {
....................   #if defined(USB_ISR_POLLING)
....................    if (interrupt_active(INT_USB))
....................    {
....................       usb_isr();
....................    }
....................   #endif
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_enumerated())
....................    {
....................       usb_cdc_flush_tx_buffer();
....................    }
....................   #endif
.................... 
....................    if (usb_attached()) 
....................    {
....................       if (UCON_USBEN==0) 
*
243E:  BTFSC  F6D.3
2440:  BRA    2444
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: ATTACH");
....................          usb_attach();
2442:  BRA    2410
....................       }
....................    }
....................    else 
....................    {
....................       if (UCON_USBEN==1)  
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: DE-ATTACH");
....................          usb_detach();
....................       }
....................    }
.................... 
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) 
2444:  DECFSZ 23,W
2446:  BRA    245E
2448:  BTFSC  F6D.5
244A:  BRA    245E
....................    {
....................       UIR = 0;
244C:  CLRF   F68
....................       UIE = 0;
244E:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING)
....................       enable_interrupts(INT_USB);
2450:  BSF    FA0.5
....................       enable_interrupts(GLOBAL);
2452:  MOVLW  C0
2454:  IORWF  FF2,F
....................      #endif
....................       UIE = __USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR
2456:  MOVLW  11
2458:  MOVWF  F69
....................      #if USB_USE_ERROR_COUNTER
....................       UIE |= __USB_UIF_ERROR;
....................      #endif
....................       usb_state=USB_STATE_POWERED;
245A:  MOVLW  02
245C:  MOVWF  23
....................       debug_usb_control(debug_putc, "\r\n\nUSB TASK: POWERED");
....................    }
245E:  GOTO   27C0 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init(void) 
.................... {
....................    usb_init_cs();
.................... 
....................    do 
....................    {
....................       usb_task();
....................    } while (usb_state != USB_STATE_POWERED);
.................... }
.................... 
.................... 
.................... // see pic18_usb.h for documentation
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
.................... 
....................    debug_usb_packet(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len);
.................... 
....................    if (usb_tbe(endpoint)) 
*
1BAE:  MOVFF  CF,D4
1BB2:  RCALL  1B60
1BB4:  MOVF   01,F
1BB6:  BTFSC  FD8.2
1BB8:  BRA    1CD8
....................    {
....................       EP_BDxCNT_I(endpoint)=len;
1BBA:  CLRF   xD6
1BBC:  MOVFF  CF,D5
1BC0:  CLRF   xD8
1BC2:  MOVLW  08
1BC4:  MOVWF  xD7
1BC6:  CALL   12D2
1BCA:  MOVFF  02,D5
1BCE:  MOVFF  01,D4
1BD2:  MOVLW  04
1BD4:  ADDWF  xD4,F
1BD6:  MOVLW  00
1BD8:  ADDWFC xD5,F
1BDA:  MOVLW  01
1BDC:  ADDWF  xD4,W
1BDE:  MOVWF  01
1BE0:  MOVLW  00
1BE2:  ADDWFC xD5,W
1BE4:  MOVWF  03
1BE6:  MOVFF  01,FE9
1BEA:  MOVLW  04
1BEC:  ADDWF  03,W
1BEE:  MOVWF  FEA
1BF0:  MOVFF  D0,FEF
.................... 
....................       debug_display_ram(len, EP_BDxADR_I(endpoint));
.................... 
....................      #if USB_IGNORE_TX_DTS
....................       i=0x80;
....................      #else
....................       if (tgl == USB_DTS_TOGGLE) 
1BF4:  MOVF   xD2,W
1BF6:  SUBLW  02
1BF8:  BNZ   1C36
....................       {
....................          i = EP_BDxST_I(endpoint);
1BFA:  CLRF   xD6
1BFC:  MOVFF  CF,D5
1C00:  CLRF   xD8
1C02:  MOVLW  08
1C04:  MOVWF  xD7
1C06:  CALL   12D2
1C0A:  MOVFF  02,D5
1C0E:  MOVFF  01,D4
1C12:  MOVLW  04
1C14:  ADDWF  xD4,F
1C16:  MOVLW  00
1C18:  ADDWFC xD5,F
1C1A:  MOVFF  D4,FE9
1C1E:  MOVLW  04
1C20:  ADDWF  xD5,W
1C22:  MOVWF  FEA
1C24:  MOVFF  FEF,D3
....................          if (bit_test(i,6))
1C28:  BTFSS  xD3.6
1C2A:  BRA    1C30
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
1C2C:  CLRF   xD2
1C2E:  BRA    1C34
....................          else
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
1C30:  MOVLW  01
1C32:  MOVWF  xD2
....................       }
1C34:  BRA    1C66
....................       else if (tgl == USB_DTS_USERX) 
1C36:  MOVF   xD2,W
1C38:  SUBLW  04
1C3A:  BNZ   1C66
....................       {
....................          i = EP_BDxST_O(endpoint);
1C3C:  CLRF   xD6
1C3E:  MOVFF  CF,D5
1C42:  CLRF   xD8
1C44:  MOVLW  08
1C46:  MOVWF  xD7
1C48:  CALL   12D2
1C4C:  MOVFF  01,FE9
1C50:  MOVLW  04
1C52:  ADDWF  02,W
1C54:  MOVWF  FEA
1C56:  MOVFF  FEF,D3
....................          if (bit_test(i,6))
1C5A:  BTFSS  xD3.6
1C5C:  BRA    1C64
....................             tgl = USB_DTS_DATA1;
1C5E:  MOVLW  01
1C60:  MOVWF  xD2
1C62:  BRA    1C66
....................          else
....................             tgl = USB_DTS_DATA0;
1C64:  CLRF   xD2
....................       }
....................       if (tgl == USB_DTS_DATA1) 
1C66:  DECFSZ xD2,W
1C68:  BRA    1C70
....................          i=0x48;  //DATA1, UOWN  //change mar2015
1C6A:  MOVLW  48
1C6C:  MOVWF  xD3
1C6E:  BRA    1C74
....................       else //if (tgl == USB_DTS_DATA0) 
....................          i=0x08; //DATA0, UOWN   //change mar2015
1C70:  MOVLW  08
1C72:  MOVWF  xD3
....................      #endif
.................... 
....................       //set BC8 and BC9
....................       //if (bit_test(len,8)) {bit_set(i,0);}
....................       //if (bit_test(len,9)) {bit_set(i,1);}
.................... 
....................       debug_usb_packet(debug_putc, " %X", i);
.................... 
....................       EP_BDxST_I(endpoint) = i;  //save changes
1C74:  CLRF   xD6
1C76:  MOVFF  CF,D5
1C7A:  CLRF   xD8
1C7C:  MOVLW  08
1C7E:  MOVWF  xD7
1C80:  CALL   12D2
1C84:  MOVFF  02,D5
1C88:  MOVFF  01,D4
1C8C:  MOVLW  04
1C8E:  ADDWF  xD4,F
1C90:  MOVLW  00
1C92:  ADDWFC xD5,F
1C94:  MOVFF  D4,FE9
1C98:  MOVLW  04
1C9A:  ADDWF  xD5,W
1C9C:  MOVWF  FEA
1C9E:  MOVFF  D3,FEF
....................       
....................       EP_BDxST_I(endpoint) |= 0x80; //change mar2015
1CA2:  CLRF   xD6
1CA4:  MOVFF  CF,D5
1CA8:  CLRF   xD8
1CAA:  MOVLW  08
1CAC:  MOVWF  xD7
1CAE:  CALL   12D2
1CB2:  MOVFF  02,D5
1CB6:  MOVFF  01,D4
1CBA:  MOVLW  04
1CBC:  ADDWF  xD4,F
1CBE:  MOVLW  00
1CC0:  ADDWFC xD5,F
1CC2:  MOVFF  D4,FE9
1CC6:  MOVLW  04
1CC8:  ADDWF  xD5,W
1CCA:  MOVWF  FEA
1CCC:  MOVF   FEF,W
1CCE:  IORLW  80
1CD0:  MOVWF  FEF
....................       
....................       //putc('!');
....................       
....................       return(1);
1CD2:  MOVLW  01
1CD4:  MOVWF  01
1CD6:  BRA    1CDC
....................    }
....................    else 
....................    {
....................       //putc('_');
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
....................    return(0);
1CD8:  MOVLW  00
1CDA:  MOVWF  01
1CDC:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 * buff_add;    
.................... 
....................    if (usb_tbe(endpoint)) 
*
1DB0:  MOVFF  C7,D4
1DB4:  RCALL  1B60
1DB6:  MOVF   01,F
1DB8:  BZ    1E40
....................    {
....................       buff_add = EP_BDxADR_I(endpoint);
1DBA:  CLRF   xD6
1DBC:  MOVFF  C7,D5
1DC0:  CLRF   xD8
1DC2:  MOVLW  08
1DC4:  MOVWF  xD7
1DC6:  CALL   12D2
1DCA:  MOVFF  02,D0
1DCE:  MOVFF  01,CF
1DD2:  MOVLW  04
1DD4:  ADDWF  xCF,F
1DD6:  MOVLW  00
1DD8:  ADDWFC xD0,F
1DDA:  MOVLW  02
1DDC:  ADDWF  xCF,W
1DDE:  MOVWF  01
1DE0:  MOVLW  00
1DE2:  ADDWFC xD0,W
1DE4:  MOVWF  03
1DE6:  MOVFF  01,FE9
1DEA:  MOVLW  04
1DEC:  ADDWF  03,W
1DEE:  MOVWF  FEA
1DF0:  MOVFF  FEC,CE
1DF4:  MOVF   FED,F
1DF6:  MOVFF  FEF,CD
....................       memcpy(buff_add, ptr, len);     
1DFA:  MOVFF  CE,FEA
1DFE:  MOVFF  CD,FE9
1E02:  MOVFF  C9,FE2
1E06:  MOVFF  C8,FE1
1E0A:  MOVFF  CB,02
1E0E:  MOVFF  CA,01
1E12:  MOVF   01,F
1E14:  BZ    1E1A
1E16:  INCF   02,F
1E18:  BRA    1E1E
1E1A:  MOVF   02,F
1E1C:  BZ    1E2A
1E1E:  MOVFF  FE6,FEE
1E22:  DECFSZ 01,F
1E24:  BRA    1E1E
1E26:  DECFSZ 02,F
1E28:  BRA    1E1E
....................       
....................       return(usb_flush_in(endpoint, len, tgl));
1E2A:  MOVFF  C7,CF
1E2E:  MOVFF  CB,D1
1E32:  MOVFF  CA,D0
1E36:  MOVFF  CC,D2
1E3A:  RCALL  1BAE
1E3C:  MOVF   01,W
1E3E:  BRA    1E44
....................    }
....................    else 
....................    {
....................       //putc('-');
....................       //printf("%X", EP_BDxST_I(endpoint));
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
.................... 
....................    return(0);
1E40:  MOVLW  00
1E42:  MOVWF  01
1E44:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
....................    unsigned int16 len;
.................... 
....................   #if USB_IGNORE_RX_DTS
....................    if (tgl == USB_DTS_STALL) 
....................    {
....................       debug_usb_token(debug_putc, '*');
....................       EP_BDxCNT_O(endpoint) = 0x84;
....................       EP_BDxST_I(endpoint) = 0x84;
....................       return;
....................    }
....................    else
....................       i=0x80;
....................   #else
....................    i = EP_BDxST_O(endpoint);
*
1A7C:  CLRF   xD6
1A7E:  MOVFF  C7,D5
1A82:  CLRF   xD8
1A84:  MOVLW  08
1A86:  MOVWF  xD7
1A88:  RCALL  12D2
1A8A:  MOVFF  01,FE9
1A8E:  MOVLW  04
1A90:  ADDWF  02,W
1A92:  MOVWF  FEA
1A94:  MOVFF  FEF,C9
....................    if (tgl == USB_DTS_TOGGLE) 
1A98:  MOVF   xC8,W
1A9A:  SUBLW  02
1A9C:  BNZ   1AAA
....................    {
....................       if (bit_test(i,6))
1A9E:  BTFSS  xC9.6
1AA0:  BRA    1AA6
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
1AA2:  CLRF   xC8
1AA4:  BRA    1AAA
....................       else
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
1AA6:  MOVLW  01
1AA8:  MOVWF  xC8
....................    }
....................    if (tgl == USB_DTS_STALL) 
1AAA:  MOVF   xC8,W
1AAC:  SUBLW  03
1AAE:  BNZ   1AE2
....................    {
....................       i = 0x84;
1AB0:  MOVLW  84
1AB2:  MOVWF  xC9
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints
1AB4:  CLRF   xD6
1AB6:  MOVFF  C7,D5
1ABA:  CLRF   xD8
1ABC:  MOVLW  08
1ABE:  MOVWF  xD7
1AC0:  RCALL  12D2
1AC2:  MOVFF  02,CD
1AC6:  MOVFF  01,CC
1ACA:  MOVLW  04
1ACC:  ADDWF  xCC,F
1ACE:  MOVLW  00
1AD0:  ADDWFC xCD,F
1AD2:  MOVFF  CC,FE9
1AD6:  MOVLW  04
1AD8:  ADDWF  xCD,W
1ADA:  MOVWF  FEA
1ADC:  MOVLW  84
1ADE:  MOVWF  FEF
....................    }
1AE0:  BRA    1AF0
....................    else if (tgl == USB_DTS_DATA1)
1AE2:  DECFSZ xC8,W
1AE4:  BRA    1AEC
....................       i = 0xC8;  //DATA1, UOWN
1AE6:  MOVLW  C8
1AE8:  MOVWF  xC9
1AEA:  BRA    1AF0
....................    else //if (tgl == USB_DTS_DATA0) 
....................       i = 0x88; //DATA0, UOWN
1AEC:  MOVLW  88
1AEE:  MOVWF  xC9
....................   #endif
.................... 
....................    //bit_clear(__usb_kbhit_status,endpoint);
.................... 
....................    len = usb_ep_rx_size[endpoint];
1AF0:  BCF    FD8.0
1AF2:  RLCF   xC7,W
1AF4:  CLRF   03
1AF6:  CALL   111E
1AFA:  TBLRD*+
1AFC:  MOVFF  FF5,03
1B00:  MOVWF  xCA
1B02:  MOVFF  03,CB
....................    EP_BDxCNT_O(endpoint) = len;
1B06:  CLRF   xD6
1B08:  MOVFF  C7,D5
1B0C:  CLRF   xD8
1B0E:  MOVLW  08
1B10:  MOVWF  xD7
1B12:  CALL   12D2
1B16:  MOVFF  01,CC
1B1A:  MOVLW  01
1B1C:  ADDWF  01,W
1B1E:  MOVWF  01
1B20:  MOVLW  00
1B22:  ADDWFC 02,W
1B24:  MOVWF  03
1B26:  MOVFF  01,FE9
1B2A:  MOVLW  04
1B2C:  ADDWF  03,W
1B2E:  MOVWF  FEA
1B30:  MOVFF  CA,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);}
1B34:  BTFSS  xCB.0
1B36:  BRA    1B3A
1B38:  BSF    xC9.0
....................    if (bit_test(len,9)) {bit_set(i,1);}
1B3A:  BTFSS  xCB.1
1B3C:  BRA    1B40
1B3E:  BSF    xC9.1
.................... 
....................    EP_BDxST_O(endpoint) = i;
1B40:  CLRF   xD6
1B42:  MOVFF  C7,D5
1B46:  CLRF   xD8
1B48:  MOVLW  08
1B4A:  MOVWF  xD7
1B4C:  CALL   12D2
1B50:  MOVFF  01,FE9
1B54:  MOVLW  04
1B56:  ADDWF  02,W
1B58:  MOVWF  FEA
1B5A:  MOVFF  C9,FEF
1B5E:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint) 
.................... {
....................    return(EP_BDxCNT_O(endpoint));
*
1D1E:  CLRF   xD6
1D20:  MOVFF  C7,D5
1D24:  CLRF   xD8
1D26:  MOVLW  08
1D28:  MOVWF  xD7
1D2A:  CALL   12D2
1D2E:  MOVFF  02,C9
1D32:  MOVFF  01,C8
1D36:  MOVLW  01
1D38:  ADDWF  01,W
1D3A:  MOVWF  01
1D3C:  MOVLW  00
1D3E:  ADDWFC 02,W
1D40:  MOVWF  03
1D42:  MOVFF  01,FE9
1D46:  MOVLW  04
1D48:  ADDWF  03,W
1D4A:  MOVWF  FEA
1D4C:  MOVFF  FEF,01
1D50:  CLRF   02
1D52:  GOTO   1D6C (RETURN)
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN Hardware layer functions required by USB.
.................... 
.................... /*****************************************************************************
.................... /* usb_get_packet_buffer(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer.
.................... /*
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC 
.................... /*          RAM.
.................... /*          Does not mark the endpoint as ready for more data.  Once you are
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready
.................... /*          to receive more data.
.................... /*
.................... /*****************************************************************************/
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) 
.................... {
....................    unsigned int8 * al;
....................    unsigned int8 st;
....................    unsigned int16 i;
.................... 
....................    al = EP_BDxADR_O(endpoint);
....................    i = EP_BDxCNT_O(endpoint);
....................    st = EP_BDxST_O(endpoint);
.................... 
....................    //read BC8 and BC9
....................    if (bit_test(st,0)) {bit_set(i,8);}
....................    if (bit_test(st,1)) {bit_set(i,9);}
.................... 
....................    if (i < max) {max = i;}
....................    
....................    memcpy(ptr, al ,max);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max)
.................... {
....................    max = usb_get_packet_buffer(endpoint, ptr, max);
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_stall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=s%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
1892:  BCF    xC7.0
1894:  BTFSC  xC6.7
1896:  BSF    xC7.0
....................    endpoint &= 0x7F;
1898:  BCF    xC6.7
....................    
....................    if (direction) 
189A:  BTFSS  xC7.0
189C:  BRA    18CC
....................    {
....................       EP_BDxST_I(endpoint) = 0x84;
189E:  CLRF   xD6
18A0:  MOVFF  C6,D5
18A4:  CLRF   xD8
18A6:  MOVLW  08
18A8:  MOVWF  xD7
18AA:  RCALL  12D2
18AC:  MOVFF  02,C9
18B0:  MOVFF  01,C8
18B4:  MOVLW  04
18B6:  ADDWF  xC8,F
18B8:  MOVLW  00
18BA:  ADDWFC xC9,F
18BC:  MOVFF  C8,FE9
18C0:  MOVLW  04
18C2:  ADDWF  xC9,W
18C4:  MOVWF  FEA
18C6:  MOVLW  84
18C8:  MOVWF  FEF
....................    }
18CA:  BRA    18E8
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x84;
18CC:  CLRF   xD6
18CE:  MOVFF  C6,D5
18D2:  CLRF   xD8
18D4:  MOVLW  08
18D6:  MOVWF  xD7
18D8:  RCALL  12D2
18DA:  MOVFF  01,FE9
18DE:  MOVLW  04
18E0:  ADDWF  02,W
18E2:  MOVWF  FEA
18E4:  MOVLW  84
18E6:  MOVWF  FEF
....................    }
18E8:  GOTO   1986 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_unstall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=u%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
1824:  BCF    xC7.0
1826:  BTFSC  xC6.7
1828:  BSF    xC7.0
....................    endpoint &= 0x7F;
182A:  BCF    xC6.7
....................    
....................    if (direction) 
182C:  BTFSS  xC7.0
182E:  BRA    185E
....................    {
....................      #if USB_IGNORE_RX_DTS
....................       EP_BDxST_I(endpoint) = 0x80;
....................      #else
....................       EP_BDxST_I(endpoint) = 0x88;
1830:  CLRF   xD6
1832:  MOVFF  C6,D5
1836:  CLRF   xD8
1838:  MOVLW  08
183A:  MOVWF  xD7
183C:  RCALL  12D2
183E:  MOVFF  02,C9
1842:  MOVFF  01,C8
1846:  MOVLW  04
1848:  ADDWF  xC8,F
184A:  MOVLW  00
184C:  ADDWFC xC9,F
184E:  MOVFF  C8,FE9
1852:  MOVLW  04
1854:  ADDWF  xC9,W
1856:  MOVWF  FEA
1858:  MOVLW  88
185A:  MOVWF  FEF
....................      #endif
....................    }
185C:  BRA    1878
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x00;
185E:  CLRF   xD6
1860:  MOVFF  C6,D5
1864:  CLRF   xD8
1866:  MOVLW  08
1868:  MOVWF  xD7
186A:  RCALL  12D2
186C:  MOVFF  01,FE9
1870:  MOVLW  04
1872:  ADDWF  02,W
1874:  MOVWF  FEA
1876:  CLRF   FEF
....................    }
....................    
....................   #if defined(__STALL_ON_UEP_ERRATA__)
....................    bit_clear(UEP(endpoint), 0);
1878:  CLRF   03
187A:  MOVF   xC6,W
187C:  ADDLW  70
187E:  MOVWF  01
1880:  MOVLW  0F
1882:  ADDWFC 03,F
1884:  MOVFF  01,FE9
1888:  MOVFF  03,FEA
188C:  BCF    FEF.0
....................   #endif
188E:  GOTO   197A (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    unsigned int8 st;
....................    
....................    direction = bit_test(endpoint,7);
*
18EC:  BCF    xC7.0
18EE:  BTFSC  xC6.7
18F0:  BSF    xC7.0
....................    endpoint &= 0x7F;
18F2:  BCF    xC6.7
....................    
....................    if (direction) 
18F4:  BTFSS  xC7.0
18F6:  BRA    1926
....................    {
....................       st=EP_BDxST_I(endpoint);
18F8:  CLRF   xD6
18FA:  MOVFF  C6,D5
18FE:  CLRF   xD8
1900:  MOVLW  08
1902:  MOVWF  xD7
1904:  RCALL  12D2
1906:  MOVFF  02,CA
190A:  MOVFF  01,C9
190E:  MOVLW  04
1910:  ADDWF  xC9,F
1912:  MOVLW  00
1914:  ADDWFC xCA,F
1916:  MOVFF  C9,FE9
191A:  MOVLW  04
191C:  ADDWF  xCA,W
191E:  MOVWF  FEA
1920:  MOVFF  FEF,C8
....................    }
1924:  BRA    1942
....................    else 
....................    {
....................       st=EP_BDxST_O(endpoint);
1926:  CLRF   xD6
1928:  MOVFF  C6,D5
192C:  CLRF   xD8
192E:  MOVLW  08
1930:  MOVWF  xD7
1932:  RCALL  12D2
1934:  MOVFF  01,FE9
1938:  MOVLW  04
193A:  ADDWF  02,W
193C:  MOVWF  FEA
193E:  MOVFF  FEF,C8
....................    }
....................    
....................    return(bit_test(st,7) && bit_test(st,2));
1942:  BTFSS  xC8.7
1944:  BRA    194A
1946:  BTFSC  xC8.2
1948:  BRA    194E
194A:  MOVLW  00
194C:  BRA    1950
194E:  MOVLW  01
1950:  MOVWF  01
1952:  GOTO   199A (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_address(unsigned int8 address) 
.................... {
....................    UADDR = address;
*
1D8C:  MOVFF  C7,F6E
....................    
....................    if (address) 
1D90:  MOVF   xC7,F
1D92:  BZ    1D9A
....................    {
....................       usb_state = USB_STATE_ADDRESS;
1D94:  MOVLW  04
1D96:  MOVWF  23
....................    }
1D98:  BRA    1D9E
....................    else 
....................    {
....................       usb_state = USB_STATE_POWERED;
1D9A:  MOVLW  02
1D9C:  MOVWF  23
....................    }
1D9E:  GOTO   1DAC (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_configured(unsigned int8 config) 
.................... {
....................    unsigned int8 en;
....................    unsigned int16 addy;
....................    unsigned int8 new_uep;
....................    unsigned int16 len;
....................    unsigned int8 i;
....................    
....................    if (config == 0)
*
1548:  MOVF   xC6,F
154A:  BNZ   1554
....................    {
....................       // if config=0 then set addressed state
....................       usb_state = USB_STATE_ADDRESS;
154C:  MOVLW  04
154E:  MOVWF  23
....................       usb_disable_endpoints();
1550:  RCALL  1350
....................    }
1552:  BRA    16EA
....................    else 
....................    {
....................       // else set configed state
....................       usb_state = USB_STATE_CONFIGURED; 
1554:  MOVLW  05
1556:  MOVWF  23
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH);
1558:  MOVLW  04
155A:  MOVWF  xC9
155C:  MOVLW  98
155E:  MOVWF  xC8
....................       for (en=1; en<USB_NUM_UEP; en++) 
1560:  MOVLW  01
1562:  MOVWF  xC7
1564:  MOVF   xC7,W
1566:  SUBLW  0F
1568:  BTFSS  FD8.0
156A:  BRA    16EA
....................       {
....................          // enable and config endpoints based upon user configuration
....................          usb_disable_endpoint(en);
156C:  MOVFF  C7,CF
1570:  RCALL  12F0
....................          new_uep = 0;
1572:  CLRF   xCA
....................          if (usb_ep_rx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
1574:  CLRF   03
1576:  MOVF   xC7,W
1578:  RCALL  10CE
157A:  SUBLW  FF
157C:  BZ    1634
....................          {
....................             new_uep = 0x04;
157E:  MOVLW  04
1580:  MOVWF  xCA
....................             len = usb_ep_rx_size[en];
1582:  BCF    FD8.0
1584:  RLCF   xC7,W
1586:  CLRF   03
1588:  RCALL  111E
158A:  TBLRD*+
158C:  MOVFF  FF5,03
1590:  MOVWF  xCB
1592:  MOVFF  03,CC
....................             EP_BDxCNT_O(en) = len;
1596:  CLRF   xD6
1598:  MOVFF  C7,D5
159C:  CLRF   xD8
159E:  MOVLW  08
15A0:  MOVWF  xD7
15A2:  RCALL  12D2
15A4:  MOVFF  01,CE
15A8:  MOVLW  01
15AA:  ADDWF  01,W
15AC:  MOVWF  01
15AE:  MOVLW  00
15B0:  ADDWFC 02,W
15B2:  MOVWF  03
15B4:  MOVFF  01,FE9
15B8:  MOVLW  04
15BA:  ADDWF  03,W
15BC:  MOVWF  FEA
15BE:  MOVFF  CB,FEF
....................             EP_BDxADR_O(en) = addy;
15C2:  CLRF   xD6
15C4:  MOVFF  C7,D5
15C8:  CLRF   xD8
15CA:  MOVLW  08
15CC:  MOVWF  xD7
15CE:  RCALL  12D2
15D0:  MOVFF  01,CE
15D4:  MOVLW  02
15D6:  ADDWF  01,W
15D8:  MOVWF  01
15DA:  MOVLW  00
15DC:  ADDWFC 02,W
15DE:  MOVWF  03
15E0:  MOVFF  01,FE9
15E4:  MOVLW  04
15E6:  ADDWF  03,W
15E8:  MOVWF  FEA
15EA:  MOVFF  C9,FEC
15EE:  MOVF   FED,F
15F0:  MOVFF  C8,FEF
....................             addy += usb_ep_rx_size[en];
15F4:  BCF    FD8.0
15F6:  RLCF   xC7,W
15F8:  CLRF   03
15FA:  RCALL  111E
15FC:  TBLRD*+
15FE:  MOVFF  FF5,03
1602:  ADDWF  xC8,F
1604:  MOVF   03,W
1606:  ADDWFC xC9,F
....................            #if USB_IGNORE_RX_DTS
....................             i = 0x80;
....................            #else
....................             i = 0x88;
1608:  MOVLW  88
160A:  MOVWF  xCD
....................            #endif
....................             if (bit_test(len,8)) {bit_set(i,0);}
160C:  BTFSS  xCC.0
160E:  BRA    1612
1610:  BSF    xCD.0
....................             if (bit_test(len,9)) {bit_set(i,1);}
1612:  BTFSS  xCC.1
1614:  BRA    1618
1616:  BSF    xCD.1
....................             EP_BDxST_O(en) = i;
1618:  CLRF   xD6
161A:  MOVFF  C7,D5
161E:  CLRF   xD8
1620:  MOVLW  08
1622:  MOVWF  xD7
1624:  RCALL  12D2
1626:  MOVFF  01,FE9
162A:  MOVLW  04
162C:  ADDWF  02,W
162E:  MOVWF  FEA
1630:  MOVFF  CD,FEF
....................          }
....................          if (usb_ep_tx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
1634:  CLRF   03
1636:  MOVF   xC7,W
1638:  RCALL  10AE
163A:  SUBLW  FF
163C:  BZ    16BE
....................          {
....................             new_uep |= 0x02;
163E:  BSF    xCA.1
....................             EP_BDxADR_I(en) = addy;
1640:  CLRF   xD6
1642:  MOVFF  C7,D5
1646:  CLRF   xD8
1648:  MOVLW  08
164A:  MOVWF  xD7
164C:  RCALL  12D2
164E:  MOVFF  02,CF
1652:  MOVFF  01,CE
1656:  MOVLW  04
1658:  ADDWF  xCE,F
165A:  MOVLW  00
165C:  ADDWFC xCF,F
165E:  MOVLW  02
1660:  ADDWF  xCE,W
1662:  MOVWF  01
1664:  MOVLW  00
1666:  ADDWFC xCF,W
1668:  MOVWF  03
166A:  MOVFF  01,FE9
166E:  MOVLW  04
1670:  ADDWF  03,W
1672:  MOVWF  FEA
1674:  MOVFF  C9,FEC
1678:  MOVF   FED,F
167A:  MOVFF  C8,FEF
....................             addy += usb_ep_tx_size[en];
167E:  BCF    FD8.0
1680:  RLCF   xC7,W
1682:  CLRF   03
1684:  RCALL  10EE
1686:  TBLRD*+
1688:  MOVFF  FF5,03
168C:  ADDWF  xC8,F
168E:  MOVF   03,W
1690:  ADDWFC xC9,F
....................             EP_BDxST_I(en) = 0x40;
1692:  CLRF   xD6
1694:  MOVFF  C7,D5
1698:  CLRF   xD8
169A:  MOVLW  08
169C:  MOVWF  xD7
169E:  RCALL  12D2
16A0:  MOVFF  02,CF
16A4:  MOVFF  01,CE
16A8:  MOVLW  04
16AA:  ADDWF  xCE,F
16AC:  MOVLW  00
16AE:  ADDWFC xCF,F
16B0:  MOVFF  CE,FE9
16B4:  MOVLW  04
16B6:  ADDWF  xCF,W
16B8:  MOVWF  FEA
16BA:  MOVLW  40
16BC:  MOVWF  FEF
....................          }
....................          if (new_uep == 0x06) {new_uep = 0x0E;}
16BE:  MOVF   xCA,W
16C0:  SUBLW  06
16C2:  BNZ   16C8
16C4:  MOVLW  0E
16C6:  MOVWF  xCA
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;}
16C8:  CLRF   03
16CA:  MOVF   xC7,W
16CC:  RCALL  10AE
16CE:  SUBLW  01
16D0:  BZ    16D4
16D2:  BSF    xCA.4
....................          
....................          UEP(en) = new_uep;
16D4:  CLRF   03
16D6:  MOVF   xC7,W
16D8:  ADDLW  70
16DA:  MOVWF  FE9
16DC:  MOVLW  0F
16DE:  ADDWFC 03,W
16E0:  MOVWF  FEA
16E2:  MOVFF  CA,FEF
16E6:  INCF   xC7,F
16E8:  BRA    1564
....................       }
....................    }
16EA:  GOTO   1788 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoint(unsigned int8 en) 
.................... {
....................    UEP(en) = ENDPT_DISABLED;
*
12F0:  CLRF   03
12F2:  MOVF   xCF,W
12F4:  ADDLW  70
12F6:  MOVWF  FE9
12F8:  MOVLW  0F
12FA:  ADDWFC 03,W
12FC:  MOVWF  FEA
12FE:  CLRF   FEF
....................    
....................    if (usb_endpoint_is_valid(en))
1300:  MOVFF  CF,D0
1304:  RCALL  1290
1306:  MOVF   01,F
1308:  BZ    134E
....................    {
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary      
130A:  CLRF   xD6
130C:  MOVFF  CF,D5
1310:  CLRF   xD8
1312:  MOVLW  08
1314:  MOVWF  xD7
1316:  RCALL  12D2
1318:  MOVFF  01,FE9
131C:  MOVLW  04
131E:  ADDWF  02,W
1320:  MOVWF  FEA
1322:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary
1324:  CLRF   xD6
1326:  MOVFF  CF,D5
132A:  CLRF   xD8
132C:  MOVLW  08
132E:  MOVWF  xD7
1330:  RCALL  12D2
1332:  MOVFF  02,D1
1336:  MOVFF  01,D0
133A:  MOVLW  04
133C:  ADDWF  xD0,F
133E:  MOVLW  00
1340:  ADDWFC xD1,F
1342:  MOVFF  D0,FE9
1346:  MOVLW  04
1348:  ADDWF  xD1,W
134A:  MOVWF  FEA
134C:  CLRF   FEF
....................    }
134E:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoints(void) 
.................... {
....................    unsigned int8 i;
....................    
....................    for (i=1; i<USB_NUM_UEP; i++)
1350:  MOVLW  01
1352:  MOVWF  xCE
1354:  MOVF   xCE,W
1356:  SUBLW  0F
1358:  BNC   1364
....................       usb_disable_endpoint(i);
135A:  MOVFF  CE,CF
135E:  RCALL  12F0
1360:  INCF   xCE,F
1362:  BRA    1354
1364:  RETURN 0
....................       
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... /// END Hardware layer functions required by USB.C
.................... 
.................... 
.................... /// BEGIN USB Interrupt Service Routine
.................... 
.................... static void usb_clear_trn(void)
.................... {
....................    //UIR_TRN = 0;
....................    //delay_cycles(6);
....................    UIR &= ~(1 << BIT_TRN);
*
13CE:  BCF    F68.3
13D0:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_handle_interrupt()
.................... /*
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished
.................... /*          tokens is the majority of this code, and is handled by usb.c
.................... /*
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt 
.................... /*       method), then you must call this function rapidly.  If there is more 
.................... /*       than 10ms latency the PC may think the USB device is stalled and
.................... /*       disable it.
.................... /*       To switch to a polling method, remove the #int_usb line above this 
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the 
.................... /*       USB interrupt.
.................... /******************************************************************************/
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR)
.................... #int_usb NOCLEAR
.................... #endif
.................... void usb_isr(void)
.................... {
....................    unsigned int8 TRNAttempts;
....................    
....................    clear_interrupt(INT_USB);
*
1F5A:  BCF    FA1.5
....................    
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though
1F5C:  MOVF   23,F
1F5E:  BTFSC  FD8.2
1F60:  BRA    1FC8
....................    if (UIR) 
1F62:  MOVF   F68,F
1F64:  BTFSC  FD8.2
1F66:  BRA    1FC8
....................    {
....................       //debug_usb(debug_putc,"\r\n\n[%X] ",UIR);
.................... 
....................       //activity detected.  (only enable after sleep)
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}
1F68:  BTFSS  F68.2
1F6A:  BRA    1F72
1F6C:  BTFSC  F69.2
1F6E:  GOTO   123E
.................... 
....................       if (UCON_SUSPND) return;
1F72:  BTFSC  F6D.1
1F74:  BRA    1FC8
.................... 
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent
1F76:  BTFSS  F68.5
1F78:  BRA    1F80
1F7A:  BTFSC  F69.5
1F7C:  GOTO   127A
.................... 
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected
1F80:  BTFSS  F68.1
1F82:  BRA    1F8A
1F84:  BTFSC  F69.1
1F86:  GOTO   1288
.................... 
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected
1F8A:  BTFSS  F68.0
1F8C:  BRA    1F94
1F8E:  BTFSC  F69.0
1F90:  GOTO   13D2
.................... 
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep
1F94:  BTFSS  F68.4
1F96:  BRA    1F9E
1F98:  BTFSC  F69.4
1F9A:  GOTO   1402
....................       
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();}
1F9E:  BTFSS  F68.6
1FA0:  BRA    1FA8
1FA2:  BTFSC  F69.6
1FA4:  GOTO   140C
.................... 
....................       TRNAttempts = 0;
1FA8:  CLRF   xC3
....................       do
....................       {
....................          if (UIR_TRN && UIE_TRN) 
1FAA:  BTFSS  F68.3
1FAC:  BRA    1FBE
1FAE:  BTFSS  F69.3
1FB0:  BRA    1FBE
....................          {
....................             USTATCopy = U1STAT;
1FB2:  MOVFF  F6C,22
....................             usb_clear_trn();
1FB6:  CALL   13CE
....................             usb_isr_tok_dne();
1FBA:  BRA    1E90
....................          }
1FBC:  BRA    1FC0
....................          else
....................             break;
1FBE:  BRA    1FC8
....................       } while (TRNAttempts++ < 4);
1FC0:  MOVF   xC3,W
1FC2:  INCF   xC3,F
1FC4:  SUBLW  03
1FC6:  BC    1FAA
.................... 
....................      #if defined(USB_CDC_ISR)
....................       //has to be done here, can't be done until TRN is empty.
....................       if (usb_cdc_kbhit())
....................       {
....................          USB_CDC_ISR();
....................       }
....................      #endif
....................    }
1FC8:  GOTO   1060
.................... }
.................... 
.................... // SOF interrupt not handled.  user must add this depending on application
.................... void usb_isr_sof(void) 
.................... {
....................    //debug_usb(debug_putc, "\r\nSOF");
....................    
....................    //UIR_SOF = 0;
....................    UIR &= ~(1 << BIT_SOF);
*
140C:  BCF    F68.6
140E:  GOTO   1FA8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_rst()
.................... /*
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device
.................... /*          and token handler code to initial state.
.................... /*
.................... /******************************************************************************/
.................... void usb_isr_rst(void) 
.................... {
....................    debug_usb_control(debug_putc,"-R-");
.................... 
....................    UEIE = 0;
*
13D2:  CLRF   F6B
....................    UIE = 0;
13D4:  CLRF   F69
....................    UEIR = 0;
13D6:  CLRF   F6A
....................    UIR = 0;
13D8:  CLRF   F68
.................... 
....................    UADDR = 0;
13DA:  CLRF   F6E
....................    
....................    UEP(0) = ENDPT_DISABLED;
13DC:  CLRF   F70
.................... 
....................    usb_disable_endpoints();
13DE:  RCALL  1350
....................    
....................    usb_token_reset();
13E0:  RCALL  13A2
.................... 
....................    UEP(0) = ENDPT_CONTROL | 0x10;
13E2:  MOVLW  16
13E4:  MOVWF  F70
.................... 
....................    while (UIR_TRN) 
13E6:  BTFSS  F68.3
13E8:  BRA    13EE
....................    {
....................       usb_clear_trn();
13EA:  RCALL  13CE
13EC:  BRA    13E6
....................    }
.................... 
.................... 
....................    UEIE = 0x9F;
13EE:  MOVLW  9F
13F0:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE;
13F2:  MOVLW  3D
13F4:  MOVWF  F69
.................... 
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled
13F6:  BCF    F6D.4
.................... 
....................    usb_init_ep0_setup();
13F8:  RCALL  1250
.................... 
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state
13FA:  MOVLW  03
13FC:  MOVWF  23
13FE:  GOTO   1F94 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_init_ep0_setup()
.................... /*
.................... /* Summary: Configure EP0 to receive setup packets
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_ep0_setup(void) 
.................... {
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH;
*
1250:  MOVLW  40
1252:  MOVLB  4
1254:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION;
1256:  MOVLW  04
1258:  MOVLB  0
125A:  MOVWF  xC5
125C:  MOVLW  18
125E:  MOVFF  C5,403
1262:  MOVFF  FE8,402
....................    #if USB_IGNORE_RX_DTS
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off
....................    #else
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on
1266:  MOVLW  88
1268:  MOVLB  4
126A:  MOVWF  x00
....................    #endif
.................... 
....................     EP_BDxST_I(0) = 0;
126C:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH;
126E:  MOVLW  04
1270:  MOVWF  x07
1272:  MOVLW  58
1274:  MOVWF  x06
1276:  MOVLB  0
1278:  RETURN 0
.................... }
.................... 
.................... /*******************************************************************************
.................... /* usb_isr_uerr()
.................... /*
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter
.................... /*          will incerement.  If having problems check the status of these 8 bytes.
.................... /*
.................... /* NOTE: This code is not enabled by default.
.................... /********************************************************************************/
.................... void usb_isr_uerr(void)
.................... {
....................   #if USB_USE_ERROR_COUNTER
....................    int ints;
....................   #endif
.................... 
....................    debug_usb_control(debug_putc,"-E%X-",UEIR);
.................... 
....................   #if USB_USE_ERROR_COUNTER
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled
.................... 
....................    if ( bit_test(ints,0) ) 
....................    { 
....................       //increment pid_error counter
....................       //debug_usb(debug_putc,"PID ");
....................       ERROR_COUNTER[0]++;
....................    }
.................... 
....................    if ( bit_test(ints,1) ) 
....................    {  
....................       //increment crc5 error counter
....................       //debug_usb(debug_putc,"CRC5 ");
....................       ERROR_COUNTER[1]++;
....................    }
.................... 
....................    if ( bit_test(ints,2) ) 
....................    {
....................       //increment crc16 error counter
....................       //debug_usb(debug_putc,"CRC16 ");
....................       ERROR_COUNTER[2]++;
....................    }
.................... 
....................    if ( bit_test(ints,3) ) 
....................    {  
....................       //increment dfn8 error counter
....................       //debug_usb(debug_putc,"DFN8 ");
....................       ERROR_COUNTER[3]++;
....................    }
.................... 
....................    if ( bit_test(ints,4) ) 
....................    {  
....................       //increment bto error counter
....................       //debug_usb(debug_putc,"BTO ");
....................       ERROR_COUNTER[4]++;
....................    }
.................... 
....................    if ( bit_test(ints,7) ) 
....................    { 
....................       //increment bts error counter
....................       //debug_usb(debug_putc,"BTS ");
....................       ERROR_COUNTER[5]++;
....................    }
....................   #endif
.................... 
....................    UEIR = 0;
*
1288:  CLRF   F6A
....................    
....................    //UIR_UERR = 0;
....................    UIR &= ~(1 << BIT_UERR);
128A:  BCF    F68.1
128C:  GOTO   1F8A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_uidle()
.................... /*
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_uidle(void)
.................... {
....................    debug_usb_control(debug_putc, "-I-");
.................... 
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice)
*
1402:  BSF    F69.2
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
....................    // turn off isr instead of clearing flag
....................    UIE &= ~(unsigned int16)__USB_UIF_IDLE;
1404:  BCF    F69.4
....................   #else
....................    UIR &= ~(1 << BIT_IDLE);
....................   #endif
....................    
....................    UCON_SUSPND = 1; //set suspend. we are now suspended
1406:  BSF    F6D.1
1408:  GOTO   1F9E (RETURN)
.................... }
.................... 
.................... 
.................... /******************************************************************************
.................... /* usb_isr_activity()
.................... /*
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB
.................... /*          peripheral.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_activity(void)
.................... {
....................    debug_usb_control(debug_putc, "-A-");
.................... 
....................    UCON_SUSPND = 0; //turn off low power suspending
*
123E:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling
1240:  BCF    F69.2
....................    
....................    while(UIR_ACTV)
1242:  BTFSS  F68.2
1244:  BRA    124A
....................    {
....................       //UIR_ACTV = 0;
....................       UIR &= ~(1 << BIT_ACTV);
1246:  BCF    F68.2
....................    }
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
1248:  BRA    1242
....................    // now it's safe to clear the flag
....................    UIR &= ~(1 << BIT_IDLE);
124A:  BCF    F68.4
....................   #endif   
124C:  GOTO   1F72 (RETURN)
.................... }
.................... 
.................... /******************************************************************************
.................... /* usb_isr_stall()
.................... /*
.................... /* Summary: Stall handshake detected.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_stall(void) 
.................... {
....................    debug_usb_control(debug_putc, "-S-");
....................    
....................    
....................    if (bit_test(UEP(0),0)) 
*
127A:  BTFSS  F70.0
127C:  BRA    1282
....................    {
....................       usb_init_ep0_setup();
127E:  RCALL  1250
....................       bit_clear(UEP(0), 0);
1280:  BCF    F70.0
....................    }
....................    
....................    //UIR_STALL = 0;
....................    UIR &= ~(1 << BIT_STALL);
1282:  BCF    F68.5
1284:  GOTO   1F80 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;}
*
1412:  MOVFF  C9,24
1416:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;}
*
19B4:  MOVLW  FE
19B6:  MOVWF  24
19B8:  RETURN 0
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;}
*
1418:  SETF   24
141A:  RETURN 0
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_tok_dne()
.................... /*
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral.
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and
.................... /*          handle the request.
.................... /*          If an IN token on EP0 was received, continue transmitting any
.................... /*          unfinished requests that may take more than one packet to transmit
.................... /*          (if necessary).
.................... /*          If an OUT token on any other EP was received, mark that EP as ready
.................... /*          for a usb_get_packet().
.................... /*          Does not handle any IN or OUT tokens on EP0.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_tok_dne(void) 
.................... {
....................    unsigned int8 en;
.................... 
....................    en = USTATCopy>>3;
*
1E90:  RRCF   22,W
1E92:  MOVWF  xC4
1E94:  RRCF   xC4,F
1E96:  RRCF   xC4,F
1E98:  MOVLW  1F
1E9A:  ANDWF  xC4,F
.................... 
....................    debug_usb_control(debug_putc, "-T%X-", USTATCopy);
.................... 
....................    if (USTATCopy == USTAT_OUT_SETUP_E0) 
1E9C:  MOVF   22,F
1E9E:  BNZ   1F22
....................    {
....................       //new out or setup token in the buffer
....................       int8 pidKey;
....................       
....................       //debug_usb(debug_putc,"%X ", EP_BDxST_O(0));
....................       
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID
1EA0:  MOVLB  4
1EA2:  MOVF   x00,W
1EA4:  ANDLW  3C
1EA6:  MOVLB  0
1EA8:  MOVWF  xC5
....................       
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion
1EAA:  MOVLW  43
1EAC:  MOVLB  4
1EAE:  ANDWF  x00,F
....................       
....................       if (pidKey == USB_PIC_PID_SETUP) 
1EB0:  MOVLB  0
1EB2:  MOVF   xC5,W
1EB4:  SUBLW  34
1EB6:  BNZ   1EF4
....................       {
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00)
1EB8:  MOVLB  4
1EBA:  MOVF   x04,W
1EBC:  ANDLW  80
1EBE:  BZ    1EC2
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests)
1EC0:  CLRF   x04
.................... 
....................          //debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0));
....................          //debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer);
.................... 
....................          usb_isr_tok_setup_dne();
1EC2:  MOVLB  0
1EC4:  BRA    1A4A
.................... 
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
1EC6:  BCF    F6D.4
.................... 
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall())
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data())
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response())
....................          if (__setup_0_tx_size == 0xFF)
1EC8:  INCFSZ 24,W
1ECA:  BRA    1ED6
....................             usb_flush_out(0, USB_DTS_STALL);
1ECC:  CLRF   xC7
1ECE:  MOVLW  03
1ED0:  MOVWF  xC8
1ED2:  RCALL  1A7C
1ED4:  BRA    1EF2
....................          else 
....................          {
....................             usb_flush_out(0, USB_DTS_TOGGLE);
1ED6:  CLRF   xC7
1ED8:  MOVLW  02
1EDA:  MOVWF  xC8
1EDC:  RCALL  1A7C
....................             if (__setup_0_tx_size != 0xFE)
1EDE:  MOVF   24,W
1EE0:  SUBLW  FE
1EE2:  BZ    1EF2
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX);
1EE4:  CLRF   xCF
1EE6:  CLRF   xD1
1EE8:  MOVFF  24,D0
1EEC:  MOVLW  04
1EEE:  MOVWF  xD2
1EF0:  RCALL  1BAE
....................          }
....................          //why was this here?
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
....................       }
1EF2:  BRA    1F20
....................       else if (pidKey == USB_PIC_PID_OUT) 
1EF4:  MOVF   xC5,W
1EF6:  SUBLW  04
1EF8:  BNZ   1F20
....................       {
....................          usb_isr_tok_out_dne(0);
1EFA:  CLRF   xC6
1EFC:  RCALL  1D7A
....................          usb_flush_out(0, USB_DTS_TOGGLE);
1EFE:  CLRF   xC7
1F00:  MOVLW  02
1F02:  MOVWF  xC8
1F04:  RCALL  1A7C
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF))
1F06:  MOVF   24,W
1F08:  SUBLW  FE
1F0A:  BZ    1F20
1F0C:  INCFSZ 24,W
1F0E:  BRA    1F12
1F10:  BRA    1F20
....................          {
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len)
1F12:  CLRF   xCF
1F14:  CLRF   xD1
1F16:  MOVFF  24,D0
1F1A:  MOVLW  01
1F1C:  MOVWF  xD2
1F1E:  RCALL  1BAE
....................          }
....................       }
....................       //else
....................       //{
....................       //   debug_usb(debug_putc, "!!! ");
....................       //}
....................    }
1F20:  BRA    1F56
....................    else if (USTATCopy == USTAT_IN_E0) 
1F22:  MOVF   22,W
1F24:  SUBLW  04
1F26:  BNZ   1F44
....................    {   
....................       //pic -> host transfer completed
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion
....................       __setup_0_tx_size = 0xFF;
1F28:  SETF   24
....................       usb_isr_tok_in_dne(0);
1F2A:  CLRF   xC6
1F2C:  RCALL  1E6E
....................       if (__setup_0_tx_size!=0xFF)
1F2E:  INCFSZ 24,W
1F30:  BRA    1F34
1F32:  BRA    1F42
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE);
1F34:  CLRF   xCF
1F36:  CLRF   xD1
1F38:  MOVFF  24,D0
1F3C:  MOVLW  02
1F3E:  MOVWF  xD2
1F40:  RCALL  1BAE
....................       else
....................       {
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................       }  
....................    }
1F42:  BRA    1F56
....................    else 
....................    {
....................       if (!bit_test(USTATCopy, 2)) 
1F44:  BTFSC  22.2
1F46:  BRA    1F50
....................       {
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_out_dne(en);
1F48:  MOVFF  C4,C6
1F4C:  RCALL  1D7A
....................       }
1F4E:  BRA    1F56
....................       else 
....................       {
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_in_dne(en);
1F50:  MOVFF  C4,C6
1F54:  RCALL  1E6E
....................       }
....................    }
1F56:  GOTO   1FBC (RETURN)
.................... }
.................... 
.................... /// END USB Interrupt Service Routine
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... #if defined(__PIC24_USB_H__)
....................  #include <pic24_usb.c>
.................... #endif
.................... 
.................... #if defined(__USBN960X_H__)
....................  #include <usbn960x.c>
.................... #endif
.................... 
.................... 
.................... #IFNDEF __USB_HARDWARE__
....................    #ERROR You must include USB hardware driver.
.................... #ENDIF
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
....................    #ERROR You must include USB descriptors.
.................... #ENDIF
.................... 
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1))
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  64
.................... #else
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  8
.................... #endif
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors
.................... 
.................... #IF USB_HID_BOOT_PROTOCOL
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES];
.................... #ENDIF
.................... 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size);
.................... 
.................... void usb_isr_tkn_setup_StandardEndpoint(void);
.................... void usb_isr_tkn_setup_StandardDevice(void);
.................... void usb_isr_tkn_setup_StandardInterface(void);
.................... #IF USB_HID_DEVICE
....................    void usb_isr_tkn_setup_ClassInterface(void);
.................... #ENDIF
.................... void usb_Get_Descriptor(void);
.................... void usb_copy_desc_seg_to_ep(void);
.................... void usb_finish_set_address(void);
.................... 
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors
.................... 
.................... /// BEGIN User Functions
.................... 
.................... // see usb.h for documentation
.................... int1 usb_enumerated(void)
.................... {
....................    return(USB_stack_status.curr_config);
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_wait_for_enumeration(void) 
.................... {
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();}
.................... }
.................... 
.................... // see USB.H for documentation
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) {
....................    unsigned int16 i=0;
....................    int1 res;
....................    unsigned int16 this_packet_len;
....................    unsigned int16 packet_size;
....................    unsigned int32 timeout_1us;
.................... 
....................    packet_size = usb_ep_tx_size[endpoint];
....................    
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size);
.................... 
....................    //send data packets until timeout or no more packets to send
....................    while (i < len) 
....................    {
....................       timeout_1us = (int32)timeout*1000;
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;}
....................       else {this_packet_len = len-i;}
....................       //putc('*');
....................       do 
....................       {
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets
....................          //putc('.');
....................          if (!res)
....................          {
....................             delay_us(1);
....................             //delay_ms(500);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................       i += packet_size;
....................    }
.................... 
.................... 
....................    //send 0len packet if needed
....................    if (i==len) {
....................       timeout_1us=(int32)timeout*1000;
....................       do {
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message
....................          if (!res) {
....................             delay_us(1);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................    }
.................... 
....................    return(res);
.................... }
.................... 
.................... // see usb.h for documentation
.................... unsigned int16 usb_gets(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max, unsigned int16 timeout) {
....................    unsigned int16 ret=0;
....................    unsigned int16 to;
....................    unsigned int16 len;
....................    unsigned int16 packet_size;
....................    unsigned int16 this_packet_max;
.................... 
....................    packet_size=usb_ep_rx_size[endpoint];
.................... 
....................    do {
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;}
....................       to=0;
....................       do {
....................          len = packet_size;
....................          if (usb_kbhit(endpoint)) {
....................             len=usb_get_packet(endpoint,ptr,this_packet_max);
....................             ptr+=len;
....................             max-=len;
....................             ret+=len;
....................             break;
....................          }
....................          else {
....................             to++;
....................             delay_ms(1);
....................          }
....................       } while (to!=timeout);
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max);
.................... 
....................    return(ret);
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR)
.................... 
.................... // see usb.h for documentation
.................... void usb_token_reset(void) 
.................... {
....................    unsigned int i;
.................... 
....................    usb_getdesc_len = 0;
*
13A2:  CLRF   29
13A4:  CLRF   28
....................    
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++) 
13A6:  CLRF   xC4
13A8:  MOVF   xC4,W
13AA:  SUBLW  01
13AC:  BNC   13C2
....................       USB_Interface[i] = 0;   //reset each interface to default
13AE:  CLRF   03
13B0:  MOVF   xC4,W
13B2:  ADDLW  2A
13B4:  MOVWF  FE9
13B6:  MOVLW  00
13B8:  ADDWFC 03,W
13BA:  MOVWF  FEA
13BC:  CLRF   FEF
.................... 
....................   #IF USB_HID_BOOT_PROTOCOL
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++)
....................       hid_protocol[i] = 1;
....................   #endif
.................... 
....................   #if USB_CDC_DEVICE
13BE:  INCF   xC4,F
13C0:  BRA    13A8
....................    usb_cdc_init();
13C2:  RCALL  1366
....................   #endif
.................... 
....................    USB_stack_status.curr_config = 0;      //unconfigured device
13C4:  CLRF   1C
.................... 
....................    USB_stack_status.status_device = 1;    //previous state.  init at none
13C6:  MOVLW  01
13C8:  MOVWF  1D
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none
13CA:  CLRF   1B
13CC:  RETURN 0
.................... }
.................... 
.................... //send a 0len packet to endpoint 0 (optimization)
.................... //notice that this doesnt return the status
.................... #define usb_put_0len_0() usb_request_send_response(0)
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    direction = bit_test(endpoint,7);
*
1290:  BCF    xD1.0
1292:  BTFSC  xD0.7
1294:  BSF    xD1.0
....................    
....................    endpoint &= 0x7F;
1296:  BCF    xD0.7
....................    
....................    if (endpoint > 16)
1298:  MOVF   xD0,W
129A:  SUBLW  10
129C:  BC    12A4
....................       return(false);
129E:  MOVLW  00
12A0:  MOVWF  01
12A2:  BRA    12D0
....................    
....................    if (direction) { //IN
12A4:  BTFSS  xD1.0
12A6:  BRA    12BE
....................       return(usb_ep_tx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
12A8:  CLRF   03
12AA:  MOVF   xD0,W
12AC:  RCALL  10AE
12AE:  SUBLW  FF
12B0:  BNZ   12B6
12B2:  MOVLW  00
12B4:  BRA    12B8
12B6:  MOVLW  01
12B8:  MOVWF  01
12BA:  BRA    12D0
....................    }
12BC:  BRA    12D0
....................    else {   //OUT
....................       return(usb_ep_rx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
12BE:  CLRF   03
12C0:  MOVF   xD0,W
12C2:  RCALL  10CE
12C4:  SUBLW  FF
12C6:  BNZ   12CC
12C8:  MOVLW  00
12CA:  BRA    12CE
12CC:  MOVLW  01
12CE:  MOVWF  01
....................    }
12D0:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) {
....................    if (endpoint==0) {
*
1E6E:  MOVF   xC6,F
1E70:  BNZ   1E86
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor?
1E72:  DECFSZ 1B,W
1E74:  BRA    1E7C
1E76:  CALL   141C
1E7A:  BRA    1E84
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();}
1E7C:  MOVF   1B,W
1E7E:  SUBLW  02
1E80:  BTFSC  FD8.2
1E82:  BRA    1DA2
....................    }
....................   #if USB_CDC_DEVICE
1E84:  BRA    1E8E
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
1E86:  MOVF   xC6,W
1E88:  SUBLW  02
1E8A:  BNZ   1E8E
....................       usb_isr_tok_in_cdc_data_dne();
1E8C:  BRA    1E68
....................   }
....................   #endif
1E8E:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint)
.................... {
....................    //TODO:
....................    if (endpoint==0) {
*
1D7A:  MOVF   xC6,F
1D7C:  BNZ   1D82
....................      debug_usb(debug_putc,"TOUT 0 ");
....................      #if USB_CDC_DEVICE
....................       usb_isr_tok_out_cdc_control_dne();
1D7E:  BRA    1CDE
....................      //#else   //REMOVED JUN/9/2009
....................      //usb_init_ep0_setup();
....................      #endif
....................    }
....................   #if USB_CDC_DEVICE
1D80:  BRA    1D8A
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
1D82:  MOVF   xC6,W
1D84:  SUBLW  02
1D86:  BNZ   1D8A
....................       usb_isr_tok_out_cdc_data_dne();
1D88:  BRA    1D62
....................    }
....................   #endif
1D8A:  RETURN 0
....................    //else {
....................    //   bit_set(__usb_kbhit_status,endpoint);
....................    //}
.................... }
.................... 
.................... 
.................... //---- process setup message stage -----------//
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_setup_dne(void) 
.................... {
....................    USB_stack_status.dev_req=NONE; // clear the device request..
*
1A4A:  CLRF   1B
.................... 
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) {
1A4C:  MOVLB  4
1A4E:  MOVF   x18,W
1A50:  ANDLW  7F
1A52:  XORLW  00
1A54:  MOVLB  0
1A56:  BZ    1A66
1A58:  XORLW  01
1A5A:  BZ    1A6A
1A5C:  XORLW  03
1A5E:  BZ    1A6E
1A60:  XORLW  23
1A62:  BZ    1A72
1A64:  BRA    1A76
.................... 
....................       case 0x00:  //standard to device
....................          debug_usb_token(debug_putc," d");
....................          usb_isr_tkn_setup_StandardDevice();
1A66:  BRA    16EE
....................          break;
1A68:  BRA    1A78
.................... 
....................       case 0x01:  //standard to interface
....................          debug_usb_token(debug_putc," i");
....................          usb_isr_tkn_setup_StandardInterface();
1A6A:  BRA    1798
....................          break;
1A6C:  BRA    1A78
.................... 
....................       case 0x02:  //standard to endpoint
....................          debug_usb_token(debug_putc," e");
....................          usb_isr_tkn_setup_StandardEndpoint();
1A6E:  BRA    1956
....................          break;
1A70:  BRA    1A78
....................          
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case 0x21:  //class specific request.  the only class this driver supports is HID
....................          debug_usb_token(debug_putc, " class");
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE)
....................          {
....................             usb_isr_tkn_setup_ClassInterface();
....................          }
....................          else
....................          {
....................             usb_isr_tkn_cdc();
....................          }
....................         #elif USB_HID_DEVICE
....................          usb_isr_tkn_setup_ClassInterface();
....................         #else
....................          usb_isr_tkn_cdc();
1A72:  BRA    19BA
....................         #endif
....................          break;
1A74:  BRA    1A78
.................... #endif
.................... 
.................... 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE
.................... 
....................       default:
....................          usb_request_stall();
1A76:  RCALL  1418
....................          break;
....................    }
1A78:  GOTO   1EC6 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardDevice()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Device request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardDevice(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
*
16EE:  MOVLB  4
16F0:  MOVF   x19,W
16F2:  XORLW  00
16F4:  MOVLB  0
16F6:  BZ    1712
16F8:  XORLW  01
16FA:  BZ    1724
16FC:  XORLW  02
16FE:  BZ    173E
1700:  XORLW  06
1702:  BZ    1756
1704:  XORLW  03
1706:  BZ    1764
1708:  XORLW  0E
170A:  BZ    1768
170C:  XORLW  01
170E:  BZ    1774
1710:  BRA    1792
.................... 
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device;
1712:  MOVFF  1D,458
....................             usb_ep0_tx_buffer[1]=0;
1716:  MOVLB  4
1718:  CLRF   x59
....................             usb_request_send_response(2);
171A:  MOVLW  02
171C:  MOVLB  0
171E:  MOVWF  xC9
1720:  RCALL  1412
....................             break;
1722:  BRA    1794
.................... 
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1
....................             if (usb_ep0_rx_buffer[2] == 1) {
1724:  MOVLB  4
1726:  DECFSZ x1A,W
1728:  BRA    1738
....................                debug_usb_token(debug_putc,"CF");
....................                USB_stack_status.status_device &= 1;
172A:  MOVLW  01
172C:  ANDWF  1D,F
....................                usb_put_0len_0();
172E:  MOVLB  0
1730:  CLRF   xC9
1732:  RCALL  1412
....................             }
1734:  BRA    173C
1736:  MOVLB  4
....................             else
....................                usb_request_stall();
1738:  MOVLB  0
173A:  RCALL  1418
....................             break;
173C:  BRA    1794
.................... 
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3
....................             if (usb_ep0_rx_buffer[2] == 1) {
173E:  MOVLB  4
1740:  DECFSZ x1A,W
1742:  BRA    1750
....................                debug_usb_token(debug_putc,"SF");
....................                USB_stack_status.status_device |= 2;
1744:  BSF    1D.1
....................                usb_put_0len_0();
1746:  MOVLB  0
1748:  CLRF   xC9
174A:  RCALL  1412
....................             }
174C:  BRA    1754
174E:  MOVLB  4
....................             else
....................                usb_request_stall();
1750:  MOVLB  0
1752:  RCALL  1418
....................             break;
1754:  BRA    1794
.................... 
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5
....................             debug_usb_token(debug_putc,"SA");
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request
1756:  MOVLW  02
1758:  MOVWF  1B
....................             USB_address_pending=usb_ep0_rx_buffer[2];
175A:  MOVFF  41A,25
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request
....................             usb_set_address(USB_address_pending);
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0
....................             #endif
....................             usb_put_0len_0();
175E:  CLRF   xC9
1760:  RCALL  1412
....................             break;
1762:  BRA    1794
.................... 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6
....................             debug_usb_token(debug_putc,"GD");
....................             usb_Get_Descriptor();
1764:  BRA    1494
....................             break;
1766:  BRA    1794
.................... 
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8
....................             debug_usb_token(debug_putc,"GC");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config;
1768:  MOVFF  1C,458
....................             usb_request_send_response(1);
176C:  MOVLW  01
176E:  MOVWF  xC9
1770:  RCALL  1412
....................             break;
1772:  BRA    1794
.................... 
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) {
1774:  MOVLB  4
1776:  MOVF   x1A,W
1778:  SUBLW  01
177A:  BNC   178E
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2];
177C:  MOVFF  41A,1C
....................                usb_set_configured(usb_ep0_rx_buffer[2]);
1780:  MOVFF  41A,C6
1784:  MOVLB  0
1786:  BRA    1548
....................                debug_usb_token(debug_putc,"SC%U", USB_stack_status.curr_config);               
....................                usb_put_0len_0();
1788:  CLRF   xC9
178A:  RCALL  1412
178C:  MOVLB  4
....................             }
....................             break;
178E:  MOVLB  0
1790:  BRA    1794
.................... 
....................       default:
....................             usb_request_stall();
1792:  RCALL  1418
....................             break;
....................    }
1794:  GOTO   1A78 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Interface request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardInterface(void) {
....................    unsigned int8 curr_config;
.................... 
....................    curr_config=USB_stack_status.curr_config;
1798:  MOVFF  1C,C6
.................... 
....................    switch (usb_ep0_rx_buffer[1]) {
179C:  MOVLB  4
179E:  MOVF   x19,W
17A0:  XORLW  00
17A2:  MOVLB  0
17A4:  BZ    17B0
17A6:  XORLW  0A
17A8:  BZ    17C0
17AA:  XORLW  01
17AC:  BZ    17FA
17AE:  BRA    181E
....................       case USB_STANDARD_REQUEST_GET_STATUS:
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=0;
17B0:  MOVLB  4
17B2:  CLRF   x58
....................             usb_ep0_tx_buffer[1]=0;
17B4:  CLRF   x59
....................             usb_request_send_response(2);
17B6:  MOVLW  02
17B8:  MOVLB  0
17BA:  MOVWF  xC9
17BC:  RCALL  1412
....................             break;
17BE:  BRA    1820
.................... 
....................       case USB_STANDARD_REQUEST_GET_INTERFACE:
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state
17C0:  MOVF   xC6,F
17C2:  BZ    17F6
17C4:  MOVLW  01
17C6:  SUBWF  xC6,W
17C8:  CLRF   03
17CA:  RCALL  11A2
17CC:  MOVWF  01
17CE:  MOVLB  4
17D0:  SUBWF  x1C,W
17D2:  BTFSS  FD8.0
17D4:  BRA    17DA
17D6:  MOVLB  0
17D8:  BRA    17F6
....................                debug_usb_token(debug_putc,"GI");
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte
17DA:  CLRF   03
17DC:  MOVF   x1C,W
17DE:  ADDLW  2A
17E0:  MOVWF  FE9
17E2:  MOVLW  00
17E4:  ADDWFC 03,W
17E6:  MOVWF  FEA
17E8:  MOVFF  FEF,458
....................                usb_request_send_response(1); //send byte back
17EC:  MOVLW  01
17EE:  MOVLB  0
17F0:  MOVWF  xC9
17F2:  RCALL  1412
....................             }
17F4:  BRA    17F8
....................             else
....................                usb_request_stall();
17F6:  RCALL  1418
....................             break;
17F8:  BRA    1820
.................... 
....................       case USB_STANDARD_REQUEST_SET_INTERFACE:
....................             if (curr_config) { //if configured state
17FA:  MOVF   xC6,F
17FC:  BZ    181A
....................                debug_usb_token(debug_putc,"SI");
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
17FE:  CLRF   03
1800:  MOVLB  4
1802:  MOVF   x1C,W
1804:  ADDLW  2A
1806:  MOVWF  FE9
1808:  MOVLW  00
180A:  ADDWFC 03,W
180C:  MOVWF  FEA
180E:  MOVFF  41A,FEF
....................                usb_put_0len_0();
1812:  MOVLB  0
1814:  CLRF   xC9
1816:  RCALL  1412
....................             }
1818:  BRA    181C
....................             else
....................                usb_request_stall();
181A:  RCALL  1418
....................             break;
181C:  BRA    1820
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR:
....................             debug_usb_token(debug_putc,"GDh");
....................             usb_Get_Descriptor();
....................             break;
.................... #endif
.................... 
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE:
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE:
.................... //                let default take care of these, goto wrongstate
....................       default:
....................             usb_request_stall();
181E:  RCALL  1418
....................             break;
....................    }
1820:  GOTO   1A78 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardEndpoint()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardEndpoint(void) {
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) {
*
1956:  MOVFF  41C,D0
195A:  RCALL  1290
195C:  MOVF   01,F
195E:  BZ    19B0
....................       switch(usb_ep0_rx_buffer[1]) {
1960:  MOVLB  4
1962:  MOVF   x19,W
1964:  XORLW  01
1966:  MOVLB  0
1968:  BZ    1974
196A:  XORLW  02
196C:  BZ    1980
196E:  XORLW  03
1970:  BZ    198C
1972:  BRA    19AE
.................... 
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE:
....................                debug_usb_token(debug_putc,"CF");
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]);
1974:  MOVFF  41C,C6
1978:  BRA    1824
....................                usb_put_0len_0();
197A:  CLRF   xC9
197C:  RCALL  1412
....................                break;
197E:  BRA    19B0
.................... 
....................          case USB_STANDARD_REQUEST_SET_FEATURE:
....................                      debug_usb_token(debug_putc,"SF");
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]);
1980:  MOVFF  41C,C6
1984:  BRA    1892
....................                      usb_put_0len_0();
1986:  CLRF   xC9
1988:  RCALL  1412
....................                      break;
198A:  BRA    19B0
.................... 
....................          case USB_STANDARD_REQUEST_GET_STATUS:
....................                debug_usb_token(debug_putc,"GS");
....................                usb_ep0_tx_buffer[0]=0;
198C:  MOVLB  4
198E:  CLRF   x58
....................                usb_ep0_tx_buffer[1]=0;
1990:  CLRF   x59
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) {
1992:  MOVFF  41C,C6
1996:  MOVLB  0
1998:  BRA    18EC
199A:  MOVF   01,F
199C:  BZ    19A6
....................                   usb_ep0_tx_buffer[0]=1;
199E:  MOVLW  01
19A0:  MOVLB  4
19A2:  MOVWF  x58
19A4:  MOVLB  0
....................                }
....................                usb_request_send_response(2);
19A6:  MOVLW  02
19A8:  MOVWF  xC9
19AA:  RCALL  1412
....................                break;
19AC:  BRA    19B0
.................... 
....................          default:
....................             usb_request_stall();
19AE:  RCALL  1418
....................             break;
....................       }
....................    }
19B0:  GOTO   1A78 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_ClassInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /* Only compiled if HID_DEVICE is TRUE
.................... /***************************************************************/
.................... #IF USB_HID_DEVICE
.................... void usb_isr_tkn_setup_ClassInterface(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03
....................             debug_usb_token(debug_putc,"GP");
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]];
....................             usb_request_send_response(1);
....................             break;
....................     #ENDIF
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b
....................             debug_usb_token(debug_putc,"SP");
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
....................             usb_put_0len_0(); //send 0len packet69
....................             break;
....................     #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_SET_IDLE:   //0a
....................          #error TODO: if you want to support SET_IDLE, add code here
....................    #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_GET_IDLE:   //02
....................          #error TODO: if you want to support GET_IDLE, add code here
....................    #ENDIF
.................... 
....................       default:
....................             usb_request_stall();
....................             break;
....................    }
.................... }
.................... #ENDIF
.................... 
.................... /**************************************************************
.................... /* usb_Get_Descriptor()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept
.................... /*
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.),
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have
.................... /*          pointers to constants we must simulate or own by setting up global registers that say
.................... /*          which constant array to deal with, which position to start in this array, and the length.
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne()
.................... /*          which will send the rest of the data.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_Get_Descriptor() {
*
1494:  CLRF   xC6
....................    unsigned int8 i = 0;
....................    usb_getdesc_ptr=0;
1496:  CLRF   27
1498:  CLRF   26
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE;
149A:  CLRF   1E
.................... 
....................    switch(usb_ep0_rx_buffer[3]) {
149C:  MOVLB  4
149E:  MOVF   x1B,W
14A0:  XORLW  01
14A2:  MOVLB  0
14A4:  BZ    14B4
14A6:  XORLW  03
14A8:  BZ    14C0
14AA:  XORLW  01
14AC:  BZ    14C8
14AE:  XORLW  22
14B0:  BZ    14F8
14B2:  BRA    1522
....................       case USB_DESC_DEVICE_TYPE:    //1
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN;
14B4:  CLRF   29
14B6:  MOVLW  12
14B8:  MOVWF  28
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE;
14BA:  MOVLW  03
14BC:  MOVWF  1E
....................             break;
14BE:  BRA    1526
.................... 
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually.
....................       case USB_DESC_CONFIG_TYPE:   //2
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN;
14C0:  CLRF   29
14C2:  MOVLW  43
14C4:  MOVWF  28
....................             break;
14C6:  BRA    1526
.................... 
....................       case USB_DESC_STRING_TYPE: //3
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE;
14C8:  MOVLW  02
14CA:  MOVWF  1E
....................             //usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]];
....................             for(i=0; i<usb_ep0_rx_buffer[2]; i++)
14CC:  CLRF   xC6
14CE:  MOVLB  4
14D0:  MOVF   x1A,W
14D2:  MOVLB  0
14D4:  SUBWF  xC6,W
14D6:  BC    14EA
....................             {
....................                usb_getdesc_ptr += USB_STRING_DESC[usb_getdesc_ptr];
14D8:  MOVFF  27,03
14DC:  MOVF   26,W
14DE:  RCALL  11EE
14E0:  ADDWF  26,F
14E2:  MOVLW  00
14E4:  ADDWFC 27,F
14E6:  INCF   xC6,F
14E8:  BRA    14CE
....................             }
....................             usb_getdesc_len = USB_STRING_DESC[usb_getdesc_ptr];
14EA:  MOVFF  27,03
14EE:  MOVF   26,W
14F0:  RCALL  11EE
14F2:  MOVWF  28
14F4:  CLRF   29
....................             break;
14F6:  BRA    1526
.................... 
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06
....................       // this is needed so host can find out about differences about this
....................       // devices ability to handle full speed verses fast speed.
....................       // since we don't support fast speed then we ignore this.
....................       //      break;
.................... 
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case USB_DESC_CLASS_TYPE:  //0x21
....................             //TODO does this work for multiple interfaces or multiple languages?
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]];
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]];
14F8:  CLRF   03
14FA:  MOVLB  4
14FC:  MOVF   x1A,W
14FE:  MOVLB  0
1500:  RCALL  11B4
1502:  MOVWF  26
1504:  CLRF   27
....................             if (usb_getdesc_ptr!=0xFF) {
1506:  INCFSZ 26,W
1508:  BRA    150E
150A:  MOVF   27,F
150C:  BZ    151E
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr];
150E:  MOVFF  27,03
1512:  MOVF   26,W
1514:  RCALL  114E
1516:  MOVWF  28
1518:  CLRF   29
....................                break;
151A:  BRA    1526
....................             }
151C:  BRA    1522
....................             else {
....................                usb_request_stall();
151E:  RCALL  1418
....................                return;
1520:  BRA    1544
....................             }
.................... #endif
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_DESC_HIDREPORT_TYPE: //0x22
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]];
....................             if (usb_getdesc_ptr !=0xFF) {
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE;
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]];
....................                break;
....................             }
....................             else {
....................                usb_request_stall();
....................                return;
....................             }
.................... #endif
.................... 
....................       default:
....................             usb_request_stall();
1522:  RCALL  1418
....................             return;
1524:  BRA    1544
....................    }
....................    if (usb_ep0_rx_buffer[7]==0) {
1526:  MOVLB  4
1528:  MOVF   x1F,F
152A:  BNZ   153C
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6])
152C:  MOVF   29,F
152E:  BNZ   1536
1530:  MOVF   28,W
1532:  SUBWF  x1E,W
1534:  BC    153C
....................          usb_getdesc_len = usb_ep0_rx_buffer[6];
1536:  CLRF   29
1538:  MOVFF  41E,28
....................    }
....................    USB_stack_status.dev_req=GET_DESCRIPTOR;
153C:  MOVLW  01
153E:  MOVWF  1B
....................    usb_copy_desc_seg_to_ep();
1540:  MOVLB  0
1542:  RCALL  141C
1544:  GOTO   1794 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_finish_set_address()
.................... /*
.................... /* Input: USB_address_pending holds the address we were asked to set to.
.................... /*
.................... /* Summary: Sets the address.
.................... /*
.................... /* This code should only be run on the PIC USB peripheral, and not the
.................... /* National peripheral.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
....................  void usb_finish_set_address() {
....................    debug_usb_token(debug_putc," FSA ");
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0
*
1DA2:  CLRF   1C
.................... 
....................    #ifdef __PIC__
....................    USB_stack_status.dev_req=NONE;  // no request pending
1DA4:  CLRF   1B
....................    usb_set_address(USB_address_pending);
1DA6:  MOVFF  25,C7
1DAA:  BRA    1D8C
....................    #endif
1DAC:  GOTO   1E84 (RETURN)
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... ///
.................... /// The following function retrieve data from constant arrays.  This may
.................... /// look un-optimized, but remember that you can't create a pointer to
.................... /// a constant array.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... void usb_copy_desc_seg_to_ep(void) {
*
141C:  CLRF   xC7
....................    unsigned int i=0;
....................    char c;
....................    
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]);
.................... 
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH))
141E:  MOVF   28,W
1420:  IORWF  29,W
1422:  BZ    147E
1424:  MOVF   xC7,W
1426:  SUBLW  3F
1428:  BNC   147E
....................    {
....................       switch(USB_stack_status.getdesc_type) {
142A:  MOVF   1E,W
142C:  BZ    1438
142E:  XORLW  02
1430:  BZ    1444
1432:  XORLW  01
1434:  BZ    1450
1436:  BRA    145A
....................          case USB_GETDESC_CONFIG_TYPE:
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr];
1438:  MOVFF  27,03
143C:  MOVF   26,W
143E:  RCALL  114E
1440:  MOVWF  xC8
....................             break;
1442:  BRA    145A
.................... 
....................         #IF USB_HID_DEVICE
....................          case USB_GETDESC_HIDREPORT_TYPE:
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr];
....................             break;
....................         #endif
.................... 
....................          case USB_GETDESC_STRING_TYPE:
....................             c=USB_STRING_DESC[usb_getdesc_ptr];
1444:  MOVFF  27,03
1448:  MOVF   26,W
144A:  RCALL  11EE
144C:  MOVWF  xC8
....................             break;
144E:  BRA    145A
.................... 
....................          case USB_GETDESC_DEVICE_TYPE:
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr];
1450:  MOVFF  27,03
1454:  MOVF   26,W
1456:  RCALL  11CC
1458:  MOVWF  xC8
....................             //debug_usb(debug_putc, "-%X- ", c);
....................             break;
....................       }
....................       usb_getdesc_ptr++;
145A:  INCF   26,F
145C:  BTFSC  FD8.2
145E:  INCF   27,F
....................       usb_getdesc_len--;
1460:  MOVF   28,W
1462:  BTFSC  FD8.2
1464:  DECF   29,F
1466:  DECF   28,F
....................       usb_ep0_tx_buffer[i++]=c;
1468:  MOVF   xC7,W
146A:  INCF   xC7,F
146C:  ADDLW  58
146E:  MOVWF  FE9
1470:  MOVLW  04
1472:  MOVWF  FEA
1474:  BTFSC  FD8.0
1476:  INCF   FEA,F
1478:  MOVFF  C8,FEF
147C:  BRA    141E
....................    }
.................... 
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) {
147E:  MOVF   28,W
1480:  IORWF  29,W
1482:  BNZ   148C
1484:  MOVF   xC7,W
1486:  SUBLW  40
1488:  BZ    148C
....................          USB_stack_status.dev_req = NONE;
148A:  CLRF   1B
....................    }
.................... 
....................    usb_request_send_response(i);
148C:  MOVFF  C7,C9
1490:  RCALL  1412
1492:  RETURN 0
.................... }
.................... 
.................... #ENDIF
.................... 
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk
....................    transfer endpoints is not supported on slow speed devices per the USB
....................    specification.  You may be able to find unofficial drivers for your
....................    operating system that allows CDC to operate on a slow speed device,
....................    but CCS doesn't have any that they can recommend to you.
.................... */
.................... #if (USB_USE_FULL_SPEED==0)
....................    #error CDC and slow speed is not supported.  See comments above.
.................... #endif
.................... 
.................... struct {
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2)
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space)
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16)
.................... } __attribute__((__packed__)) usb_cdc_line_coding;
.................... 
.................... //length of time, in ms, of break signal as we received in a SendBreak message.
.................... //if ==0xFFFF, send break signal until we receive a 0x0000.
.................... unsigned int16 usb_cdc_break;
.................... 
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1];
.................... #else
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE];
.................... #endif
.................... 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT)
.................... #if sizeof(usb_cdc_put_buffer)>=0x100
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this.
....................  typedef unsigned int16 usb_cdc_tx_t;
.................... #else
....................  typedef unsigned int8 usb_cdc_tx_t;
.................... #endif
.................... 
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin;
.................... //#locate usb_cdc_put_buffer_nextin=0x1800
.................... 
.................... 
.................... #if defined(__PIC__)
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer
.................... #else
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE];
.................... #endif
.................... 
.................... int1 usb_cdc_got_set_line_coding;
.................... 
.................... struct  {
....................    int1 dte_present; //1=DTE present, 0=DTE not present
....................    int1 active;      //1=activate carrier, 0=deactivate carrier
....................    unsigned int reserved:6;
.................... } usb_cdc_carrier;
.................... 
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state;
.................... 
.................... /*
.................... #if defined(__PCH__)
....................  #byte INTCON=0xFF2
....................  #bit INT_GIE=INTCON.7
.................... #else
....................  #word SR=0x42
.................... #endif
.................... */
.................... 
.................... #if defined(USB_CDC_USE_ENCAPSULATED)
.................... unsigned int16 g_UsbCdcSendEncapsSize;
.................... #endif
.................... 
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data]
.................... void usb_isr_tok_out_cdc_control_dne(void) 
.................... {
....................    switch (__usb_cdc_state) {
*
1CDE:  MOVF   x77,W
1CE0:  XORLW  01
1CE2:  BZ    1CEA
1CE4:  XORLW  03
1CE6:  BZ    1CF4
1CE8:  BRA    1D18
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state);
....................       case USB_CDC_OUT_COMMAND:
....................         #if defined(USB_CDC_USE_ENCAPSULATED)
....................          usb_cdc_SendEncapsulatedCommand(usb_ep0_rx_buffer, g_UsbCdcSendEncapsSize);
....................         #endif
....................          usb_put_0len_0();
1CEA:  CLRF   xC9
1CEC:  CALL   1412
....................          __usb_cdc_state=0;
1CF0:  CLRF   x77
....................          break;
1CF2:  BRA    1D1A
.................... 
....................     #if USB_MAX_EP0_PACKET_LENGTH==8
....................       case USB_CDC_WAIT_0LEN:
....................          usb_put_0len_0();
....................          __usb_cdc_state=0;
....................          break;
....................     #endif
.................... 
....................       case USB_CDC_OUT_LINECODING:
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7);
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n");
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7);
1CF4:  CLRF   FEA
1CF6:  MOVLW  2C
1CF8:  MOVWF  FE9
1CFA:  MOVLW  04
1CFC:  MOVWF  FE2
1CFE:  MOVLW  18
1D00:  MOVWF  FE1
1D02:  MOVLW  07
1D04:  MOVWF  01
1D06:  MOVFF  FE6,FEE
1D0A:  DECFSZ 01,F
1D0C:  BRA    1D06
....................          __usb_cdc_state=0;
1D0E:  CLRF   x77
....................          usb_put_0len_0();
1D10:  CLRF   xC9
1D12:  CALL   1412
....................          break;
1D16:  BRA    1D1A
.................... 
....................       default:
....................          __usb_cdc_state=0;
1D18:  CLRF   x77
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................          break;
....................    }
1D1A:  GOTO   1D80 (RETURN)
.................... }
.................... 
.................... //handle IN token on 0 (setup packet)
.................... void usb_isr_tkn_cdc(void) {
....................    unsigned int16 wLen;
....................    //make sure the request goes to a CDC interface
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) {
*
19BA:  MOVLB  4
19BC:  DECFSZ x1C,W
19BE:  BRA    19C2
19C0:  BRA    19C6
19C2:  MOVF   x1C,F
19C4:  BNZ   1A44
....................       wLen = make16(usb_ep0_rx_buffer[7], usb_ep0_rx_buffer[6]);
19C6:  MOVFF  41F,C7
19CA:  MOVFF  41E,C6
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]);
....................       switch(usb_ep0_rx_buffer[1]) {
19CE:  MOVF   x19,W
19D0:  XORLW  00
19D2:  MOVLB  0
19D4:  BZ    19EC
19D6:  XORLW  01
19D8:  BZ    19F4
19DA:  XORLW  21
19DC:  BZ    19FC
19DE:  XORLW  01
19E0:  BZ    1A06
19E2:  XORLW  03
19E4:  BZ    1A28
19E6:  XORLW  01
19E8:  BZ    1A32
19EA:  BRA    1A40
....................          case 0x00:  //send_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             g_UsbCdcSendEncapsSize = wLen;
....................            #endif
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND;
19EC:  MOVLW  01
19EE:  MOVWF  x77
....................             usb_request_get_data();
19F0:  RCALL  19B4
....................             break;
19F2:  BRA    1A42
.................... 
....................          case 0x01:  //get_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             usb_cdc_GetEncapsulatedResponse(usb_ep0_tx_buffer, wLen);
....................            #endif
....................             usb_request_send_response(wLen);
19F4:  MOVFF  C6,C9
19F8:  RCALL  1412
....................             break;
19FA:  BRA    1A42
.................... 
....................          case 0x20:  //set_line_coding
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING;
19FC:  MOVLW  02
19FE:  MOVWF  x77
....................             usb_cdc_got_set_line_coding=true;
1A00:  BSF    x75.0
....................             usb_request_get_data();
1A02:  RCALL  19B4
....................             break;
1A04:  BRA    1A42
.................... 
....................          case 0x21:  //get_line_coding
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding));
1A06:  MOVLW  04
1A08:  MOVWF  FEA
1A0A:  MOVLW  58
1A0C:  MOVWF  FE9
1A0E:  CLRF   FE2
1A10:  MOVLW  2C
1A12:  MOVWF  FE1
1A14:  MOVLW  07
1A16:  MOVWF  01
1A18:  MOVFF  FE6,FEE
1A1C:  DECFSZ 01,F
1A1E:  BRA    1A18
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes
1A20:  MOVLW  07
1A22:  MOVWF  xC9
1A24:  RCALL  1412
....................             break;
1A26:  BRA    1A42
.................... 
....................          case 0x22:  //set_control_line_state
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2];
1A28:  MOVFF  41A,76
....................             usb_put_0len_0();
1A2C:  CLRF   xC9
1A2E:  RCALL  1412
....................             break;
1A30:  BRA    1A42
.................... 
....................          case 0x23:  //send_break
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]);
1A32:  MOVFF  41A,34
1A36:  MOVFF  41B,33
....................             usb_put_0len_0();
1A3A:  CLRF   xC9
1A3C:  RCALL  1412
....................             break;
1A3E:  BRA    1A42
.................... 
....................          default:
....................             usb_request_stall();
1A40:  RCALL  1418
....................             break;
1A42:  MOVLB  4
....................       }
....................    }
1A44:  MOVLB  0
1A46:  GOTO   1A78 (RETURN)
.................... }
.................... 
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars]
.................... void usb_isr_tok_out_cdc_data_dne(void) {
....................    usb_cdc_get_buffer_status.got=true;
*
1D62:  BSF    1F.0
....................    usb_cdc_get_buffer_status.index=0;
1D64:  CLRF   21
.................... #if (defined(__PIC__) && __PIC__)
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT);
1D66:  MOVLW  02
1D68:  MOVWF  xC7
1D6A:  BRA    1D1E
1D6C:  MOVFF  01,20
.................... #else
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer(
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE);
.................... #endif
....................    if (!usb_cdc_get_buffer_status.len)
1D70:  MOVF   20,F
1D72:  BNZ   1D76
....................    {
....................       usb_cdc_get_discard();
1D74:  RCALL  1D56
....................    }
1D76:  GOTO   1D8A (RETURN)
....................    /*
....................   #if defined(USB_CDC_ISR)
....................    else
....................    {
....................       USB_CDC_ISR();
....................    }
....................   #endif
....................   */
.................... }
.................... 
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters]
.................... void usb_isr_tok_in_cdc_data_dne(void) 
.................... {
....................    usb_cdc_flush_tx_buffer();
*
1E68:  RCALL  1E46
1E6A:  GOTO   1E8E (RETURN)
.................... }
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
*
247E:  MOVFF  AF,B5
2482:  MOVFF  AE,B4
2486:  MOVFF  B1,B7
248A:  MOVFF  B0,B6
248E:  MOVF   xB3,F
2490:  BNZ   2498
2492:  MOVF   xB2,W
2494:  SUBLW  00
2496:  BC    24F8
.................... {
....................    if(*su1!=*su2)
2498:  MOVFF  B4,FE9
249C:  MOVFF  B5,FEA
24A0:  MOVFF  FEF,B8
24A4:  MOVFF  B7,03
24A8:  MOVFF  B6,FE9
24AC:  MOVFF  B7,FEA
24B0:  MOVF   FEF,W
24B2:  SUBWF  xB8,W
24B4:  BZ    24E2
....................       return ((*su1<*su2)?-1:1);
24B6:  MOVFF  B5,03
24BA:  MOVFF  B4,FE9
24BE:  MOVFF  03,FEA
24C2:  MOVFF  FEF,B8
24C6:  MOVFF  B7,03
24CA:  MOVFF  B6,FE9
24CE:  MOVFF  B7,FEA
24D2:  MOVF   FEF,W
24D4:  SUBWF  xB8,W
24D6:  BC    24DC
24D8:  MOVLW  FF
24DA:  BRA    24DE
24DC:  MOVLW  01
24DE:  MOVWF  01
24E0:  BRA    24FC
24E2:  INCF   xB4,F
24E4:  BTFSC  FD8.2
24E6:  INCF   xB5,F
24E8:  INCF   xB6,F
24EA:  BTFSC  FD8.2
24EC:  INCF   xB7,F
24EE:  MOVF   xB2,W
24F0:  BTFSC  FD8.2
24F2:  DECF   xB3,F
24F4:  DECF   xB2,F
24F6:  BRA    248E
.................... }
.................... return 0;
24F8:  MOVLW  00
24FA:  MOVWF  01
24FC:  GOTO   2598 (RETURN)
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... void usb_cdc_flush_tx_buffer(void) 
.................... {
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE
....................    usb_cdc_tx_t n;
....................   #endif
....................   
....................    if (usb_cdc_put_buffer_nextin != 0)
*
1E46:  MOVF   x74,F
1E48:  BZ    1E66
....................    {
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE))
1E4A:  MOVLW  02
1E4C:  MOVWF  xC7
1E4E:  CLRF   xC9
1E50:  MOVLW  35
1E52:  MOVWF  xC8
1E54:  CLRF   xCB
1E56:  MOVFF  74,CA
1E5A:  MOVLW  02
1E5C:  MOVWF  xCC
1E5E:  RCALL  1DB0
1E60:  MOVF   01,F
1E62:  BZ    1E66
....................       {
....................          usb_cdc_put_buffer_nextin = 0;
1E64:  CLRF   x74
....................       }
....................      #else
....................       n = usb_cdc_put_buffer_nextin;
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets
....................          n = USB_CDC_DATA_IN_SIZE-1;
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE))
....................       {
....................          //pull the buffer back
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n);
....................          usb_cdc_put_buffer_nextin -= n;
....................       }      
....................      #endif
....................    }
1E66:  RETURN 0
.................... }
.................... 
.................... void usb_cdc_init(void) 
.................... {
....................    usb_cdc_line_coding.dwDTERrate = 9600;
*
1366:  CLRF   xC8
1368:  CLRF   xC7
136A:  MOVLW  25
136C:  MOVWF  xC6
136E:  MOVLW  80
1370:  MOVWF  xC5
1372:  MOVFF  C5,2C
1376:  MOVFF  C6,2D
137A:  CLRF   2E
137C:  CLRF   2F
....................    usb_cdc_line_coding.bCharFormat = 0;
137E:  CLRF   xC5
1380:  MOVFF  C5,30
....................    usb_cdc_line_coding.bParityType = 0;
1384:  CLRF   xC5
1386:  MOVFF  C5,31
....................    usb_cdc_line_coding.bDataBits = 8;
138A:  MOVLW  08
138C:  MOVWF  xC5
138E:  MOVFF  C5,32
....................    (int8)usb_cdc_carrier = 0;
1392:  CLRF   x76
....................    usb_cdc_got_set_line_coding = false;
1394:  BCF    x75.0
....................    usb_cdc_break = 0;
1396:  CLRF   34
1398:  CLRF   33
....................    usb_cdc_put_buffer_nextin = 0;
139A:  CLRF   x74
....................    usb_cdc_get_buffer_status.got = 0;
139C:  BCF    1F.0
....................    __usb_cdc_state = 0;
139E:  CLRF   x77
13A0:  RETURN 0
.................... }
.................... 
.................... ////////////////// END USB CONTROL HANDLING //////////////////////////////////
.................... 
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY /////////////////////////////
.................... 
.................... typedef struct
.................... {
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD.
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device.
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device. 
....................    unsigned int bFraming:1;   //A framing error has occurred.
....................    unsigned int bParity:1;    //A parity error has occurred.
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device.
....................    unsigned int reserved0:1;   //future use
....................    unsigned int reserved1:8;   //future use
.................... } cdc_serial_state_t;
.................... 
.................... /*
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring, 
....................    break signal and more (see cdc_serial_state_t).
....................    Some of these values are held by the host (meaning it's value only needs
....................    to be sent on change), but some values are one shot (meaning you continously
....................    need to send value to host while being held).
.................... */
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state)
.................... {
....................   #if __USB_PIC_PERIF__
*
2500:  CLRF   19
2502:  BTFSC  FF2.7
2504:  BSF    19.7
2506:  BCF    FF2.7
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer
....................   #else
....................    unsigned int8 payload[10];
....................    #define CDC_EP1_NOTIFY_BUFFER payload
....................   #endif
.................... 
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT))
2508:  MOVLW  01
250A:  MOVWF  xD4
250C:  CALL   1B60
2510:  BTFSC  19.7
2512:  BSF    FF2.7
2514:  MOVF   01,F
2516:  BNZ   251E
....................       return(false);
2518:  MOVLW  00
251A:  MOVWF  01
251C:  BRA    2562
.................... 
....................    //bmRequestType
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001
251E:  MOVLW  A1
2520:  MOVLB  4
2522:  MOVWF  x98
....................    //bNotification
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE
2524:  MOVLW  20
2526:  MOVWF  x99
....................    //wValue
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0;
2528:  CLRF   x9A
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0;
252A:  CLRF   x9B
....................    //wIndex
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0;
252C:  CLRF   x9C
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0;
252E:  CLRF   x9D
....................    //wLength
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t)
2530:  MOVLW  02
2532:  MOVWF  x9E
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0;
2534:  CLRF   x9F
....................    //data
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state;
2536:  MOVFF  AE,4A0
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8;
253A:  MOVFF  AF,4A1
253E:  CLRF   19
2540:  BTFSC  FF2.7
2542:  BSF    19.7
2544:  BCF    FF2.7
.................... 
....................   #if __USB_PIC_PERIF__
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE);
2546:  MOVLW  01
2548:  MOVLB  0
254A:  MOVWF  xCF
254C:  CLRF   xD1
254E:  MOVLW  0A
2550:  MOVWF  xD0
2552:  MOVLW  02
2554:  MOVWF  xD2
2556:  CALL   1BAE
255A:  BTFSC  19.7
255C:  BSF    FF2.7
....................   #else
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE);
....................   #endif
....................    
....................    return(true);
255E:  MOVLW  01
2560:  MOVWF  01
2562:  GOTO   25B0 (RETURN)
.................... }
.................... 
.................... void usb_cdc_get_discard(void)
.................... {
....................    usb_cdc_get_buffer_status.got = false;
*
1D56:  BCF    1F.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE);
1D58:  MOVLW  02
1D5A:  MOVWF  xC7
1D5C:  MOVWF  xC8
1D5E:  RCALL  1A7C
1D60:  RETURN 0
.................... }
.................... 
.................... char usb_cdc_getc(void) 
.................... {
....................    char c;
.................... 
....................    while (!usb_cdc_kbhit()) 
*
26A8:  BTFSC  1F.0
26AA:  BRA    26AE
....................    {
....................      #if defined(USB_ISR_POLLING)
26AC:  BRA    26A8
....................       usb_task();
....................      #endif
....................    }
.................... 
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++];
26AE:  MOVF   21,W
26B0:  INCF   21,F
26B2:  ADDLW  A3
26B4:  MOVWF  FE9
26B6:  MOVLW  04
26B8:  MOVWF  FEA
26BA:  BTFSC  FD8.0
26BC:  INCF   FEA,F
26BE:  MOVFF  FEF,AC
.................... 
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len) 
26C2:  MOVF   20,W
26C4:  SUBWF  21,W
26C6:  BNC   26D8
26C8:  CLRF   19
26CA:  BTFSC  FF2.7
26CC:  BSF    19.7
26CE:  BCF    FF2.7
....................    {
....................       usb_cdc_get_discard();
26D0:  CALL   1D56
26D4:  BTFSC  19.7
26D6:  BSF    FF2.7
....................    }
.................... 
....................    return(c);
26D8:  MOVFF  AC,01
26DC:  GOTO   2812 (RETURN)
.................... }
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... #define __USB_PAUSE_ISR()
.................... #define __USB_RESTORE_ISR()
.................... #else
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1
.................... #endif
.................... 
.................... static void _usb_cdc_putc_fast_noflush(char c)
.................... {
....................    __USB_PAUSE_ISR();
*
2604:  BCF    xB1.0
2606:  BTFSC  FA0.5
2608:  BSF    xB1.0
260A:  BCF    FA0.5
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) 
....................    {
....................       usb_cdc_flush_tx_buffer();
....................    }
....................   #endif
.................... 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) {
260C:  MOVF   x74,W
260E:  SUBLW  3E
2610:  BC    2616
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer!
2612:  MOVLW  3E
2614:  MOVWF  x74
....................    }
....................    
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c;
2616:  MOVF   x74,W
2618:  INCF   x74,F
261A:  CLRF   03
261C:  ADDLW  35
261E:  MOVWF  FE9
2620:  MOVLW  00
2622:  ADDWFC 03,W
2624:  MOVWF  FEA
2626:  MOVFF  B0,FEF
.................... 
....................    __USB_RESTORE_ISR();
262A:  BTFSS  xB1.0
262C:  BRA    2630
262E:  BSF    FA0.5
2630:  GOTO   263A (RETURN)
.................... }
.................... 
.................... void usb_cdc_putc_fast(char c)
.................... {
....................    _usb_cdc_putc_fast_noflush(c);
2634:  MOVFF  AF,B0
2638:  BRA    2604
263A:  CLRF   19
263C:  BTFSC  FF2.7
263E:  BSF    19.7
2640:  BCF    FF2.7
.................... 
....................   #if defined(USB_ISR_POLLING)
....................    // if interrupts are disabled, we should clear all activity isrs
....................    // before we attempt to put any data onto an endpoint.
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT))
....................       return;
....................    usb_task();
....................   #endif
....................   
....................   #if !defined(USB_CDC_DELAYED_FLUSH)
....................    //if (usb_cdc_put_buffer_free()) 
....................    {
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin);
....................       usb_cdc_flush_tx_buffer();
2642:  RCALL  1E46
2644:  BTFSC  19.7
2646:  BSF    FF2.7
....................    }
....................   #endif
2648:  GOTO   2684 (RETURN)
.................... 
....................    //putc('*');
.................... }
.................... 
.................... void usb_cdc_putc(char c)
.................... {
....................    while (!usb_cdc_putready()) 
264C:  MOVLW  3F
264E:  BSF    FD8.0
2650:  SUBFWB x74,W
2652:  BNZ   267E
2654:  CLRF   19
2656:  BTFSC  FF2.7
2658:  BSF    19.7
265A:  BCF    FF2.7
....................    {
....................      #if 1
....................       if (usb_cdc_put_buffer_free()) 
265C:  MOVLW  02
265E:  MOVWF  xD4
2660:  CALL   1B60
2664:  BTFSC  19.7
2666:  BSF    FF2.7
2668:  MOVF   01,F
266A:  BZ    267C
266C:  CLRF   19
266E:  BTFSC  FF2.7
2670:  BSF    19.7
2672:  BCF    FF2.7
....................       {
....................          usb_cdc_flush_tx_buffer();
2674:  CALL   1E46
2678:  BTFSC  19.7
267A:  BSF    FF2.7
....................       }
....................      #endif
.................... 
....................      #if defined(USB_ISR_POLLING)
267C:  BRA    264C
....................       usb_task();
....................      #endif
....................    }
....................    usb_cdc_putc_fast(c);
267E:  MOVFF  AE,AF
2682:  BRA    2634
2684:  RETURN 0
.................... }
.................... 
.................... int1 usb_cdc_putd(char *ptr, unsigned int8 len)
.................... {
....................  #if USB_EP2_TX_SIZE>=0x100
....................    unsigned int16 i;
....................  #else
....................    unsigned int8 i;
....................  #endif
....................    char c;
....................    
....................    i = 0;
....................    
....................    if (!usb_cdc_put_buffer_free())
....................       return(false);
....................    
....................    while(len--)
....................    {
....................       c = *ptr++;
....................       _usb_cdc_putc_fast_noflush(c);
....................       if (++i >= USB_EP2_TX_SIZE)
....................          break;
....................    }
....................    
....................    usb_cdc_flush_tx_buffer();
....................    
....................    return(true);
.................... }
.................... 
.................... int1 usb_cdc_puts(char *ptr)
.................... {   
....................    unsigned int8 len;
.................... 
....................    len = strlen(ptr);
....................   
....................    return(usb_cdc_putd(ptr, len));
.................... }
.................... 
.................... #endif //__USB_CDC_HELPERS_ONLY__
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... char gethex1_usb() 
.................... {
....................    char digit;
.................... 
....................    digit = usb_cdc_getc();
.................... 
....................    usb_cdc_putc(digit);
.................... 
....................    if(digit<='9')
....................      return(digit-'0');
....................    else
....................      return((toupper(digit)-'A')+10);
.................... }
.................... 
.................... char gethex_usb() {
....................    unsigned int8 lo,hi;
.................... 
....................    hi = gethex1_usb();
....................    lo = gethex1_usb();
....................    if(lo==0xdd)
....................      return(hi);
....................    else
....................      return( hi*16+lo );
.................... }
.................... 
.................... void get_string_usb(char* s, unsigned int max) {
....................    unsigned int len;
....................    char c;
.................... 
....................    --max;
....................    len=0;
....................    do {
....................      c=usb_cdc_getc();
....................      if(c==8) {  // Backspace
....................         if(len>0) {
....................           len--;
....................           usb_cdc_putc(c);
....................           usb_cdc_putc(' ');
....................           usb_cdc_putc(c);
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
....................        if(len<max) {
....................          s[len++]=c;
....................          usb_cdc_putc(c);
....................        }
....................    } while(c!=13);
....................    s[len]=0;
.................... }
.................... 
.................... 
.................... // stdlib.h is required for the ato_ conversions
.................... // in the following functions
.................... #ifdef _STDLIB
.................... 
.................... signed int get_int_usb() {
....................   char s[7];
....................   signed int i;
.................... 
....................   get_string_usb(s, 7);
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... 
.................... signed long get_long_usb() {
....................   char s[13];
....................   signed long l;
.................... 
....................   get_string_usb(s, 13);
....................   l=atol(s);
....................   return(l);
.................... }
.................... 
.................... float get_float_usb() {
....................   char s[20];
....................   float f;
.................... 
....................   get_string_usb(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #define LCD_DB4   PIN_D7
....................    #define LCD_DB5   PIN_D6 
....................    #define LCD_DB6   PIN_D5 
....................    #define LCD_DB7   PIN_D4 
....................    #define LCD_RS    PIN_D0 
....................    #define LCD_RW    PIN_D1 
....................    #define LCD_E     PIN_D2
....................    #include "lcd20x4.c"
.................... // Flex_LCD420.c 
.................... 
.................... // These pins are for my Microchip PicDem2-Plus board, 
.................... // which I used to test this driver. 
.................... // An external 20x4 LCD is connected to these pins. 
.................... // Change these pins to match your own board's connections. 
.................... 
.................... 
.................... 
.................... 
.................... // To prove that the driver can be used with random 
.................... // pins, I also tested it with these pins: 
.................... #ifndef LCD_DB4
.................... #define LCD_DB4   PIN_D4
.................... #endif
.................... 
.................... #ifndef LCD_DB5
.................... #define LCD_DB5   PIN_B1
.................... #endif
.................... 
.................... #ifndef LCD_DB6
.................... #define LCD_DB6   PIN_C5 
.................... #endif
.................... 
.................... #ifndef LCD_DB7
.................... #define LCD_DB7   PIN_B5
.................... #endif
.................... 
.................... #ifndef LCD_RS
.................... #define LCD_RS    PIN_E2 
.................... #endif
.................... 
.................... #ifndef LCD_E
.................... #define LCD_E     PIN_D6 
.................... #endif
.................... 
.................... //!#ifndef LCD_RW
.................... //!#define LCD_RW    PIN_B2 
.................... //!#endif
.................... 
.................... 
....................  
.................... 
.................... // If you want only a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and comment 
.................... // out the following line.  Doing so will save one PIC 
.................... // pin, but at the cost of losing the ability to read from 
.................... // the LCD.  It also makes the write time a little longer 
.................... // because a static delay must be used, instead of polling 
.................... // the LCD's busy bit.  Normally a 6-pin interface is only 
.................... // used if you are running out of PIC pins, and you need 
.................... // to use as few as possible for the LCD.
.................... #ifndef USE_RW_PIN
.................... #define USE_RW_PIN   1
.................... #endif
.................... 
.................... #ifdef USE_RW_PIN
....................    #ifndef LCD_RW
....................       #define LCD_RW    PIN_B2 
....................    #endif
.................... #endif
.................... 
....................      
.................... 
.................... 
.................... // These are the line addresses for most 4x20 LCDs. 
.................... #define LCD_LINE_1_ADDRESS 0x00 
.................... #define LCD_LINE_2_ADDRESS 0x40 
.................... #define LCD_LINE_3_ADDRESS 0x14 
.................... #define LCD_LINE_4_ADDRESS 0x54 
.................... 
.................... // These are the line addresses for LCD's which use 
.................... // the Hitachi HD66712U controller chip. 
.................... /* 
.................... #define LCD_LINE_1_ADDRESS 0x00 
.................... #define LCD_LINE_2_ADDRESS 0x20 
.................... #define LCD_LINE_3_ADDRESS 0x40 
.................... #define LCD_LINE_4_ADDRESS 0x60 
.................... */ 
.................... 
.................... 
.................... //======================================== 
.................... 
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more) 
.................... 
.................... int8 lcd_line; 
.................... 
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots 
....................  0xc,                     // Display on 
....................  1,                       // Clear display 
....................  6                        // Increment cursor 
....................  }; 
....................                               
.................... 
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
.................... // Note:  !! converts an integer expression 
.................... // to a boolean (1 or 0). 
....................  output_bit(LCD_DB4, !!(nibble & 1)); 
*
2222:  BTFSC  xB6.0
2224:  BRA    222A
2226:  BCF    F8C.7
2228:  BRA    222C
222A:  BSF    F8C.7
222C:  BCF    F95.7
....................  output_bit(LCD_DB5, !!(nibble & 2));  
222E:  BTFSC  xB6.1
2230:  BRA    2236
2232:  BCF    F8C.6
2234:  BRA    2238
2236:  BSF    F8C.6
2238:  BCF    F95.6
....................  output_bit(LCD_DB6, !!(nibble & 4));    
223A:  BTFSC  xB6.2
223C:  BRA    2242
223E:  BCF    F8C.5
2240:  BRA    2244
2242:  BSF    F8C.5
2244:  BCF    F95.5
....................  output_bit(LCD_DB7, !!(nibble & 8));    
2246:  BTFSC  xB6.3
2248:  BRA    224E
224A:  BCF    F8C.4
224C:  BRA    2250
224E:  BSF    F8C.4
2250:  BCF    F95.4
.................... 
....................  delay_cycles(1); 
2252:  NOP   
....................  output_high(LCD_E); 
2254:  BCF    F95.2
2256:  BSF    F8C.2
....................  delay_us(2); 
2258:  MOVLW  07
225A:  MOVWF  00
225C:  DECFSZ 00,F
225E:  BRA    225C
2260:  BRA    2262
....................  output_low(LCD_E); 
2262:  BCF    F95.2
2264:  BCF    F8C.2
2266:  RETURN 0
.................... } 
.................... 
.................... //----------------------------------- 
.................... // This sub-routine is only called by lcd_read_byte(). 
.................... // It's not a stand-alone routine.  For example, the 
.................... // R/W signal is set high by lcd_read_byte() before 
.................... // this routine is called.      
.................... 
.................... #ifdef USE_RW_PIN 
.................... int8 lcd_read_nibble(void) 
.................... { 
.................... int8 retval; 
.................... // Create bit variables so that we can easily set 
.................... // individual bits in the retval variable. 
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
.................... 
.................... retval = 0; 
2268:  CLRF   xB7
....................     
.................... output_high(LCD_E); 
226A:  BCF    F95.2
226C:  BSF    F8C.2
.................... delay_us(1); 
226E:  MOVLW  03
2270:  MOVWF  00
2272:  DECFSZ 00,F
2274:  BRA    2272
2276:  BRA    2278
.................... 
.................... retval_0 = input(LCD_DB4); 
2278:  BSF    F95.7
227A:  BCF    xB7.0
227C:  BTFSC  F83.7
227E:  BSF    xB7.0
.................... retval_1 = input(LCD_DB5); 
2280:  BSF    F95.6
2282:  BCF    xB7.1
2284:  BTFSC  F83.6
2286:  BSF    xB7.1
.................... retval_2 = input(LCD_DB6); 
2288:  BSF    F95.5
228A:  BCF    xB7.2
228C:  BTFSC  F83.5
228E:  BSF    xB7.2
.................... retval_3 = input(LCD_DB7); 
2290:  BSF    F95.4
2292:  BCF    xB7.3
2294:  BTFSC  F83.4
2296:  BSF    xB7.3
....................   
.................... output_low(LCD_E); 
2298:  BCF    F95.2
229A:  BCF    F8C.2
.................... delay_us(1); 
229C:  MOVLW  03
229E:  MOVWF  00
22A0:  DECFSZ 00,F
22A2:  BRA    22A0
22A4:  BRA    22A6
....................     
.................... return(retval);    
22A6:  MOVFF  B7,01
22AA:  RETURN 0
.................... }    
.................... #endif 
.................... 
.................... //--------------------------------------- 
.................... // Read a byte from the LCD and return it. 
.................... 
.................... #ifdef USE_RW_PIN 
.................... int8 lcd_read_byte(void) 
.................... { 
....................    int8 low; 
....................    int8 high; 
....................    #ifdef LCD_RW
....................       output_high(LCD_RW);
22AC:  BCF    F95.1
22AE:  BSF    F8C.1
....................    #endif
....................    delay_cycles(1); 
22B0:  NOP   
....................    
....................    high = lcd_read_nibble(); 
22B2:  RCALL  2268
22B4:  MOVFF  01,B6
....................    
....................    low = lcd_read_nibble(); 
22B8:  RCALL  2268
22BA:  MOVFF  01,B5
....................    
....................    return( (high<<4) | low); 
22BE:  SWAPF  xB6,W
22C0:  MOVWF  00
22C2:  MOVLW  F0
22C4:  ANDWF  00,F
22C6:  MOVF   00,W
22C8:  IORWF  xB5,W
22CA:  MOVWF  01
22CC:  GOTO   22D6 (RETURN)
.................... } 
.................... #endif 
.................... 
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
....................    output_low(LCD_RS); 
22D0:  BCF    F95.0
22D2:  BCF    F8C.0
....................    
....................    #ifdef USE_RW_PIN 
....................       while(bit_test(lcd_read_byte(),7)) ; 
22D4:  BRA    22AC
22D6:  MOVFF  01,B5
22DA:  BTFSC  01.7
22DC:  BRA    22D4
....................    #else 
....................       delay_us(60);  
....................    #endif 
....................    
....................    if(address) 
22DE:  MOVF   xB3,F
22E0:  BZ    22E8
....................       output_high(LCD_RS); 
22E2:  BCF    F95.0
22E4:  BSF    F8C.0
22E6:  BRA    22EC
....................    else 
....................       output_low(LCD_RS); 
22E8:  BCF    F95.0
22EA:  BCF    F8C.0
....................          
....................     delay_cycles(1); 
22EC:  NOP   
....................    
....................    #ifdef USE_RW_PIN
....................       #ifdef LCD_RW
....................          output_low(LCD_RW);
22EE:  BCF    F95.1
22F0:  BCF    F8C.1
....................       #endif
....................       delay_cycles(1); 
22F2:  NOP   
....................    #endif 
....................    
....................    output_low(LCD_E); 
22F4:  BCF    F95.2
22F6:  BCF    F8C.2
....................    
....................    lcd_send_nibble(n >> 4); 
22F8:  SWAPF  xB4,W
22FA:  MOVWF  xB5
22FC:  MOVLW  0F
22FE:  ANDWF  xB5,F
2300:  MOVFF  B5,B6
2304:  RCALL  2222
....................    lcd_send_nibble(n & 0xf); 
2306:  MOVF   xB4,W
2308:  ANDLW  0F
230A:  MOVWF  xB5
230C:  MOVWF  xB6
230E:  RCALL  2222
2310:  RETURN 0
.................... } 
.................... //---------------------------- 
.................... 
.................... void lcd_init(void) 
.................... { 
....................    int8 i; 
.................... 
....................    lcd_line = 1; 
2312:  MOVLW  01
2314:  MOVWF  x7A
.................... 
....................    output_low(LCD_RS); 
2316:  BCF    F95.0
2318:  BCF    F8C.0
.................... 
....................    #ifdef USE_RW_PIN
....................       #ifdef LCD_RW
....................          output_low(LCD_RW); 
231A:  BCF    F95.1
231C:  BCF    F8C.1
....................       #endif
....................    #endif
.................... 
....................    output_low(LCD_E); 
231E:  BCF    F95.2
2320:  BCF    F8C.2
.................... 
....................    // Some LCDs require 15 ms minimum delay after 
....................    // power-up.  Others require 30 ms.  I'm going 
....................    // to set it to 35 ms, so it should work with 
....................    // all of them. 
....................    delay_ms(35);          
2322:  MOVLW  23
2324:  MOVWF  xAF
2326:  RCALL  21FA
.................... 
....................    for(i=0 ;i < 3; i++) 
2328:  CLRF   xAC
232A:  MOVF   xAC,W
232C:  SUBLW  02
232E:  BNC   2340
....................    { 
....................       lcd_send_nibble(0x03); 
2330:  MOVLW  03
2332:  MOVWF  xB6
2334:  RCALL  2222
....................       delay_ms(5); 
2336:  MOVLW  05
2338:  MOVWF  xAF
233A:  RCALL  21FA
233C:  INCF   xAC,F
233E:  BRA    232A
....................    } 
.................... 
....................    lcd_send_nibble(0x02); 
2340:  MOVLW  02
2342:  MOVWF  xB6
2344:  RCALL  2222
.................... 
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
2346:  CLRF   xAC
2348:  MOVF   xAC,W
234A:  SUBLW  03
234C:  BNC   2362
....................    { 
....................       lcd_send_byte(0, LCD_INIT_STRING[i]); 
234E:  CLRF   03
2350:  MOVF   xAC,W
2352:  CALL   122A
2356:  MOVWF  xAD
2358:  CLRF   xB3
235A:  MOVWF  xB4
235C:  RCALL  22D0
....................     
....................       // If the R/W signal is not used, then 
....................       // the busy bit can't be polled.  One of 
....................       // the init commands takes longer than 
....................       // the hard-coded delay of 50 us, so in 
....................       // that case, lets just do a 5 ms delay 
....................       // after all four of them. 
....................       #ifndef USE_RW_PIN 
235E:  INCF   xAC,F
2360:  BRA    2348
....................          delay_ms(5); 
....................       #endif 
....................    } 
2362:  GOTO   278E (RETURN)
.................... 
.................... } 
.................... 
.................... //---------------------------- 
.................... 
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
.................... 
.................... 
.................... switch(y) 
2366:  MOVF   xB0,W
2368:  XORLW  01
236A:  BZ    237A
236C:  XORLW  03
236E:  BZ    237E
2370:  XORLW  01
2372:  BZ    2384
2374:  XORLW  07
2376:  BZ    238A
2378:  BRA    2390
....................   { 
....................    case 1: 
....................      address = LCD_LINE_1_ADDRESS; 
237A:  CLRF   xB1
....................      break; 
237C:  BRA    2392
.................... 
....................    case 2: 
....................      address = LCD_LINE_2_ADDRESS; 
237E:  MOVLW  40
2380:  MOVWF  xB1
....................      break; 
2382:  BRA    2392
.................... 
....................    case 3: 
....................      address = LCD_LINE_3_ADDRESS; 
2384:  MOVLW  14
2386:  MOVWF  xB1
....................      break; 
2388:  BRA    2392
.................... 
....................    case 4: 
....................      address = LCD_LINE_4_ADDRESS; 
238A:  MOVLW  54
238C:  MOVWF  xB1
....................      break; 
238E:  BRA    2392
.................... 
....................    default: 
....................      address = LCD_LINE_1_ADDRESS; 
2390:  CLRF   xB1
....................      break; 
....................       
....................   } 
.................... 
.................... address += x-1; 
2392:  MOVLW  01
2394:  SUBWF  xAF,W
2396:  ADDWF  xB1,F
.................... lcd_send_byte(0, 0x80 | address); 
2398:  MOVF   xB1,W
239A:  IORLW  80
239C:  MOVWF  xB2
239E:  CLRF   xB3
23A0:  MOVWF  xB4
23A2:  RCALL  22D0
23A4:  GOTO   23EE (RETURN)
.................... } 
.................... 
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
23A8:  MOVF   xAE,W
23AA:  XORLW  0C
23AC:  BZ    23B8
23AE:  XORLW  06
23B0:  BZ    23CC
23B2:  XORLW  02
23B4:  BZ    23DA
23B6:  BRA    23E4
....................    { 
....................     case '\f': 
....................       lcd_send_byte(0,1); 
23B8:  CLRF   xB3
23BA:  MOVLW  01
23BC:  MOVWF  xB4
23BE:  RCALL  22D0
....................       lcd_line = 1; 
23C0:  MOVLW  01
23C2:  MOVWF  x7A
....................       delay_ms(2); 
23C4:  MOVLW  02
23C6:  MOVWF  xAF
23C8:  RCALL  21FA
....................       break; 
23CA:  BRA    23EE
....................     
....................     case '\n': 
....................        lcd_gotoxy(1, ++lcd_line); 
23CC:  INCF   x7A,F
23CE:  MOVLW  01
23D0:  MOVWF  xAF
23D2:  MOVFF  7A,B0
23D6:  BRA    2366
....................        break; 
23D8:  BRA    23EE
....................     
....................     case '\b': 
....................        lcd_send_byte(0,0x10); 
23DA:  CLRF   xB3
23DC:  MOVLW  10
23DE:  MOVWF  xB4
23E0:  RCALL  22D0
....................        break; 
23E2:  BRA    23EE
....................     
....................     default: 
....................        lcd_send_byte(1,c); 
23E4:  MOVLW  01
23E6:  MOVWF  xB3
23E8:  MOVFF  AE,B4
23EC:  RCALL  22D0
....................        break; 
....................    } 
23EE:  RETURN 0
.................... }
.................... 
.................... //----------------------------- 
.................... void lcd_puts(unsigned char *dato){
....................    while (*dato){
....................       
....................       switch(*dato)
....................       {
....................          case '\f':
....................             lcd_send_byte(0,1);
....................             lcd_line = 1; 
....................             delay_ms(2);
....................             break;
....................          case '\n':
....................             lcd_gotoxy(1, ++lcd_line); 
....................             break;
....................          case '\b': 
....................             lcd_send_byte(0,0x10); 
....................             break;
....................          default:
....................             lcd_send_byte(1,*dato);
....................             break;
....................       }
....................       
....................       //lcd_send_byte(1,*dato);    // Envio el dato al LCD
....................       dato++;             // Incrementa el buffer de dato
....................     }
.................... }
.................... 
.................... //------------------------------ 
.................... #ifdef USE_RW_PIN 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
.................... char value; 
.................... 
.................... lcd_gotoxy(x,y); 
.................... 
.................... // Wait until busy flag is low. 
.................... while(bit_test(lcd_read_byte(),7));  
.................... 
.................... output_high(LCD_RS); 
.................... value = lcd_read_byte(); 
.................... output_low(LCD_RS); 
.................... 
.................... return(value); 
.................... } 
.................... #endif
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //
.................... // usb_debug_task()
.................... //
.................... // When called periodically, displays debugging information over serial
.................... // to display enumeration and connection states.  Also lights LED1 based upon
.................... // enumeration and status.
.................... //
.................... /////////////////////////////////////////////////////////////////////////////
.................... void usb_debug_task(void)
.................... {
....................    static int8 last_connected;
....................    static int8 last_enumerated;
....................    int8 new_connected;
....................    int8 new_enumerated;
....................    static int8 last_cdc;
....................    int8 new_cdc;
.................... 
....................    new_connected=usb_attached();
....................    new_enumerated=usb_enumerated();
....................    new_cdc=usb_cdc_connected();
.................... 
....................    if (new_enumerated)
....................       LED_ON(LED1);
....................    else
....................       LED_OFF(LED1);
.................... 
....................    if (new_cdc)
....................       LED_ON(LED2);
....................    else
....................       LED_OFF(LED2);
.................... 
....................    if (usb_cdc_carrier.dte_present)
....................       LED_ON(LED3);
....................    else
....................       LED_OFF(LED3);
.................... 
....................    if (new_connected && !last_connected)
....................       uart_printf("USB connected, waiting for enumaration...\r\n\n");
....................    if (!new_connected && last_connected)
....................       uart_printf("USB disconnected, waiting for connection...\r\n\n");
....................    if (new_enumerated && !last_enumerated)
....................       uart_printf("USB enumerated by PC/HOST\r\n\n");
....................    if (!new_enumerated && last_enumerated)
....................       uart_printf("USB unenumerated by PC/HOST, waiting for enumeration...\r\n\n");
....................    if (new_cdc && !last_cdc)
....................       uart_printf("Serial program initiated on USB<->UART COM Port\r\n\n");
.................... 
....................    last_connected=new_connected;
....................    last_enumerated=new_enumerated;
....................    last_cdc=new_cdc;
.................... }
.................... 
.................... // transmit to the host new dcd/dsr, its value based on button.
.................... void cdc_serial_state_task(void)
.................... {
....................    cdc_serial_state_t newState;
....................    static cdc_serial_state_t lastState;
.................... 
....................    memset(&newState, 0x00, sizeof(newState));
*
2566:  CLRF   FEA
2568:  MOVLW  AC
256A:  MOVWF  FE9
256C:  CLRF   00
256E:  CLRF   02
2570:  MOVLW  02
2572:  MOVWF  01
2574:  BRA    2462
.................... 
....................    newState.bRxCarrier = BUTTON_PRESSED();
2576:  BSF    F93.4
2578:  BCF    xAC.0
257A:  BTFSS  F81.4
257C:  BSF    xAC.0
....................    newState.bTxCarrier = newState.bRxCarrier;
257E:  BCF    xAC.1
2580:  BTFSC  xAC.0
2582:  BSF    xAC.1
.................... 
....................    if (memcmp(&newState, &lastState, sizeof(newState)) != 0)
2584:  CLRF   xAF
2586:  MOVLW  AC
2588:  MOVWF  xAE
258A:  CLRF   xB1
258C:  MOVLW  80
258E:  MOVWF  xB0
2590:  CLRF   xB3
2592:  MOVLW  02
2594:  MOVWF  xB2
2596:  BRA    247E
2598:  MOVF   01,F
259A:  BZ    25E8
....................    {
....................       uart_printf("\r\nNew button state being sent: ");
259C:  MOVLW  B8
259E:  MOVWF  FF6
25A0:  MOVLW  20
25A2:  MOVWF  FF7
25A4:  RCALL  21AC
....................       //change in state, send it.
....................       if (usb_cdc_serial_state(newState))
25A6:  MOVFF  AD,AF
25AA:  MOVFF  AC,AE
25AE:  BRA    2500
25B0:  MOVF   01,F
25B2:  BZ    25CE
....................       {
....................          //state was sent ok, save it in memory so we don't resend it.
....................          memcpy(&lastState, &newState, sizeof(lastState));
25B4:  MOVFF  AC,80
25B8:  MOVFF  AD,81
....................          uart_printf("OK");
25BC:  MOVLW  4F
25BE:  BTFSS  F9E.4
25C0:  BRA    25BE
25C2:  MOVWF  FAD
25C4:  MOVLW  4B
25C6:  BTFSS  F9E.4
25C8:  BRA    25C6
25CA:  MOVWF  FAD
....................       }
25CC:  BRA    25D8
....................       else
....................       {
....................          uart_printf("FAIL");
25CE:  MOVLW  D8
25D0:  MOVWF  FF6
25D2:  MOVLW  20
25D4:  MOVWF  FF7
25D6:  RCALL  21AC
....................       }
....................       uart_printf("\r\n");
25D8:  MOVLW  0D
25DA:  BTFSS  F9E.4
25DC:  BRA    25DA
25DE:  MOVWF  FAD
25E0:  MOVLW  0A
25E2:  BTFSS  F9E.4
25E4:  BRA    25E2
25E6:  MOVWF  FAD
....................    }
25E8:  GOTO   27C2 (RETURN)
.................... }
.................... 
.................... void main(void)
*
2716:  CLRF   FF8
2718:  BCF    FD0.7
271A:  BSF    07.7
271C:  CLRF   1A
271E:  BSF    FB8.3
2720:  MOVLW  E1
2722:  MOVWF  FAF
2724:  MOVLW  04
2726:  MOVWF  FB0
2728:  MOVLW  A6
272A:  MOVWF  FAC
272C:  MOVLW  90
272E:  MOVWF  FAB
2730:  CLRF   x7F
2732:  CLRF   x7E
2734:  MOVF   FC1,W
2736:  ANDLW  C0
2738:  IORLW  0F
273A:  MOVWF  FC1
273C:  MOVLW  07
273E:  MOVWF  FB4
2740:  CLRF   x78
2742:  CLRF   x79
2744:  CLRF   x7B
2746:  CLRF   x7C
2748:  CLRF   x7D
274A:  CLRF   x80
274C:  CLRF   x81
274E:  CLRF   xAB
.................... {
....................    char c, buffer[40],i=0;
.................... 
....................    HW_INIT();
2750:  MOVF   FC1,W
2752:  ANDLW  C0
2754:  IORLW  0E
2756:  MOVWF  FC1
....................    set_tris_e(0);
2758:  MOVLW  00
275A:  MOVWF  F96
.................... 
.................... //!   LED_OFF(LED1);
.................... //!   LED_OFF(LED2);
.................... //!   LED_OFF(LED3);
.................... 
....................    uart_printf("\r\n\nCCS CDC (Virtual RS232) Example\r\n");
275C:  MOVLW  DE
275E:  MOVWF  FF6
2760:  MOVLW  20
2762:  MOVWF  FF7
2764:  RCALL  21AC
.................... 
.................... 
....................    uart_printf("\r\n\PCM: v");
2766:  MOVLW  04
2768:  MOVWF  FF6
276A:  MOVLW  21
276C:  MOVWF  FF7
276E:  RCALL  21AC
....................    uart_printf(__PCH__);
2770:  MOVLW  0E
2772:  MOVWF  FF6
2774:  MOVLW  21
2776:  MOVWF  FF7
2778:  RCALL  21AC
.................... 
....................    uart_printf("\r\n");
277A:  MOVLW  0D
277C:  BTFSS  F9E.4
277E:  BRA    277C
2780:  MOVWF  FAD
2782:  MOVLW  0A
2784:  BTFSS  F9E.4
2786:  BRA    2784
2788:  MOVWF  FAD
....................    
....................    
.................... 
....................    // init USB (non-blocking)
....................    // usb_task() need to be called in your loop to finish USB initialization.
....................    usb_init_cs();
278A:  BRA    21F4
.................... 
....................   #if !(__USB_PIC_PERIF__)
....................    uart_printf("USBN: 0x%X", usbn_get_version());
....................    uart_printf("\r\n\n");
....................   #endif
....................   
....................   lcd_init();
278C:  BRA    2312
....................    lcd_putc("\fUSB-Serial\ncon pic18f4550");
278E:  MOVLW  14
2790:  MOVWF  FF6
2792:  MOVLW  21
2794:  MOVWF  FF7
2796:  RCALL  23F0
....................    delay_ms(1000);
2798:  MOVLW  04
279A:  MOVWF  xAC
279C:  MOVLW  FA
279E:  MOVWF  xAF
27A0:  RCALL  21FA
27A2:  DECFSZ xAC,F
27A4:  BRA    279C
....................    lcd_putc("\fSuscribete\nAl canal");
27A6:  MOVLW  30
27A8:  MOVWF  FF6
27AA:  MOVLW  21
27AC:  MOVWF  FF7
27AE:  RCALL  23F0
....................    delay_ms(1000);
27B0:  MOVLW  04
27B2:  MOVWF  xAC
27B4:  MOVLW  FA
27B6:  MOVWF  xAF
27B8:  RCALL  21FA
27BA:  DECFSZ xAC,F
27BC:  BRA    27B4
....................    
....................    //output_high(PIN_E0);
....................    while (TRUE)
....................    {
....................       // service low level USB operations.
....................       usb_task();
27BE:  BRA    243E
.................... 
....................       // special debugging routines for this program.
....................       //usb_debug_task();
.................... 
....................       // send host DSR state, which is based on button.
....................       cdc_serial_state_task();
27C0:  BRA    2566
.................... 
....................       if (uart_kbhit())
27C2:  BTFSS  F9E.5
27C4:  BRA    280C
....................       {
....................          c=uart_getc();
27C6:  BRA    25EC
27C8:  MOVFF  01,82
....................          if (c=='\n') {usb_cdc_putc('\r'); usb_cdc_putc('\n');}
27CC:  MOVF   x82,W
27CE:  SUBLW  0A
27D0:  BNZ   27E0
27D2:  MOVLW  0D
27D4:  MOVWF  xAE
27D6:  RCALL  264C
27D8:  MOVLW  0A
27DA:  MOVWF  xAE
27DC:  RCALL  264C
27DE:  BRA    280C
....................          else if (c=='\r') {usb_cdc_putc('\r'); usb_cdc_putc('\n');}
27E0:  MOVF   x82,W
27E2:  SUBLW  0D
27E4:  BNZ   27F4
27E6:  MOVLW  0D
27E8:  MOVWF  xAE
27EA:  RCALL  264C
27EC:  MOVLW  0A
27EE:  MOVWF  xAE
27F0:  RCALL  264C
....................         #if defined(__PCM__)
27F2:  BRA    280C
....................          else if (c=='!') {uart_printf(usb_cdc_putc,"HELLO-WORLD-HELLO-WORLD-HELLO-WORLD-DONE");}
....................         #else
....................          else if (c=='!') {uart_printf(usb_cdc_putc,"HELLO-WORLD-HELLO-WORLD-HELLO-WORLD-HELLO-WORLD-HELLO-WORLD-HELLO-WORLD-HELLO-WORLD-HELLO-WORLD-DONE");}
27F4:  MOVF   x82,W
27F6:  SUBLW  21
27F8:  BNZ   2806
27FA:  MOVLW  46
27FC:  MOVWF  FF6
27FE:  MOVLW  21
2800:  MOVWF  FF7
2802:  BRA    2686
....................         #endif
2804:  BRA    280C
....................          else {usb_cdc_putc(c);}
2806:  MOVFF  82,AE
280A:  RCALL  264C
....................       }
....................       if (usb_cdc_kbhit())
280C:  BTFSS  1F.0
280E:  BRA    287E
....................       {
....................          c=usb_cdc_getc();
2810:  BRA    26A8
2812:  MOVFF  01,82
....................          buffer[i] = c;
2816:  CLRF   03
2818:  MOVF   xAB,W
281A:  ADDLW  83
281C:  MOVWF  FE9
281E:  MOVLW  00
2820:  ADDWFC 03,W
2822:  MOVWF  FEA
2824:  MOVFF  82,FEF
....................          i++;
2828:  INCF   xAB,F
....................          if(i>15){
282A:  MOVF   xAB,W
282C:  SUBLW  0F
282E:  BC    2840
....................             i=0;
2830:  CLRF   xAB
....................             printf(lcd_putc,"\f%s",buffer);
2832:  MOVLW  0C
2834:  MOVWF  xAE
2836:  RCALL  23A8
2838:  CLRF   FEA
283A:  MOVLW  83
283C:  MOVWF  FE9
283E:  BRA    26E0
....................          }
....................          
....................          
.................... //!         output_toggle(PIN_E0);
....................          if(c == 'a'){
2840:  MOVF   x82,W
2842:  SUBLW  61
2844:  BNZ   284C
....................             output_high(PIN_E0);
2846:  BCF    F96.0
2848:  BSF    F8D.0
....................          }else{
284A:  BRA    2850
....................             output_low(PIN_E0);
284C:  BCF    F96.0
284E:  BCF    F8D.0
....................          }
....................          if (c=='\n') {uart_putc('\r'); uart_putc('\n');}
2850:  MOVF   x82,W
2852:  SUBLW  0A
2854:  BNZ   2864
2856:  MOVLW  0D
2858:  MOVWF  xAC
285A:  RCALL  2710
285C:  MOVLW  0A
285E:  MOVWF  xAC
2860:  RCALL  2710
2862:  BRA    287E
....................          else if (c=='\r') {uart_putc('\r'); uart_putc('\n');}
2864:  MOVF   x82,W
2866:  SUBLW  0D
2868:  BNZ   2878
286A:  MOVLW  0D
286C:  MOVWF  xAC
286E:  RCALL  2710
2870:  MOVLW  0A
2872:  MOVWF  xAC
2874:  RCALL  2710
2876:  BRA    287E
....................          else {uart_putc(c);}
2878:  MOVFF  82,AC
287C:  RCALL  2710
....................       }
287E:  BRA    27BE
....................    }
.................... }
2880:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
